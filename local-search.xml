<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自用软件/项目/网站推荐</title>
    <link href="/2023/12/17/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6-%E9%A1%B9%E7%9B%AE-%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2023/12/17/%E8%87%AA%E7%94%A8%E8%BD%AF%E4%BB%B6-%E9%A1%B9%E7%9B%AE-%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>由于经常瞎折腾，经常反复重装系统，有些奇奇怪怪的东西会忘记掉，所以在这里记录下。当然Google是最好的找回办法。</p><h3 id="Goolge搜索高级用法"><a href="#Goolge搜索高级用法" class="headerlink" title="Goolge搜索高级用法"></a>Goolge搜索高级用法</h3><ol><li><p>限定关键词:用双引号””包裹</p></li><li><p>限定标题:intitle</p></li><li><p>限定内容:intext</p></li><li><p>限定网址:inurl</p></li><li><p>限定网站:site</p></li><li><p>限定图片大小:imagesize</p></li><li><p>限定文件类型:filetype</p></li></ol><h2 id="学习相关"><a href="#学习相关" class="headerlink" title="学习相关"></a>学习相关</h2><ul><li>Qwerty Learner –为键盘工作者设计的单词记忆与英语肌肉记忆锻炼软件 <a href="https://github.com/Kaiyiwing/qwerty-learner">项目地址</a></li><li>時雨の町 –日语学习网站 <a href="https://www.sigure.tw/">官方网址</a></li><li>Python –100天从新手到大师 <a href="https://github.com/jackfrued/Python-100-Days">项目地址</a></li></ul><h2 id="办公相关"><a href="#办公相关" class="headerlink" title="办公相关"></a>办公相关</h2><ul><li>Slidev –用MarkDown制作PPT <a href="https://github.com/slidevjs/slidev">项目地址</a></li><li>Google文档 –Google推出的办公套件 <a href="https://www.google.com/intl/zh-CN/docs/about/">官方网址</a></li></ul><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><ul><li>Hexo –强大的静态博客框架（Mac、Windows、Linux） <a href="https://hexo.io/">官方网址</a></li><li>Gridea –易用的静态博客写作客户端（Mac、Windows、Linux） <a href="https://github.com/getgridea/gridea">官方网址</a></li></ul><h2 id="站长工具"><a href="#站长工具" class="headerlink" title="站长工具"></a>站长工具</h2><ul><li>Google站长 <a href="https://search.google.com/">官方网址</a></li><li>Google分析 <a href="https://analytics.google.com/">官方网址</a></li><li>Super Tiny Icons –小体积SVG图像项目 <a href="https://github.com/edent/SuperTinyIcons">项目地址</a></li><li>聚合图床 –高速稳定的图片上传和外链服务 <a href="https://www.superbed.cn/">官方网址</a></li><li>阿里巴巴矢量图库 <a href="https://www.iconfont.cn/collections?personal=1">官方网址</a></li></ul><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><ul><li>VSCode –极其好用的IDE <a href="https://code.visualstudio.com/">官方网址</a></li><li>Android Studio –Android开发必备IDE <a href="https://developer.android.com/studio">官方网址</a></li><li>吾爱破解论坛 <a href="https://www.52pojie.cn/">论坛地址</a></li><li>Homebrew –Mac必备包管理软件 <a href="https://brew.sh/">官方网址</a></li></ul><h3 id="VSCode插件专区"><a href="#VSCode插件专区" class="headerlink" title="VSCode插件专区"></a>VSCode插件专区</h3><ul><li>vscode-icons – 在文件列表的文件名边加上图标 <a href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons">链接</a></li><li>Kite AutoComplete AI Code – 智能代码补全工具 <a href="https://marketplace.visualstudio.com/items?itemName=kiteco.kite">链接</a></li><li>Chinese (Traditional) Language Pack for Visual Studio Code – 中文插件 <a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant">链接</a></li><li>Bracket Pair Colorizer – 代码对着色器 <a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">链接</a></li></ul><h2 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h2><ul><li>🐋 Awesome TTRSS –方便部署的Tiny Tiny RSS Docker项目 <a href="https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E">官方网址</a></li><li>FeedMe –Android RSS订阅客户端 （<a href="https://play.google.com/store/apps/details?id=com.seazon.feedme&hl=zh&gl=US">Android</a>） <a href="https://github.com/seazon/FeedMe">官方网址</a></li><li>RSSHub –开源、简单易用、易于扩展的 RSS 生成器 <a href="https://docs.rsshub.app/">官方网址</a></li><li>Newlearnerの自留地 –Telegram资讯频道 <a href="https://t.me/NewlearnerChannel">频道链接</a></li></ul><h2 id="多媒体-x2F-音乐相关"><a href="#多媒体-x2F-音乐相关" class="headerlink" title="多媒体&#x2F;音乐相关"></a>多媒体&#x2F;音乐相关</h2><ul><li>YouTube Music –来自Google的音乐串流服务 （Web、Android、iOS）<a href="https://music.youtube.com/">官方网址</a></li><li>Netflix –优质的影视流媒体平台 <a href="https://www.netflix.com/">官方网址</a></li><li>巴哈姆特動畫瘋 –巴哈姆特电玩资讯站于台湾运营的OTT动画播放平台 <a href="https://ani.gamer.com.tw/">官方网址</a></li><li>IINA –干净的MacOS多媒体播放器 （Mac）<a href="https://iina.io/">官方网址</a></li><li>VLC –跨平台的多媒体播放器（Mac、Windows、Linux、Android、iOS）<a href="https://www.videolan.org/">官方网址</a></li><li>poweramp –强大的Android音乐播放器 <a href="https://powerampapp.com/">官方网址</a></li><li>Plex –跨平台的家庭影音中心（Mac、Windows、Linux、Android、iOS）<a href="https://www.plex.tv/">官方网址</a></li><li>Emby&#x2F;Jellyfin - 另外两个家庭影音中心</li><li>Disney+ – 迪士尼本家的流媒体平台 <a href="https://disneyplus.com/">官方网址</a></li><li>落雪音乐软件 —一个基于 electron 的音乐软件 <a href="https://github.com/lyswhut/lx-music-desktop">官网地址</a></li><li>YesPlayMusic —高颜值的第三方网易云播放器 <a href="https://github.com/qier222/YesPlayMusic">官网地址</a></li></ul><h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><ul><li>Telegram （Mac、Windows、Linux、Android、iOS、Web）<a href="https://telegram.org/">官方网址</a></li></ul><h2 id="网络穿透工具"><a href="#网络穿透工具" class="headerlink" title="网络穿透工具"></a>网络穿透工具</h2><ul><li><a href="https://github.com/Dreamacro/clash">Clash</a> （<a href="https://github.com/yichengchen/clashX">Mac</a>、<a href="https://github.com/Fndroid/clash_for_windows_pkg">Windows</a>、<a href="https://github.com/Kr328/ClashForAndroid">Android</a>、<a href="https://github.com/vernesong/OpenClash">OpenWrt</a>）</li><li>v2Ray –网络穿透工具箱 <a href="https://www.v2ray.com/">官方网址</a></li></ul><h2 id="电子书-x2F-漫画相关"><a href="#电子书-x2F-漫画相关" class="headerlink" title="电子书&#x2F;漫画相关"></a>电子书&#x2F;漫画相关</h2><ul><li>Tachiyomi –开源的Android漫画客户端 （Android) <a href="https://github.com/tachiyomiorg/tachiyomi">项目地址</a></li><li>Calibre –跨平台的电子书管理软件（Mac、Windows、Linux）<a href="https://calibre-ebook.com/">官方网址</a></li></ul><h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><ul><li>tgbot-collection&#x2F;YYeTsBot –开源的人人影视数据库 <a href="https://github.com/tgbot-collection/YYeTsBot">项目地址</a></li><li>Mox.moe –Kindle漫画下载站<a href="https://vol.moe/">官方网址</a></li><li>RARBG –影视磁力下载站 <a href="https://rarbg.to/">官方网址</a></li><li>日剧跑 –日剧资源分享站 <a href="https://www.rijupao.com/">官方网址</a></li><li>蜜柑计划 –番剧磁力下载站 <a href="https://mikanani.me/">官方网址</a></li><li>AGE动漫 –番剧网盘下载站 <a href="https://www.age.tv/">官方网址</a></li><li>次元狗动漫 –番剧网盘下载站 <a href="https://www.acgndog.com/">官方网址</a></li><li>二次元虫洞 –ACG资源论坛 <a href="http://www.2cycd.com/">论坛地址</a></li><li>ACG爱动漫 –ACG资源论坛 <a href="https://www.aidm12.com/">论坛地址</a></li><li>星空论坛 –ACG资源论坛 <a href="https://bbs.seikuu.com/forum.php">论坛地址</a></li><li>Hires后花园 –无损音乐论坛 <a href="https://dsdlove.com/forum.php">论坛地址</a></li><li>漫音社 –无损ACG音乐下载站 <a href="http://www.acgjc.com/">官方网址</a></li><li>sukidesuost –无损ACG音乐下载站 <a href="https://sukidesuost.info/">官方网址</a></li><li>点点字幕 –好用的字幕下载站 <a href="http://www.ddzimu.com/">官方网址</a></li><li>A4K字幕 –好用的字幕下载站 <a href="https://www.a4k.net/">官方网址</a></li><li>Xclient下载站 –MacOS软件下载站 <a href="https://xclient.info/?t=22dcd3c249bc291a24ef20acc97a97f9947a0846">xclient</a></li><li>pc6下载站 –MacOS软件下载站 <a href="http://www.pc6.com/mac/soft/">官方网址</a></li></ul><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul><li>Downie 4 –万用的Mac视频下载器（Mac）<a href="https://software.charliemonroe.net/downie/">官方网址</a></li><li>BitComet(比特彗星) –一款免费的BT&#x2F;HTTP&#x2F;FTP下载软件（Mac、Windows、Android）<a href="http://www.bitcomet.com/cn">官方网址</a></li><li>aria2 –跨平台下载工具（Mac、Windows、Linux）<a href="https://aria2.github.io/">官方网址</a></li><li>Motrix –跨平台下载工具（Mac、Windows、Linux）<a href="https://motrix.app/">官方网址</a></li></ul><h2 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h2><ul><li>Ubuntu <a href="https://ubuntu.com/">官方网址</a></li><li>Windows10 <a href="https://www.microsoft.com/zh-tw/software-download/windows10ISO">官方网址</a></li><li>OpenWrt <a href="https://mlapp.cn/369.html">第三方项目地址</a></li><li>Openwrt <a href="https://openwrt.ai/?target=x86/64&id=generic">OpenWrt软路由固件下载与在线定制编译</a></li><li>MacOS <a href="https://www.applex.net/pages/macos/">第三方论坛地址</a></li><li>Cros Updates Serving –ChromeOS镜像站 <a href="https://cros-updates-serving.appspot.com/">官方网址</a></li><li>Debian-Pi-Aarch64 ★ 全新树莓派64位系统 <a href="https://github.com/openfans-community-offical/Debian-Pi-Aarch64">项目地址</a></li><li>pixelexperience –好用的类原生Android ROM <a href="https://download.pixelexperience.org/">官方网址</a></li></ul><h2 id="私有云-x2F-分享站"><a href="#私有云-x2F-分享站" class="headerlink" title="私有云&#x2F;分享站"></a>私有云&#x2F;分享站</h2><ul><li>OLAINDEX –一款OneDrive目录文件索引应用 <a href="https://github.com/WangNingkai/OLAINDEX">项目地址</a></li><li>Cloudreve –以最低的成本快速搭建公私兼备的网盘系统 <a href="https://cloudreve.org/">官方网址</a></li><li>小雅Alist - <a href="https://alist.xiaoya.pro/">小雅的分类 Alist (xiaoya.pro)</a></li></ul><h2 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h2><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><ul><li>Radio Garden –收听全世界的广播 <a href="http://radio.garden/">官方网址</a></li></ul><h3 id="系统镜像烧录"><a href="#系统镜像烧录" class="headerlink" title="系统镜像烧录"></a>系统镜像烧录</h3><ul><li>balenaEtcher –跨平台镜像烧录工具（Mac、Windows、Linux）<a href="https://www.balena.io/etcher/">官方网址</a></li></ul><h3 id="MarkDown工具"><a href="#MarkDown工具" class="headerlink" title="MarkDown工具"></a>MarkDown工具</h3><ul><li>obsidian –跨平台的MarkDown写作工具（Mac、Windows、Linux、Android、iOS） <a href="https://obsidian.md/">官方网址</a></li><li>Typora - 一个非常优秀的MarkDown写作软件（Mac、Windows）<a href="https://typora.io/">官方网址</a></li></ul><h3 id="traceroute请求可视化"><a href="#traceroute请求可视化" class="headerlink" title="traceroute请求可视化"></a>traceroute请求可视化</h3><ul><li>BestTrace –一款优秀的traceroute请求可视化工具 <a href="https://www.ipip.net/product/client.html">官方网址</a></li></ul><h3 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h3><ul><li>tinypng –在线压缩图像的网站 <a href="https://tinypng.com/">官方网址</a></li><li>PP鸭 –图片压缩神器 <a href="https://ppduck.com/">官方网址</a></li></ul><h3 id="图像放大"><a href="#图像放大" class="headerlink" title="图像放大"></a>图像放大</h3><ul><li>bigjpg - 在线无损放大图像的网站 <a href="https://bigjpg.com/">官方网址</a></li></ul><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><ul><li>MacZip –一款干净的Mac解压缩工具（Mac）<a href="https://ezip.awehunt.com/">官方网址</a></li><li>Bandizip –一款跨平台解压缩工具（Mac、Windows）<a href="https://www.bandisoft.com/">官方网址</a></li><li>ZArchiver –一款Android平台好用的解压缩、文件管理工具<a href="https://play.google.com/store/apps/details?id=ru.zdevs.zarchiver&hl=zh&gl=US">Google Play</a></li></ul><h3 id="音频提取"><a href="#音频提取" class="headerlink" title="音频提取"></a>音频提取</h3><ul><li>XLD –Mac音频提取工具（Mac） <a href="https://sourceforge.net/projects/xld/">下载地址</a></li></ul><h3 id="音乐信息修改"><a href="#音乐信息修改" class="headerlink" title="音乐信息修改"></a>音乐信息修改</h3><ul><li>Music Tag Editor –一款Mac下音乐信息修改工具（Mac）<a href="http://www.yumysoft.com/">官方网址</a></li></ul><h3 id="视频-x2F-音频压制"><a href="#视频-x2F-音频压制" class="headerlink" title="视频&#x2F;音频压制"></a>视频&#x2F;音频压制</h3><ul><li>HandBrake –跨平台视频压制工具（Mac、Windows、Linux）<a href="https://handbrake.fr/">官方网址</a></li><li>Adapter –音视频压缩工具（Mac、Windows）<a href="https://macroplant.com/adapter">官方网址</a></li></ul><h3 id="配色工具"><a href="#配色工具" class="headerlink" title="配色工具"></a>配色工具</h3><ul><li>色采 –一款优秀的移动端配色应用（<a href="https://colorcollect.cn/apk/ColorCapture.apk">Android</a>、<a href="https://apps.apple.com/cn/app/id1439521846">iOS</a>）<a href="https://colorcollect.cc/"></a></li></ul><h3 id="网络抓包"><a href="#网络抓包" class="headerlink" title="网络抓包"></a>网络抓包</h3><ul><li>Fiddler –一款优秀的跨平台抓包工具（Mac、Windows、Linux）<a href="https://www.telerik.com/fiddler">官方网址</a></li></ul><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><ul><li>Termius –跨平台SSH工具 （Mac、Windows、Linux、Android、iOS）<a href="https://termius.com/">官方网址</a></li></ul><h3 id="局域网文件传输"><a href="#局域网文件传输" class="headerlink" title="局域网文件传输"></a>局域网文件传输</h3><ul><li>snapdrop –好用的局域网跨平台传输工具 <a href="https://snapdrop.net/">官方网址</a></li></ul><h3 id="Android-ROM解包工具"><a href="#Android-ROM解包工具" class="headerlink" title="Android ROM解包工具"></a>Android ROM解包工具</h3><ul><li>unpackandroidrom –基于Python的Android解包工具 <a href="https://github.com/AEnjoy/unpackandroidrom">项目地址</a></li></ul><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><ul><li>CodeTransmit –基于python的编码转换工具 （Mac、Windows、Linux）<a href="https://github.com/clorymmk/CodeTransmit">项目地址</a></li></ul><h3 id="订阅转换"><a href="#订阅转换" class="headerlink" title="订阅转换"></a>订阅转换</h3><ul><li>subconverter –网络穿透订阅链接转换服务项目 （Mac、Windows、Linux）<a href="https://github.com/tindy2013/subconverter">项目地址</a></li><li>sub-web –subconverter的Web前端 <a href="https://github.com/CareyWang/sub-web">项目地址</a></li><li>Clash rules –适用于 Clash Premium 内核的规则集（RULE-SET）<a href="https://github.com/Loyalsoldier/clash-rules">项目地址</a></li><li>subconverteriniexample –适用于 Clash Premium 内核的规则集 <a href="https://github.com/lzdnico/subconverteriniexample">项目地址</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Python中文指南：从零到一的零基础 Python 教程</title>
    <link href="/2023/10/18/Python%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E7%9A%84%E9%9B%B6%E5%9F%BA%E7%A1%80-Python-%E6%95%99%E7%A8%8B/"/>
    <url>/2023/10/18/Python%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E7%9A%84%E9%9B%B6%E5%9F%BA%E7%A1%80-Python-%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Python中文指南：从零到一的零基础-Python-教程"><a href="#Python中文指南：从零到一的零基础-Python-教程" class="headerlink" title="Python中文指南：从零到一的零基础 Python 教程"></a><strong>Python中文指南：从零到一的零基础 Python 教程</strong></h1><p><strong>版权归<a href="https://github.com/iswbm/python-guide">iswbm</a>所有</strong></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202310181427269.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202310181426965.webp"></p><h1 id="第一章：安装运行"><a href="#第一章：安装运行" class="headerlink" title="第一章：安装运行"></a>第一章：安装运行</h1><h2 id="1-1-【环境】快速安装-Python-解释器"><a href="#1-1-【环境】快速安装-Python-解释器" class="headerlink" title="1.1 【环境】快速安装 Python 解释器"></a>1.1 【环境】快速安装 Python 解释器</h2><p>Python 是一门解释性脚本语言，因此要想让你编写的代码得以运行，需要先安装 CPython 解释器。</p><p>根据你电脑的系统以及位数不同，安装步骤也有所差异。</p><ul><li>Windows 系统：系统无自带 Python 解释器，需要自行安装</li><li>Mac 系统：系统自带 Python 2.7，需要自行安装 Python 3</li></ul><p>由于 Python 2.x 已经不再维护了，因此本文会带大家安装CPython 最新版本： Python 3.9 （截止撰稿时最新：2020&#x2F;12&#x2F;16）。</p><p>同时本系列教程都将以 Python 3.9 版本进行讲解，不负责任的讲，可能是全网最新的 零基础系列教程。</p><h3 id="1-下载解释器"><a href="#1-下载解释器" class="headerlink" title="1. 下载解释器"></a>1. 下载解释器</h3><p>进入 <a href="https://www.python.org/downloads/windows/">Python 官网</a>，目前 Python 最新 Python 稳定版为 3.9，点击如下链接 </p><p><img src="http://image.iswbm.com/image-20201129172024424.png"></p><p>直接跳到最后，根据你电脑系统以及的位数</p><ul><li>Win 32 位：选择 <a href="https://www.python.org/ftp/python/3.9.0/python-3.9.0.exe">Windows x86 executable installer</a></li><li>Win 64 位：选择 <a href="https://www.python.org/ftp/python/3.9.0/python-3.9.0-amd64.exe">Windows x86-64 executable installer</a></li><li>Mac ：<a href="https://www.python.org/ftp/python/3.9.1/python-3.9.1-macosx10.9.pkg">Python-3.9.1-macosx10.9.pkg</a></li></ul><p><img src="http://image.iswbm.com/image-20201129172153677.png"></p><p>下载下来后，根据你的电脑系统选择后面的内容进行阅读。</p><h3 id="2-Win-安装"><a href="#2-Win-安装" class="headerlink" title="2. Win 安装"></a>2. Win 安装</h3><p>下载到本地后，双击打开开始安装</p><p><img src="http://image.iswbm.com/20201207164009.png"></p><p>记得勾选 <code>Add Python 3.9 to PATH</code>，这是把你的 Python 路径加入到系统环境变量中。如果不想自定义选择安装路径，可以直接点击 <code>Install Now</code>，如果要选择安装路径，点击下图位置。</p><p><img src="http://image.iswbm.com/20201207164148.png"></p><p>然后全部选上，然后点击  Next </p><p><img src="http://image.iswbm.com/20201207164207.png"></p><p>这里根据需要进行打勾，一般默认就行，然后点击 <code>Browse</code> ，选择你想要把 Python 安装到的哪那个目录里。</p><p>然后再直接点击  Install 开始安装。</p><p><img src="http://image.iswbm.com/20201207164309.png"></p><p>安装过程只要几分钟就行</p><p><img src="http://image.iswbm.com/20201207164451.png"></p><p>出现如下界面，说明安装过程已经结束。</p><p><img src="http://image.iswbm.com/20201207164957.png"></p><p>安装是安装上了，那么如何验证呢？</p><p>使用 windows 搜索 cmd，选择 <code>命令提示符</code> （我们把这个称之为你的终端）</p><p><img src="http://image.iswbm.com/20201207165111.png"></p><p>然后敲入 python ，若出现如下界面，则说明 Python 已经成功安装到你的机器上。</p><p><img src="http://image.iswbm.com/20201218200632.png"></p><h3 id="3-Mac-安装"><a href="#3-Mac-安装" class="headerlink" title="3. Mac 安装"></a>3. Mac 安装</h3><p>下载到本地后，双击打开开始安装</p><p><img src="http://image.iswbm.com/image-20201215124444268.png"></p><p>出现如下界面，一直点继续</p><p><img src="http://image.iswbm.com/image-20201215124456818.png"></p><p>直到出现如下界面，输入密码开始安装</p><p><img src="http://image.iswbm.com/image-20201215124710859.png"></p><p>安装的速度非常地快，大概在一分钟左右</p><p><img src="http://image.iswbm.com/image-20201215124720398.png"></p><p><img src="http://image.iswbm.com/image-20201215124935041.png"></p><p>打开Terminal 或者 iTerm（同样我们把这个称之为你的终端），输入 Python 3 ，如果进入如下界面，说明 Python3 已经安装完成。</p><p><img src="http://image.iswbm.com/image-20201215125120591.png"></p><h2 id="1-2-【环境】Python-开发环境的搭建"><a href="#1-2-【环境】Python-开发环境的搭建" class="headerlink" title="1.2 【环境】Python 开发环境的搭建"></a>1.2 【环境】Python 开发环境的搭建</h2><p>理论上只需要你安装了 CPython 解释器后，就可以开始写 Python 代码了。为了让你的在写代码时，有一个更加友好的编码体验。就有人开发了一堆的编辑器。</p><p>这些编辑器，具有代码高亮，代码提示自动补全的各种功能，如果没有这些编辑器，我想你没两天就会放弃编程这条路了。</p><p>因此在开始学习使用 Python 写代码时，首先要教大家搭建一个舒适的开发环境。</p><p>在这里我推荐大家使用 PyCharm 这个软件，它不只是一个简单编辑器，而是一个由 Jetbrain 公司为 Python 专门开发的 Python 语言集成开发环境。</p><p>也许你还不知道 Jetbrain ，我来简要介绍一下，Jetbrain  是一家专业的 IDE （Integrated Development Environment ）生产商，只要是市面上主流的编程语言，Jetbrain 都有相应的产品。</p><p>比如：Python 对应 PyCharm ，Golang 对应 Goland，Java 对应 IntelliJ IDEA，C 语言对应 Clion 等等。</p><p>在这些众多的 IDE 中，有一些提供了多种版本：<code>教育版</code>、<code>社区版</code> 和  <code>专业版</code>。</p><blockquote><p>PyCharm Edu is based on PyCharm Community Edition and comprises all its features, making it just perfectly suitable for writing professional projects with Python.</p></blockquote><p>教育版：教育版是免费的，具备社区版的所有功能，除此之外，还提供有一个教学功能，因此它更适合学生。老师可以用它创建教学，学生可以通过他完成教学任务。</p><p>社区版：就是阉割版的专业版，它也是免费的，如果你并不需要使用专业版才有那些功能，可以选择社区版。</p><p>专业版：提供所有 PyCharm 的功能，虽然是收费的，但是可以试用一个月。</p><p>社区版和专业版在功能上有哪些区别呢？你可以看下面这个表格。</p><p>可以看出专业版比社区版多了 <code>科学工具</code>、<code>WEB 开发</code>、<code>Python Web 框架</code>、<code>Python 代码分析</code>、<code>远程开发调试</code>、<code>数据库支持</code>。</p><p><img src="http://image.iswbm.com/20190506150523.png"></p><p>社区版的功能有限，有些非常好用的功能只有专业版才有，比如 远程调试。</p><p>如果你想使用到专业版，那有什么办法呢？</p><ol><li>有钱的就是大爷，付费购买。</li><li>穷人自有穷活法，每次试用一个月，试用期到，卸载干净，再来一次。</li><li>利用学生与教师的特权，可申请免费使用</li><li>若你有开源项目，也可以申请免费使用</li><li>用一些 <code>非寻常手段</code> （也就是破解）来实现。</li></ol><p>破解的方法，其实还分很多种：</p><ol><li>可以使用注册服务器的方式，优点是非常方便，缺点是过一段时间就有可能失效，不稳定。</li><li>还可以使用破解补丁的方式，优点是永久破解（使用期限到 2099 或者 2100年，某种意义上算是永久了），缺点是对于最新版的 PyCharm 你可能找不到相应的破解补丁。如果要使用这种方法，就意味着你得使用旧版的 PyCharm 。</li><li>使用绿色免安装的 PyCharm 安装包，其实原理和第二种一样，这一种只是别人帮你破解好，你直接用而已。只适用于 Windows 。</li></ol><p>那么这么多版本，该怎么选择呢？</p><p>一般来说：</p><ul><li>如果你是学生，那么可以直接向 Jetbrain 免费申请专业版。</li><li>如果你是新手，直接安装社区版就行了，功能已经够用了。</li><li>如果你想使用更多好用的 专业版功能，那么花钱去购买吧。</li></ul><p>如果你暂时付不起购买费用，可以加下面微信，我这有 <code>绿色免安装的专业版</code>，对，就是那种连安装都不用安装的 专业版。</p><p><img src="http://image.iswbm.com/image-20201218210141865.png"></p><h3 id="1-下载链接"><a href="#1-下载链接" class="headerlink" title="1. 下载链接"></a>1. 下载链接</h3><p>PyCharm for Windows ：<a href="https://www.jetbrains.com/pycharm/download/#section=windows">https://www.jetbrains.com/pycharm/download/#section=windows</a></p><p>PyCharm for  Mac ：<a href="https://www.jetbrains.com/pycharm/download/#section=mac">https://www.jetbrains.com/pycharm/download/#section=mac</a></p><p>PyCharm for  Linux ：<a href="https://www.jetbrains.com/pycharm/download/#section=linux">https://www.jetbrains.com/pycharm/download/#section=linux</a></p><p><img src="http://image.iswbm.com/20200901213017.png"></p><h3 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. 安装步骤</h3><p>下载完成后，双击 exe 文件</p><p><img src="http://image.iswbm.com/20200901213223.png"></p><p>选择安装目录，Pycharm需要的内存较多，建议将其安装在D盘或者E盘，不建议放在系统盘C盘：</p><p><img src="http://image.iswbm.com/20200901213310.png"></p><p>选好路径后，点击 Next ，创建桌面快捷方式等一系列选项参照下图勾选！</p><p><img src="http://image.iswbm.com/20200901213325.png"></p><p>最后默认安装即可，直接点击Install。</p><p><img src="http://image.iswbm.com/20200901213415.png"></p><p>7、耐心的等待两分钟左右。</p><p>之后就会得到下面的安装完成的界面</p><p><img src="http://image.iswbm.com/20200901213504.png"></p><p>点击Finish，Pycharm安装完成。</p><p>接下来对Pycharm进行配置，双击运行桌面上的Pycharm图标，进入下图界面：</p><p><img src="http://image.iswbm.com/20200901213526.png"></p><p>选择Do not import settings，之后选择OK，进入下一步。</p><p>下面是选择主题</p><p>-&gt; 这里默认选择黑色(左边黑色,右边白色)</p><p>-&gt; 点击Next:Featured plugins</p><p><img src="http://image.iswbm.com/20200901213602.png"></p><p>建议选择Darcula主题，该主题更有利于保护眼睛。</p><p>一切配置完成后，就会进入 PyCharm 的主界面。</p><p>首先，点击 <code>View</code> -&gt; <code>Appearance</code>  勾上 <code>Toolbar </code>，来调出工具栏，个人认为这个工具栏对于新手非常有用，使用频率很高。</p><p><img src="http://image.iswbm.com/20201218203225.png"></p><p>再然后，应该告诉 PyCharm 你的 CPython 解释器在哪里？不然后面要执行 Python 代码的时候，都不知道去哪里找。</p><p>点击 <code>File</code> -&gt; <code>Settings</code> ，就会出现如下界面，在搜索框输入 <code>interpreter</code> ，点击右上角的 <code>Add</code> </p><p><img src="http://image.iswbm.com/20201218203836.png"></p><p>跳到如下界面，再选择 <code>System Interpreter</code> ，然后右边选择你在上一节中安装 CPython 的路径。</p><p><img src="http://image.iswbm.com/20201218203632.png"></p><p>然后在文件夹下，新建一个 <code>demo.py</code> 的文件，并写入如下代码，然后再点击上面的 <code>Add Configuration</code> 配置脚本运行的参数</p><p><img src="http://image.iswbm.com/20201218204204.png"></p><p>接下来，我们要在 PyCharm 中运行这个 <code>demo.py</code> 这个脚本了。右键然后选择 <code>Run &#39;demo&#39;</code> ，或者直接按住快捷键：<code>Ctrl+Shift+F10</code></p><p><img src="http://image.iswbm.com/image-20201218204355375.png"></p><p>运行后，在下面就会弹出一个 <code>Run</code> 窗口，你在执行 Python 脚本时，所有的输出内容，都会出现在这里。</p><p><img src="http://image.iswbm.com/image-20201218204718039.png"></p><p>至此， PyCharm 这个非常好用的集成开发环境就配置完成了，后面我们就要正式开始接触代码了。</p><p>另外，关于 PyCharm 的使用，我花了两个月的时间，整理了一份非常实用且全面的 <a href="https://pycharm.iswbm.com/">《PyCharm 中文指南》</a>，点击这个链接，即可跳转学习：<a href="https://pycharm.iswbm.com/">https://pycharm.iswbm.com/</a></p><p><img src="http://image.iswbm.com/20200901220204.png"></p><h2 id="1-3-【基础】两种运行-Python-程序方法"><a href="#1-3-【基础】两种运行-Python-程序方法" class="headerlink" title="1.3 【基础】两种运行 Python 程序方法"></a>1.3 【基础】两种运行 Python 程序方法</h2><p>前两节我们安装好了 CPython 解释器，有了解释器，就可以运行 Python 程序了。</p><p>Python 程序的执行分为两种：</p><ol><li><p>使用Python Console 界面上执行 Python 语句</p></li><li><p>使用命令行执行 <code>.py</code> 后缀的脚本文件</p></li></ol><p>下面分别对这两种方法进行演示。</p><h3 id="1-第一种方法"><a href="#1-第一种方法" class="headerlink" title="1. 第一种方法"></a>1. 第一种方法</h3><p>首先打开你的终端，直接输入 <code>python3</code> 回车，然后输入 <code>print(&quot;Hello, World&quot;)</code>，就时候就会在屏幕上打印出 <code>Hello, World</code> 这几个字符。<code>print</code> 是 Python 的一个函数，通过它可以把你内容输出到终端屏幕上。这是我们写的第一行 Python 代码，调用的第一个 Python 函数，也是第一个 Python 程序。</p><p><img src="http://image.iswbm.com/20201218210312.png"> </p><h3 id="2-第二种方法"><a href="#2-第二种方法" class="headerlink" title="2. 第二种方法"></a>2. 第二种方法</h3><p>还记得我们在上一节中新建了个 Python 脚本文件 <code>demo.py</code> 吗？</p><p>当时我是使用 PyCharm 直接执行的，隐藏了一些运行细节，如果我不想通过 PyCharm 来执行脚本，有什么办法呢？</p><p>首先先进入脚本所在的文件夹，然后按住 <code>Shift</code> 和 右键，再点击如图位置打开 <code>PowerShell</code></p><p><img src="http://image.iswbm.com/image-20201218210755151.png"></p><p>然后在 <code>PowerShell</code> 中输入 <code>python dmeo.py</code>，就可以执行这个 python 脚本啦。</p><p><img src="http://image.iswbm.com/image-20201218210911124.png"></p><p>以上介绍了两种最原始的 Python 程序的执行方式。</p><h3 id="3-重要提示"><a href="#3-重要提示" class="headerlink" title="3. 重要提示"></a>3. 重要提示</h3><ol><li>在后面学习 Python 基础的时候，我在演示案例的时候，都会使用第一种方法（代码框里最前面会有 <code>&gt;&gt;&gt;</code> 标识），请你注意，后面不再提及。</li><li>实际上不管你使用哪个编辑器和 IDE 执行 Python 文件，它们的本质都是采用的第二种方法，因此这里很有必要向你介绍。</li></ol><h1 id="第二章：数据类型"><a href="#第二章：数据类型" class="headerlink" title="第二章：数据类型"></a>第二章：数据类型</h1><h2 id="2-1-【基础】常量与变量"><a href="#2-1-【基础】常量与变量" class="headerlink" title="2.1 【基础】常量与变量"></a>2.1 【基础】常量与变量</h2><p><strong>变量</strong>：在程序运行过程中，值会发生变化的量</p><p><strong>常量</strong>：在程序运行过程中，值不会发生变化的量</p><p>无论是变量还是常量，在创建时都会在内存中开辟一块空间，用于保存它的值。</p><h3 id="1-变量不需要声明类型"><a href="#1-变量不需要声明类型" class="headerlink" title="1. 变量不需要声明类型"></a>1. 变量不需要声明类型</h3><p>Python 的变量和常量不需要事先声明类型，这是根据Python的动态语言特性而来。</p><p>例如下面的 <code>age</code>  和 <code>name</code> 两个变量，在使用前没有进行任何的诸如 <code>age int</code> 和 <code>name string</code> 的类型声明，而这在一些静态语言中，比如 JAVA 和 Golang 中是必须的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;王炳明&quot;</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="2-赋值与比较"><a href="#2-赋值与比较" class="headerlink" title="2. 赋值与比较"></a>2. 赋值与比较</h3><p>Python 中 用 <code>=</code> 号来给变量赋值，比如下面这个表达式，age 这个变量的值就是 18</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>与之相似的，新手会容易混淆的是 两个等号 <code>==</code> ，它表示的是比较两个值是否相等，如果相等返回 <code>True</code>，如果不相等返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age == <span class="hljs-number">18</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age == <span class="hljs-number">17</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="3-先创建再使用"><a href="#3-先创建再使用" class="headerlink" title="3. 先创建再使用"></a>3. 先创建再使用</h3><p>每个变量在使用前都必须赋值，变量赋值以后才会被创建。</p><p>新的变量通过赋值的动作，创建并开辟内存空间，保存值。</p><p>如果没有赋值而直接使用，会抛出变量未定义的异常。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h3 id="4-赋值的方式"><a href="#4-赋值的方式" class="headerlink" title="4. 赋值的方式"></a>4. 赋值的方式</h3><p>赋值的两种方式</p><p>第一种：单个直接赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>第二种：多个批量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = b = c = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>第三种：先计算再赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 先计算 17+1，再把结果赋值给age</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">17</span>+<span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>第四种：分别赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, c = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="5-理解赋值的背后"><a href="#5-理解赋值的背后" class="headerlink" title="5. 理解赋值的背后"></a>5. 理解赋值的背后</h3><p>理解变量在计算机内存中的表示也非常重要。</p><p>当我们写：<code>a = &quot;Jack&quot;</code> 时，Python解释器干了两件事情：</p><ol><li><p>在内存中创建了一个<code>&#39;Jack&#39;</code>的字符串对象；</p></li><li><p>在内存中创建了一个名为a的变量，并把它指向 <code>&#39;Jack&#39;</code>。</p></li></ol><p>而当你把一个变量a赋值给另一个变量b，这个操作实际上是将变量b指向变量a所指向的数据，例如下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;Jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = a<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-string">&#x27;Jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)<br><span class="hljs-number">4332916664</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)<br><span class="hljs-number">4332916664</span><br></code></pre></td></tr></table></figure><p>通过<code> id()</code> 可以查看变量值的内存地址，打印出来的 a 和 b的内存地址是一样的，因此二者其实是一个数据。</p><p>但如果继续对 a 进行赋值其他值， 会发现 a 的内存地址变了，而 b 的并没有变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;Tom&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-string">&#x27;Tom&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)<br><span class="hljs-number">4332974128</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)<br><span class="hljs-number">4332916664</span><br></code></pre></td></tr></table></figure><p>请牢记：<strong>Python中的一切都是对象，变量是对象的引用！</strong>：</p><ul><li>执行a &#x3D; ‘Jack’，解释器创建字符串‘Jack’对象和变量a，并把a指向‘Jack’对象；</li><li>执行b &#x3D; a,解释器创建变量b，并且将其指向变量a指向的字符串‘Jack’对象；</li><li>执行a &#x3D; ‘Tom’,解释器创建字符串‘Tom’对象，并把a改为指向‘Tom’对象，与b无关。</li></ul><p><img src="http://image.iswbm.com/20210116171300.png"></p><h3 id="6-简单介绍常量"><a href="#6-简单介绍常量" class="headerlink" title="6. 简单介绍常量"></a>6. 简单介绍常量</h3><p>说完变量，还要说下常量。</p><p>常量就是不变的变量，比如常用的数学常数圆周率就是一个常量。在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>PI = <span class="hljs-number">3.14159265359</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>PI<br><span class="hljs-number">3.14159265359</span><br></code></pre></td></tr></table></figure><p>但事实上，从Python语法角度看，PI仍然是一个变量，因为Python根本没有任何机制保证PI不会被改变。你完全可以给PI赋值为10，不会弹出任何错误。所以，用全部大写的变量名表示常量只是一个习惯上的用法。</p><p>常量通常放置在代码的最上部，并作为全局使用。<img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="2-2-【基础】字符串类型"><a href="#2-2-【基础】字符串类型" class="headerlink" title="2.2 【基础】字符串类型"></a>2.2 【基础】字符串类型</h2><h3 id="1-如何定义字符串？"><a href="#1-如何定义字符串？" class="headerlink" title="1. 如何定义字符串？"></a>1. 如何定义字符串？</h3><p>字符串是Python中最常用的数据类型之一。</p><p>使用单引号或双引号来创建字符串，使用三引号创建多行字符串。字符串要么使用两个单引号，要么两个双引号，不能一单一双！Python不支持单字符类型，单字符在Python中也是作为一个字符串使用。</p><p>以下四种写法是等价的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name_1 = <span class="hljs-string">&#x27;Jack&#x27;</span>  <span class="hljs-comment"># 单引号</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name_2 = <span class="hljs-string">&quot;Jack&quot;</span>  <span class="hljs-comment"># 双引号</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name_3 =  <span class="hljs-string">&#x27;&#x27;&#x27;Jack&#x27;&#x27;&#x27;</span> <span class="hljs-comment"># 三个单引号</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name_4 = <span class="hljs-string">&quot;&quot;&quot;Jack&quot;&quot;&quot;</span>  <span class="hljs-comment"># 三个双引号</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name_1 == name_2 == name_3 == name_4<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>如果一个字符串里，要有引号，那么最好和外部包裹的引号类型不同，比如</p><ul><li>外层使用单引号，那么里层使用双引号</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&quot;my name is &#x27;Jack&#x27;&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg<br><span class="hljs-string">&quot;my name is &#x27;Jack&#x27;&quot;</span><br></code></pre></td></tr></table></figure><ul><li>外层使用双引号，那么里层使用单引号</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&#x27;my name is &quot;Jack&quot;&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg<br><span class="hljs-string">&#x27;my name is &quot;Jack&quot;&#x27;</span><br></code></pre></td></tr></table></figure><p>若想使用一样的符号呢？那字符串里的引号前记得加转义符号：<code>\</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&#x27;what\&#x27;s you name?&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg<br><span class="hljs-string">&quot;what&#x27;s you name?&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-常用的方法"><a href="#2-常用的方法" class="headerlink" title="2. 常用的方法"></a>2. 常用的方法</h3><p>字符串对象本身自带了许多非常实用的方法，考虑到新手的接受程序，在这里也没必要一一给你介绍。</p><p>本篇文章只会为你介绍最常用的那些方法，而剩下的你只要在需要的时候去过一下文档就 OK了。</p><p><strong>去除首尾空格</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&quot;    Python编程时光    &quot;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.lstrip()  <span class="hljs-comment"># 去除左边空格</span><br><span class="hljs-string">&#x27;Python编程时光    &#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.rstrip()  <span class="hljs-comment"># 去除右边空格</span><br><span class="hljs-string">&#x27;    Python编程时光&#x27;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.strip()  <span class="hljs-comment"># 去除左右两边空格</span><br><span class="hljs-string">&#x27;Python编程时光&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>判断字符串是否以某字符串开头</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&quot;Hello, Python&quot;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.startswith(<span class="hljs-string">&quot;Hello&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.startswith(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><strong>判断字符串是否以某字符串结尾</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">&quot;Hello, Python&quot;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.endswith(<span class="hljs-string">&quot;Python&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg.endswith(<span class="hljs-string">&quot;python&quot;</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><strong>格式化字符串</strong>：格式化字符串非常重要，在后面的章节中我有非常详细的讲解，这里你简单了解即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;王炳明&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg = <span class="hljs-string">f&quot;你好，我是<span class="hljs-subst">&#123;name&#125;</span>&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>msg<br><span class="hljs-string">&#x27;你好，我是王炳明&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>分割字符串</strong>：以逗号为分割符分割字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>languages = <span class="hljs-string">&quot;Python,Java,Golang&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>languages.split(<span class="hljs-string">&quot;,&quot;</span>)<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Golang&#x27;</span>]<br>```<span class="hljs-comment">## 2.3 【基础】整数与浮点数</span><br><br>Python 支持的数字类型有三种：整数、浮点数和复数。<br><br><span class="hljs-comment">### 1. 整数（Int）</span><br><br>通常被称为整型，是正或负整数，不带小数点。例如：<span class="hljs-number">1</span>，<span class="hljs-number">100</span>，-<span class="hljs-number">8080</span>，<span class="hljs-number">0</span>，等等。<br><br>```python<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = -<span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(b)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>表示数字的时候，有时我们还会用八进制或十六进制来表示：</p><ul><li><p>十六进制：用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2。</p></li><li><p>八进制：用0o前缀和0-7表示，例如0o12</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">0x0001</span> <span class="hljs-comment"># 十六进制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">0o01</span>  <span class="hljs-comment"># 八进制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(b)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="2-浮点数-Float"><a href="#2-浮点数-Float" class="headerlink" title="2. 浮点数(Float)"></a>2. 浮点数(Float)</h3><p>浮点数也就是小数，如1.23，3.14，-9.01，等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1.23</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">1.23</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，<code>1.23x10^9</code>和<code>12.3x10^8</code>是完全相等的。浮点数可以用数学写法，如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1.23e9</span><br><span class="hljs-number">1230000000.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">12.3e8</span><br><span class="hljs-number">1230000000.0</span><br></code></pre></td></tr></table></figure><h3 id="3-复数-Complex"><a href="#3-复数-Complex" class="headerlink" title="3. 复数(Complex)"></a>3. 复数(Complex)</h3><p>复数由实数部分和虚数部分构成，可以用<code>a + bj</code>，或者 <code>complex(a,b)</code> 表示，复数的实部a和虚部b都是浮点型。关于复数，不做科学计算或其它特殊需要，通常很难遇到，这里不做过多解释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span> + <span class="hljs-number">0.2j</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>(<span class="hljs-number">10</span>+<span class="hljs-number">0.2j</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;complex&#x27;</span>&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-built_in">complex</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0.2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>(<span class="hljs-number">10</span>+<span class="hljs-number">0.2j</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(b)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;complex&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h3><p><strong>两数运算</strong></p><p>两数相加减</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + b<br><span class="hljs-number">30</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b - a<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>两数相乘除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a * b<br><span class="hljs-number">200</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b / a<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>取模取余</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a // b<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a % b<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>计算绝对值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = -<span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(a)<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>数值直接取整</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">3.14</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(a)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">3.78</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(b)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>数值四舍五入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">3.14</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(a)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">3.78</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(b)<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="2-4-【基础】布尔值：真与假"><a href="#2-4-【基础】布尔值：真与假" class="headerlink" title="2.4 【基础】布尔值：真与假"></a>2.4 【基础】布尔值：真与假</h2><h3 id="1-什么是布尔值"><a href="#1-什么是布尔值" class="headerlink" title="1. 什么是布尔值"></a>1. 什么是布尔值</h3><p>但在Python语言中，布尔类型只有两个值</p><ul><li><code>True</code>：表示真值</li><li><code>False</code>：表示假值</li></ul><p>请注意，首字母要大写，不能是其它花式变型。</p><p>所有的计算结果，判断表达式调用返回值是True或者False的过程都可以称为布尔运算，例如比较运算。</p><p>布尔值通常用来判断条件是否成立。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">16</span><br><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你是个成年人&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你还未成年&quot;</span>)<br></code></pre></td></tr></table></figure><p>在 Python Shell 的模式下，很容易看出表达式返回的是真值还是假值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> &gt; <span class="hljs-number">5</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> == <span class="hljs-number">9</span>/<span class="hljs-number">3</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="2-布尔类型的转换"><a href="#2-布尔类型的转换" class="headerlink" title="2. 布尔类型的转换"></a>2. 布尔类型的转换</h3><p>Python内置的 <code>bool()</code> 函数可以用来测试一个表达式的布尔值结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">0</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>([])<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(())<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(&#123;&#125;)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-literal">None</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&quot;False&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-string">&quot;True&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">0.0</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-number">1.0</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(-<span class="hljs-number">0.0</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>看完上面的例子，可以总结出</p><p>下面这些值经过 bool 转换后是假值：</p><ul><li>0、0.0、-0.0</li><li>None：这个后面会讲到</li><li>空字符串、空列表、空元组、空字典</li></ul><p>而这些会转换成真值</p><ul><li>-1、1或者其他非0数值</li><li>所有非空字符串，包括 <code>&quot;False&quot;</code></li><li>所有非空字典、非空列表、非空集合，非空元组</li></ul><h3 id="3-布尔运算"><a href="#3-布尔运算" class="headerlink" title="3. 布尔运算"></a>3. 布尔运算</h3><p>布尔类型可以进行 and、or和 not运算。</p><p>and 运算是与运算，只有所有都为True，and运算的结果才是True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>or运算是或运算，只要其中有一个为True，or运算结果就是True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>not运算是非运算，它是单目运算符，把True变成False，False变成True：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>再开下脑洞，布尔类型还能做别的运算吗？试试就知道了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> &gt; <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> &lt; <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> &gt;=<span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> -<span class="hljs-number">1</span><br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> + <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> *<span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> -<span class="hljs-number">1</span><br>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>真的可以！比较运算，四则运算都没有问题。并且在做四则运算的时候，明显把True看做1，False看做0。往往是我们不知道的细节，有时候给我们带来巨大的困扰和疑惑。更多的运算种类支持，请大家自行测试。</p><h3 id="4-空值：None"><a href="#4-空值：None" class="headerlink" title="4. 空值：None"></a>4. 空值：None</h3><p>空值不是布尔类型，严格的来说放在这里是不合适的，只不过和布尔关系比较紧密。</p><p>空值是Python里一个特殊的值，用None表示（首字母大写）。None不能理解为 0，因为0是整数类型，而None是一个特殊的值。</p><p><strong>None也不是布尔类型，而是NoneType</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(<span class="hljs-literal">None</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="2-5-【基础】学会输入与输出"><a href="#2-5-【基础】学会输入与输出" class="headerlink" title="2.5 【基础】学会输入与输出"></a>2.5 【基础】学会输入与输出</h2><p>无论是从我们一开始的“hello world”，还是前面章节的里各种例子，基本都是些“自说自话”，展示类的代码片段。只有能够接收用户输入，根据输入动态生成结果，并输出到屏幕上展示出来，才算一个较为完整，起码是有那么点乐趣或者说成就的简单程序。</p><h3 id="1-input-输入函数"><a href="#1-input-输入函数" class="headerlink" title="1.  input 输入函数"></a>1.  input 输入函数</h3><p>input函数：获取用户输入，保存成一个<strong>字符串</strong>。重要的话，说两遍，input函数的返回值是一个字符串类型。哪怕你输入的是个数字1，返回给你的只会是字符串“1”，而不是 整数1。下面是一些简单的展示例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>name<br><span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(name)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>第一个例子中，<code>inp = input(&quot;please input your name: &quot;)</code>，input函数里可以提供一个字符串，用来给用户进行输入提示。input函数的返回值赋值给inp这个变量后，inp里就保存了用户输入的值。</p><p><code>type()</code> 是Python内置的函数之一，非常有用，用于查看对象的数据类型。例子中的 name 是一个str字符串类型，这验证了我们前面说的话。</p><p>如果你想要输入的是数值，那么需要你手动使用 <code>int()</code> 函数转一下类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your age: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your age: <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-string">&#x27;18&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-built_in">int</span>(age)<br><span class="hljs-meta">&gt;&gt;&gt; </span>age<br><span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(age)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>有时候可能输入两边会多敲入几个空格，这时候可以使用 <code>strip()</code> 函数去除首尾空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name  = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your name:      jack<br><span class="hljs-meta">&gt;&gt;&gt; </span>name<br><span class="hljs-string">&#x27;     jack&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>name = name.strip()<br><span class="hljs-meta">&gt;&gt;&gt; </span>name<br><span class="hljs-string">&#x27;jack&#x27;</span><br></code></pre></td></tr></table></figure><p>有时候用户输入的内容会不符合程序的预期，比如我想要获取年龄，那输入必然是全数字，而不能是其他非数值，这时候就可以使用 <code>isdigit</code> 函数进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please input your age: &quot;</span>)<br>please <span class="hljs-built_in">input</span> your age: jack<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> age.isdigit():<br><span class="hljs-meta">... </span>    age = <span class="hljs-built_in">int</span>(age)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你的年龄是: &quot;</span>, age)<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入不合法！&quot;</span>)<br>...<br>输入不合法！<br></code></pre></td></tr></table></figure><p>input函数有时可以巧妙地用于阻塞或暂停程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序前面部分执行完毕......&quot;</span>)<br><br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请按回车继续......&quot;</span>)       <span class="hljs-comment"># 在这里程序会暂停，等待你的回车动作</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;继续执行程序的后面部分......&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时的input函数不会将输入保存下来，只是用作暂停程序动作。</p><h3 id="2-print-输入函数"><a href="#2-print-输入函数" class="headerlink" title="2. print 输入函数"></a>2. print 输入函数</h3><p>print函数我们其实已经不陌生了，前前后后也用了不少次，多少有点经验，明白点它的用法了。</p><p>print函数用于将内容格式化显示在标准输出上，主要指的是屏幕显示器。</p><p>print可以接受多个字符串，字符串类型的变量或者可print的对象。每个字符串用逗号“,”隔开，连成一串输出。print会依次打印每个字符串，同时，每遇到一个逗号“,”就输出一个空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;i am&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&quot;student&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a,<span class="hljs-string">&quot;a&quot;</span> , b)<br>i am a student      <span class="hljs-comment"># 自动以空格分隔</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a+<span class="hljs-string">&quot;a&quot;</span>+b)<br>i amastudent        <span class="hljs-comment"># 无分隔</span><br></code></pre></td></tr></table></figure><p>对于形如<code>print(a+&quot;a&quot;+b)</code>的语句，其实是先计算<code>a+&quot;a&quot;+b</code>的值，然后再通过print打印它。print()会自动执行内部的语句，输出想要的结果。再看一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>((a, a*b)))        <span class="hljs-comment"># 先求a*b，再求和，再打印</span><br><span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>我们看一下print函数的原型：<code>print(self, *args, sep=&#39; &#39;, end=&#39;\n&#39;, file=None)</code></p><p><strong>sep参数</strong>: 分隔的符号，默认是一个空格；</p><p><strong>end参数</strong>: 打印后的结束方式，默认为换行符<code>\n</code>。如果，设置<code>end=&#39;&#39;</code>，则可以不换行，让print在一行内连续打印。活用print的参数，可以实现灵活的打印控制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;i am&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&quot;student&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a,<span class="hljs-string">&quot;a&quot;</span> , b, sep=<span class="hljs-string">&quot;*&quot;</span>)<br>i am*a*student<br></code></pre></td></tr></table></figure><h2 id="2-6-【基础】字符串格式化"><a href="#2-6-【基础】字符串格式化" class="headerlink" title="2.6 【基础】字符串格式化"></a>2.6 【基础】字符串格式化</h2><p>格式化输出，主要有三种方式</p><ol><li>使用 % 进行格式化</li><li>使用 format 函数进行格式化</li><li>使用 f-string 进行格式化</li></ol><p>由于这三种格式化的内容都非常的多，这里仅为了你看本教程后面的内容，我只介绍最常用的几种</p><h3 id="第一种方法：使用"><a href="#第一种方法：使用" class="headerlink" title="第一种方法：使用 %"></a>第一种方法：使用 %</h3><p><code>%s</code> 表示这个位置接的是一个字符串变量</p><p><code>%d</code> 表示这个位置接的是一个整型变量</p><p>前面有多少个 %，后面就要有多少个变量，一一对应，多个变量要括号括起来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是: %s，今年 %d 岁&quot;</span> %(name, age))<br>我的名字是: Jack，今年 <span class="hljs-number">18</span> 岁<br></code></pre></td></tr></table></figure><p>更多的格式化式符号，可以参考这张表</p><p><img src="http://image.iswbm.com/20201209211318.png"></p><h3 id="第二种方法：使用-format"><a href="#第二种方法：使用-format" class="headerlink" title="第二种方法：使用 format"></a>第二种方法：使用 format</h3><p>在字符串中，使用 <code>&#123;&#125;</code> 进行占位，然后在字符串后跟上 <code>.format()</code> 函数，这个函数的参数就是我们要往字符串中填充的变量。</p><p>format 函数会依次填充，比如第一个 <code>&#123;&#125;</code> 会取到第一个参数 name，第二个  <code>&#123;&#125;</code> 会取到第二个参数 age</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是:&#123;&#125;, 今年 &#123;&#125; 岁&quot;</span>.<span class="hljs-built_in">format</span>(name, age))<br>我的名字是:Jack, 今年 <span class="hljs-number">18</span> 岁<br></code></pre></td></tr></table></figure><p>然后如果变量值比较多的话，这样往往会看错乱掉。你可以改成使用索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是:&#123;0&#125;, 今年 &#123;1&#125; 岁&quot;</span>.<span class="hljs-built_in">format</span>(name, age))<br>我的名字是:Jack, 今年 <span class="hljs-number">18</span> 岁<br></code></pre></td></tr></table></figure><p>甚至还可以直接用变量名进行替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是:&#123;name&#125;, 今年 &#123;age&#125; 岁&quot;</span>.<span class="hljs-built_in">format</span>(name=name, age=age))<br>我的名字是:Jack, 今年 <span class="hljs-number">18</span> 岁<br></code></pre></td></tr></table></figure><p>更多 format 函数的用法，可详读我另一篇文章：<a href="https://www.cnblogs.com/wongbingming/p/6848701.html">Python强大的格式化format</a></p><h3 id="第三种方法：使用-f-string"><a href="#第三种方法：使用-f-string" class="headerlink" title="第三种方法：使用 f-string"></a>第三种方法：使用 f-string</h3><p>这种方法是 Python 3.6 才支持的写法，只要你在字符串前面加一个 <code>f</code>，开启 f-string ，就可以在字符中写入变量。</p><p>直接看案例了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&quot;Jack&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的名字是:<span class="hljs-subst">&#123;name&#125;</span>, 今年 <span class="hljs-subst">&#123;age&#125;</span> 岁&quot;</span>)<br>我的名字是:Jack, 今年 <span class="hljs-number">18</span> 岁<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="2-6-【基础】运算符（超全整理）"><a href="#2-6-【基础】运算符（超全整理）" class="headerlink" title="2.6 【基础】运算符（超全整理）"></a>2.6 【基础】运算符（超全整理）</h2><h3 id="0-什么是运算符？"><a href="#0-什么是运算符？" class="headerlink" title="0. 什么是运算符？"></a>0. 什么是运算符？</h3><p>本章节主要说明Python的运算符。举个简单的例子 <strong>4 +5 &#x3D; 9</strong> 。 例子中，4和5被称为操作数，”+”号为运算符。</p><p>Python语言支持以下类型的运算符:</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><p>接下来让我们一个个来学习Python的运算符。</p><hr><h3 id="1-Python算术运算符"><a href="#1-Python算术运算符" class="headerlink" title="1. Python算术运算符"></a>1. Python算术运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left">**</td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left">&#x2F;&#x2F;</td><td align="left">取整除 - 返回商的整数部分</td><td align="left">9&#x2F;&#x2F;2 输出结果 4 , 9.0&#x2F;&#x2F;2.0 输出结果 4.0</td></tr></tbody></table><p>以下实例演示了Python所有算术运算符的操作</p><p><strong>两数相加减</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a + b<br><span class="hljs-number">30</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b - a<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>两数相乘除</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a * b<br><span class="hljs-number">200</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b / a<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p><strong>取模取余</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a // b<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a % b<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="2-Python比较运算符"><a href="#2-Python比较运算符" class="headerlink" title="2. Python比较运算符"></a>2. Python比较运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a &#x3D;&#x3D; b) 返回 False。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a !&#x3D; b) 返回 true.</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td align="left">(a &lt; b) 返回 true。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;&#x3D; b) 返回 False。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;&#x3D; b) 返回 true。</td></tr></tbody></table><p>以下实例演示了Python所有比较运算符的操作：</p><p>判断两数是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a != b<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>判断 a 是否大于 b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a &gt; b<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a &lt; b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="3-Python赋值运算符"><a href="#3-Python赋值运算符" class="headerlink" title="3. Python赋值运算符"></a>3. Python赋值运算符</h3><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符</td><td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加法赋值运算符</td><td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减法赋值运算符</td><td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘法赋值运算符</td><td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除法赋值运算符</td><td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td align="left">%&#x3D;</td><td align="left">取模赋值运算符</td><td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td align="left">**&#x3D;</td><td align="left">幂赋值运算符</td><td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td align="left">&#x2F;&#x2F;&#x3D;</td><td align="left">取整除赋值运算符</td><td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><p>以下实例演示了Python所有赋值运算符的操作：</p><p>这里只以加减为例，其它的同理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a += <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a += <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a -= <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="4-Python位运算符"><a href="#4-Python位运算符" class="headerlink" title="4. Python位运算符"></a>4. Python位运算符</h3><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符</td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移动运算符</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移动运算符</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><p>以下实例演示了Python所有位运算符的操作：</p><p>与运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">60</span>  <span class="hljs-comment"># 60 = 0011 1100 </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">13</span>  <span class="hljs-comment"># 13 = 0000 1101 </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span> a &amp; b  <span class="hljs-comment"># 12 = 0000 1100</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>或运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a | b  <span class="hljs-comment">#  61 = 0011 1101 </span><br><span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p>异或运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a ^ b  <span class="hljs-comment"># 49 = 0011 0001</span><br><span class="hljs-number">49</span><br></code></pre></td></tr></table></figure><p>取反运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">60</span>  <span class="hljs-comment"># 60 = 0011 1100 </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>~a        <span class="hljs-comment"># -61 = 1100 0011</span><br>-<span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p>左移动运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">60</span>  <span class="hljs-comment"># 60 = 0011 1100 </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a &lt;&lt; <span class="hljs-number">2</span>  <span class="hljs-comment"># 240 = 1111 0000</span><br><span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p>右移动运算符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">60</span>  <span class="hljs-comment"># 60 = 0011 1100 </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a &gt;&gt; <span class="hljs-number">2</span>  <span class="hljs-comment"># 15 = 0000 1111</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="5-Python逻辑运算符"><a href="#5-Python逻辑运算符" class="headerlink" title="5. Python逻辑运算符"></a>5. Python逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><p>以上实例输出结果：</p><p>and：必须都为True，才能返回True，否则返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>or：只要有一个为True，就返回True，其他返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>not：与原值取反</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="6-Python成员运算符"><a href="#6-Python成员运算符" class="headerlink" title="6. Python成员运算符"></a>6. Python成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回True，否则返回False。</td><td align="left">x 在 y序列中 , 如果x在y序列中返回True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回True，否则返回False。</td><td align="left">x 不在 y序列中 , 如果x不在y序列中返回True。</td></tr></tbody></table><p>以下实例演示了Python所有成员运算符的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Apple&quot;</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>]<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Vivo&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>]<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="7-Python身份运算符"><a href="#7-Python身份运算符" class="headerlink" title="7. Python身份运算符"></a>7. Python身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is是判断两个标识符是不是引用自一个对象</td><td align="left">x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td></tr><tr><td align="left">is not</td><td align="left">is not是判断两个标识符是不是引用自不同对象</td><td align="left">x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td></tr></tbody></table><p>以下实例演示了Python所有身份运算符的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">1000</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">1000</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)<br><span class="hljs-number">4532310864</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)<br><span class="hljs-number">4532311632</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="8-Python运算符优先级"><a href="#8-Python运算符优先级" class="headerlink" title="8. Python运算符优先级"></a>8. Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* &#x2F; % &#x2F;&#x2F;</td><td align="left">乘，除，取模和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td align="left">比较运算符</td></tr><tr><td align="left">&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td align="left">等于运算符</td></tr><tr><td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not or and</td><td align="left">逻辑运算符</td></tr></tbody></table><p>以下实例演示了Python运算符优先级的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">20</span> + ( <span class="hljs-number">30</span> * <span class="hljs-number">2</span> ) / <span class="hljs-number">5</span><br><span class="hljs-number">32.0</span><br></code></pre></td></tr></table></figure><p>计算顺序是</p><ol><li>30*2 &#x3D; 60</li><li>60&#x2F;5 &#x3D; 12.0</li><li>20 + 12.0 &#x3D; 32.0</li></ol><h1 id="第三章：数据结构"><a href="#第三章：数据结构" class="headerlink" title="第三章：数据结构"></a>第三章：数据结构</h1><h2 id="3-1-【基础】列表"><a href="#3-1-【基础】列表" class="headerlink" title="3.1 【基础】列表"></a>3.1 【基础】列表</h2><p>列表（英文名 list），是由一系列元素按顺序进行排列而成的容器。</p><p>这里面有两个重点：</p><ul><li><strong>元素</strong>：没有要求同一类型，所以可以是任意类型。</li><li><strong>顺序</strong>：按顺序排列而成，说明列表是有序的。</li></ul><p>在接下来的例子中，我会向你演示，列表的一些特性和常用的方法。</p><h3 id="1-创建列表"><a href="#1-创建列表" class="headerlink" title="1. 创建列表"></a>1. 创建列表</h3><p>创建列表有两种方法</p><p><strong>第一种方法</strong>：先创建空列表实例，再往实例中添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = <span class="hljs-built_in">list</span>()   <span class="hljs-comment"># 实例化</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Apple&quot;</span>)  <span class="hljs-comment"># 添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Huawei&quot;</span>)  <span class="hljs-comment"># 添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Xiaomi&quot;</span>)  <span class="hljs-comment"># 添加元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：直接定义列表，并填充元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br></code></pre></td></tr></table></figure><p>很明显，第二种最简单直接，容易理解。并且经过测试，第二种的效率也比第一种的要高。因此推荐新手使用第二种。</p><h3 id="2-增删改查"><a href="#2-增删改查" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h3><p><strong>增删改查</strong>：是 新增元素、删除元素、修改元素、查看元素的简写。</p><p>由于，内容比较简单，让我们直接看演示</p><h4 id="查看元素"><a href="#查看元素" class="headerlink" title="查看元素"></a>查看元素</h4><p>使用 <code>[i]</code> 的方式查看第 <code>i+1</code> 个元素。例如 x 的起始值为 0 ，代表第一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;Apple&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;Huawei&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;Xiaomi&#x27;</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 index 方法，查看第一个值为 x 的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.index(<span class="hljs-string">&quot;Huawei&quot;</span>)<br><span class="hljs-number">1</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 count 方法，查看该列表中有几个值为 x </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.count(<span class="hljs-string">&quot;Huawei&quot;</span>)<br><span class="hljs-number">2</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用内置函数<code> len()</code>，可以查看该列表中有几个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(phones)<br><span class="hljs-number">3</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h4 id="新增元素"><a href="#新增元素" class="headerlink" title="新增元素"></a>新增元素</h4><p>使用列表的 append 、insert、和 extend 方法 </p><ul><li>append 方法：将元素插入在列表的最后一个位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = []<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Apple&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.append(<span class="hljs-string">&quot;Huawei&quot;</span>)  <span class="hljs-comment"># append 后 Huawei 会在最后一个位置</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><ul><li>insert 方法：将元素插入在列表的指定的位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;OPPO&quot;</span>)  <span class="hljs-comment"># 把 OPPO 插入到索引为 1 的位置</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;OPPO&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br></code></pre></td></tr></table></figure><ul><li>extend：将一个新的列表直接连接在旧的列表后面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_phones = [<span class="hljs-string">&quot;OPPO&quot;</span>, <span class="hljs-string">&quot;VIVO&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.extend(new_phones)<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;OPPO&#x27;</span>, <span class="hljs-string">&#x27;VIVO&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p>直接使用 <code>list[x]=new_item</code> 的方法直接替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;OPPO&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;OPPO&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>使用 pop ，remove 、clear 方法或者 del 语句删除元素</p><ul><li>pop 方法：删除指定位置的元素。默认删除最后一个元素，并返回</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.pop()  <span class="hljs-comment"># 删除最后一个元素</span><br><span class="hljs-string">&#x27;Xiaomi&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.pop(<span class="hljs-number">0</span>) <span class="hljs-comment"># 删除索引为0的元素</span><br><span class="hljs-string">&#x27;Apple&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Huawei&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><ul><li>remove：删除第一个值为 x 的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.remove(<span class="hljs-string">&quot;Huawei&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;Huawei&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><ul><li>clear 方法：把所有的元素清空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones.clear()<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><ul><li>del 语句：清空列表，还有另一种方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> phones[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 del 语句，还可以删除某一个或者某几个连续的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;OPPO&quot;</span>, <span class="hljs-string">&quot;VIVO&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> phones[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 删除索引为0的元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;OPPO&#x27;</span>, <span class="hljs-string">&#x27;VIVO&#x27;</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> phones[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># 删除索引在 [1:3) 区间内元素，注意是左闭右开区间</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>phones<br>[<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;VIVO&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="3-列表反转"><a href="#3-列表反转" class="headerlink" title="3. 列表反转"></a>3. 列表反转</h3><p>列表反转有两种方法</p><p><strong>第一种方法</strong>：使用自带的 reverse 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums.reverse()<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：使用切片的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>nums[::-<span class="hljs-number">1</span>]<br>[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>这两种方法，区别在于：</p><ul><li>reverse 方法是原地反转，作用在原对象上</li><li>切片反转是返回一个新对象，原对象不改变</li></ul><h3 id="4-列表排序"><a href="#4-列表排序" class="headerlink" title="4. 列表排序"></a>4. 列表排序</h3><p>列表的排序同样有两种方法：</p><p><strong>第一种方法</strong>：列表对象内置了 sort 方法，可方便我们对元素进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist.sort()<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：Python 有个内置的 sorted 函数，它不仅可用作列表的排序，后面我们还会学到 字典 等其他数据结构的排序也会用到它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(alist)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>不管用哪种方法，都要保证列表内的元素俩俩是可比较的。</p><p>比如，数值和数值是可比较的，字符串和字符串之间是可比较的。</p><p>但是数值和字符串是不可比较的，示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist.sort()<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">not</span> supported between instances of <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;int&#x27;</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>除了上面介绍的俩种之外，其实利用 sort 函数还可以实现自定义排序，这部分内容对于新手来说学习起来稍有点难度，且用到的场景也不多，因此这边我就不介绍啦。</p><h2 id="3-2-【基础】元组"><a href="#3-2-【基础】元组" class="headerlink" title="3.2 【基础】元组"></a>3.2 【基础】元组</h2><p>元组（英文名 tuple），和列表非常的相似，它也是由一系列元素按顺序进行排列而成的容器。</p><p>不同的是，元组是不可变的，而列表是可变的。</p><h3 id="1-创建元组"><a href="#1-创建元组" class="headerlink" title="1. 创建元组"></a>1. 创建元组</h3><p>创建元组有三种方法</p><p><strong>第一种方法</strong>：直接使用 圆括号 将所有的元素进行包围。这有别于创建列表时使用的是中括号：<code>[]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>atuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>atuple<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：有时候，创建元组时，圆括号可有可无的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>btuple = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>btuple<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>第三种方法</strong>：使用元组推导式，由于元组是不可变的，所以生成一个生成器对象。这一种对于新手来说可能会比较难以理解，我会放在后面专门进行讲解，这里先作了解，新手可直接跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x10a288f90</span>&gt;<br></code></pre></td></tr></table></figure><p>上面三种方法介绍完毕~</p><p>你以为就这么简单？</p><p>当你在创建只有一个元素的元组时，你有可能会这样子创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple = (<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(ctuple)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple<br><span class="hljs-number">1</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>却发现，创建出来的并不是 tuple，而是一个 int 对象。</p><p>此时千万要记住，当你创建只包含一个元素的元组时，要在第一个元素后面加一个逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(ctuple)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>ctuple<br>(<span class="hljs-number">1</span>,)<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dtuple = <span class="hljs-number">1</span>,<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(dtuple)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dtuple<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>另外，创建空元组可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">tuple</span>()  <span class="hljs-comment"># 第一种方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = ()  <span class="hljs-comment"># 第二种方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br>()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(b)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="2-增删改查-1"><a href="#2-增删改查-1" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h3><p>最前面我们说过，元组是不可变的。因此，你想对元组进行修改的行为都是不被允许的。</p><p>呐，看一下示例，查看元素可以，但是修改元素和删除元素都报错了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>atuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>atuple[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 查看元素</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>atuple[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br>  &gt;&gt;&gt;<br>  &gt;&gt;&gt; <span class="hljs-keyword">del</span> atuple[<span class="hljs-number">0</span>]<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> doesn<span class="hljs-string">&#x27;t support item deletion</span><br></code></pre></td></tr></table></figure><p>新增元素呢？当然同样也是不支持的，这里不再演示。</p><h3 id="3-元组与列表的转换"><a href="#3-元组与列表的转换" class="headerlink" title="3. 元组与列表的转换"></a>3. 元组与列表的转换</h3><p>虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。</p><p>元组是 immutable （不可变的），其序列通常包含不同种类的元素，并且通过解包或者索引来访问（如果是 <code>namedtuples</code> 的话甚至还可以通过属性访问）。</p><p>列表是 mutable （可变的），并且列表中的元素一般是同种类型的，并且通过迭代访问。</p><p>那有办法可以实现二者的转换吗？</p><p>当然有，而且非常简单。</p><p><strong>将元组转成列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>atuple = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(atuple)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(atuple)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>将列表转成元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(alist)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">tuple</span>(alist)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="3-3-【基础】字典"><a href="#3-3-【基础】字典" class="headerlink" title="3.3 【基础】字典"></a>3.3 【基础】字典</h2><p>字典（英文名 dict），它是由一系列的键值（key-value）对组合而成的数据结构。</p><p>字典中的每个键都与一个值相关联，其中</p><ol><li>键，必须是可 hash 的值，如字符串，数值等</li><li>值，则可以是任意对象</li></ol><h3 id="1-创建字典"><a href="#1-创建字典" class="headerlink" title="1. 创建字典"></a>1. 创建字典</h3><p>创建一个字典有三种方法</p><p><strong>第一种方法</strong>：先使用 <code>dict()</code> 创建空字典实例，再往实例中添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&quot;王炳明&quot;</span>, age=<span class="hljs-number">27</span>, 众号=<span class="hljs-string">&quot;ython编程时光&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;众号&#x27;</span>: <span class="hljs-string">&#x27;ython编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：直接使用 <code>&#123;&#125;</code> 定义字典，并填充元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三种方法</strong>：使用 <code>dict()</code> 构造函数可以直接从键值对序列里创建字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>info = [(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;王炳明 &#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">27</span>), (<span class="hljs-string">&#x27;公众号&#x27;</span>, <span class="hljs-string">&#x27;Python编程时光&#x27;</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dict</span>(info)<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明 &#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四种方法</strong>：使用字典推导式，这一种对于新手来说可能会比较难以理解，我会放在后面专门进行讲解，这里先作了解，新手可直接跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>adict = &#123;x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>)&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>adict<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">4</span>, <span class="hljs-number">4</span>: <span class="hljs-number">16</span>, <span class="hljs-number">6</span>: <span class="hljs-number">36</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-增删改查-2"><a href="#2-增删改查-2" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h3><p><strong>增删改查</strong>：是 新增元素、删除元素、修改元素、查看元素的简写。</p><p>由于，内容比较简单，让我们直接看演示</p><h4 id="查看元素-1"><a href="#查看元素-1" class="headerlink" title="查看元素"></a>查看元素</h4><p>查看或者访问元素，直接使用 <code>dict[key]</code> 的方式就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;公众号&quot;</span>]<br><span class="hljs-string">&#x27;Python编程时光&#x27;</span><br></code></pre></td></tr></table></figure><p>但这种方法，在 key 不存在时会报 KeyValue 的异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;gender&quot;</span>]<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>KeyError: <span class="hljs-string">&#x27;gender&#x27;</span><br></code></pre></td></tr></table></figure><p>所以更好的查看获取值的方法是使用 <code>get()</code> 函数，当不存在 gender 的key时，默认返回 male</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile.get(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>)<br><span class="hljs-string">&#x27;male&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="新增元素-1"><a href="#新增元素-1" class="headerlink" title="新增元素"></a>新增元素</h4><p>新增元素，直接使用 <code>dict[key] = value</code> 就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = <span class="hljs-built_in">dict</span>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;王炳明&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">27</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;公众号&quot;</span>] = <span class="hljs-string">&quot;Python编程时光&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">27</span>,<span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改元素-1"><a href="#修改元素-1" class="headerlink" title="修改元素"></a>修改元素</h4><p>修改元素，直接使用 <code>dict[key] = new_value</code> 就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">28</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">28</span>, <span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><p>删除元素，有三种方法</p><p><strong>第一种方法</strong>：使用 pop 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile.pop(<span class="hljs-string">&quot;age&quot;</span>)<br><span class="hljs-number">27</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>, <span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：使用 del 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> profile[<span class="hljs-string">&quot;age&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;王炳明&#x27;</span>, <span class="hljs-string">&#x27;公众号&#x27;</span>: <span class="hljs-string">&#x27;Python编程时光&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-重要方法"><a href="#3-重要方法" class="headerlink" title="3. 重要方法"></a>3. 重要方法</h3><h4 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h4><p>在 Python 2 中的字典对象有一个 has_key 函数，可以用来判断一个 key 是否在该字典中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile.has_key(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>profile.has_key(<span class="hljs-string">&quot;gender&quot;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>但是这个方法在 Python 3 中已经取消了，原因是有一种更简单直观的方法，那就是使用 <code>in</code> 和 <code>not in</code> 来判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> profile<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">in</span> profile<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="设置默认值"><a href="#设置默认值" class="headerlink" title="设置默认值"></a>设置默认值</h4><p>要给某个 key 设置默认值，最简单的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> profile:<br>    profile[<span class="hljs-string">&quot;gender&quot;</span>] = <span class="hljs-string">&quot;male&quot;</span><br></code></pre></td></tr></table></figure><p>实际上有个更简单的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">27</span>, <span class="hljs-string">&quot;公众号&quot;</span>: <span class="hljs-string">&quot;Python编程时光&quot;</span>&#125;<br>profile.setdefault(<span class="hljs-string">&quot;gender&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-4-【基础】集合"><a href="#3-4-【基础】集合" class="headerlink" title="3.4 【基础】集合"></a>3.4 【基础】集合</h2><p>集合（英文名 set），它是一个无序的不重复元素序列。</p><p>这里面有两个重点：</p><ol><li>无序，</li><li>不重复</li></ol><h3 id="1-创建集合"><a href="#1-创建集合" class="headerlink" title="1. 创建集合"></a>1. 创建集合</h3><p>集合的创建有两种方法</p><p><strong>第一种方法</strong>：使用 花括号 <code>&#123;&#125;</code> 直接创建，创建的时候，<code>&#123;&#125;</code> 可以包含有重要的元素，但是创建完后，集合会去重，只留第一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：使用 <code>set()</code> 方法进行创建，当<code> set()</code> 函数不接任何参数时，创建的是空集合，如果不创建空集合，可以传入一个列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bset = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 空集合</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bset<br><span class="hljs-built_in">set</span>([])<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>cset = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>cset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="2-增删改查-3"><a href="#2-增删改查-3" class="headerlink" title="2. 增删改查"></a>2. 增删改查</h3><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p>使用 <code>add</code> 函数可以往集合中传入函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = <span class="hljs-built_in">set</span>()<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([])<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.add(<span class="hljs-string">&quot;Apple&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.add(<span class="hljs-string">&quot;Huawei&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p>另外，还可以使用 <code>update</code> 函数，来往集合中添加元素，<code>update</code> 函数后可接集合，列表，元组，字典等。</p><p>这是接集合的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = <span class="hljs-built_in">set</span>()<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([])<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 接集合</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.update(&#123;<span class="hljs-string">&quot;Apple&quot;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Apple&#x27;</span>])<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 接列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.update([<span class="hljs-string">&quot;Huawei&quot;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 接元组</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.update((<span class="hljs-string">&quot;Xiaomi&quot;</span>,))<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 接字典</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.update(&#123;<span class="hljs-string">&quot;VIVO&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;VIVO&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a>删除元素</h4><p>使用 <code>remove</code> 函数可以删除集合中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.remove(<span class="hljs-string">&quot;Xiaomi&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用 <code>remove</code> 函数，如果对应的元素不存在，是会报错的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.remove(<span class="hljs-string">&quot;VIVO&quot;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>KeyError: <span class="hljs-string">&#x27;VIVO&#x27;</span><br></code></pre></td></tr></table></figure><p>对于这种情况，你可以使用 <code>discard</code> 函数，存在元素则移除，不存在也不会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.discard(<span class="hljs-string">&quot;VIVO&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p>此外，还有一个 <code>pop</code> 函数，用于从集合中随机删除元素，和列表、字典的 <code>pop</code> 不一样，这里的 pop 不能加任何的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.pop()<br><span class="hljs-string">&#x27;Huawei&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.pop()<br><span class="hljs-string">&#x27;Xiaomi&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.pop()<br><span class="hljs-string">&#x27;Apple&#x27;</span><br></code></pre></td></tr></table></figure><p>最后，还要介绍一个 <code>clear</code> 函数，它用于清空集合的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.clear()<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([])<br></code></pre></td></tr></table></figure><h4 id="修改元素-2"><a href="#修改元素-2" class="headerlink" title="修改元素"></a>修改元素</h4><p>文章开头处，已经说明了集合是 <code>无序</code> 的，因此集合是没有索引的。</p><p>既然没有索引，修改也无从谈起。</p><p><strong>记住</strong>：集合只有添加元素、删除元素。</p><h4 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h4><p>同上，没有顺序，也就没有索引，没有索引，查询也无从谈起。</p><p>但是我们可以查看集合的其他内容</p><p>比如，查看集合的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(aset)<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="3-集合运算"><a href="#3-集合运算" class="headerlink" title="3. 集合运算"></a>3. 集合运算</h3><h4 id="求合集"><a href="#求合集" class="headerlink" title="求合集"></a>求合集</h4><p>将两个集合进行合并并去重，可以使用 <code>union</code> 函数，下面的示例中，由于 <code>Huawei</code> 是重复的元素，只会保留一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.union(bset)<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br></code></pre></td></tr></table></figure><p>另外还可以使用 <code>|</code> 的操作符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset | bset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="求差集"><a href="#求差集" class="headerlink" title="求差集"></a>求差集</h4><p>要找出存在集合 A 但是不存在 集合 B 的元素，就是对两个集合求差集。</p><p>可以使用 <code>difference</code> 函数，下面的示例中， <code>Apple</code> 在 aset 中存在，但在 bset 中不存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.difference(bset)<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p>另外还可以使用 <code>-</code> 的操作符，更加直观</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset - bset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="求交集"><a href="#求交集" class="headerlink" title="求交集"></a>求交集</h4><p>要找出存在集合 A 并且存在集合 B 的元素，就是对两个集合求交集。</p><p>可以使用 <code>intersection</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.intersection(bset)<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>])<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>和 <code>intersection</code> 相似的还有一个 <code>intersection_update</code> 函数，它们的区别是，<code>intersection_update</code> 会原地更新在 aset 上，而不是会回交集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.intersection_update(bset)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>])<br></code></pre></td></tr></table></figure><p>另外还可以使用 <code>&amp;</code> 的操作符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset &amp; bset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Huawei&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="求不重合集"><a href="#求不重合集" class="headerlink" title="求不重合集"></a>求不重合集</h4><p>如果计算两个集合中不重复的元素集合，可以使用 <code>symmetric_difference</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.symmetric_difference(bset)<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Xiaomi&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>])<br></code></pre></td></tr></table></figure><p>和 <code>symmetric_difference</code> 相似的还有一个 <code>symmetric_difference_update</code> 函数，它们的区别是，<code>symmetric_difference_update</code> 会原地更新在 aset 上，而不是直接返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.symmetric_difference_update(bset)<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset<br><span class="hljs-built_in">set</span>([<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Xiaomi&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="4-集合判断"><a href="#4-集合判断" class="headerlink" title="4. 集合判断"></a>4. 集合判断</h3><h4 id="判断是否有某元素"><a href="#判断是否有某元素" class="headerlink" title="判断是否有某元素"></a>判断是否有某元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&quot;Apple&quot;</span> <span class="hljs-keyword">in</span> aset<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="判断两集合是否有相同元素"><a href="#判断两集合是否有相同元素" class="headerlink" title="判断两集合是否有相同元素"></a>判断两集合是否有相同元素</h4><p>如果两集合有相同元素，则返回 False，如果没有相同元素，则返回 True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Xiaomi&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>aset.isdisjoint(bset)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h4 id="判断是否是子集"><a href="#判断是否是子集" class="headerlink" title="判断是否是子集"></a>判断是否是子集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aset = &#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset = &#123;<span class="hljs-string">&quot;Huawei&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>bset.issubset(aset)<br><span class="hljs-literal">True</span><br>```![](http://image.iswbm.com/<span class="hljs-number">20210606214719.</span>png)<br><br><span class="hljs-comment">## 3.5 【基础】迭代器</span><br><br><span class="hljs-comment">### 1. 可迭代对象</span><br><br>可以利用 <span class="hljs-keyword">for</span> 循环的对象，都叫可迭代对象。<br><br>譬如我们前面学过的 列表、元组、字典、字符串等都是可迭代对象。<br><br>```python<br><span class="hljs-comment">## 以列表为例</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> alist:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i)<br>...<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="2-是否可迭代？"><a href="#2-是否可迭代？" class="headerlink" title="2. 是否可迭代？"></a>2. 是否可迭代？</h3><p>对 Python 比较熟悉的朋友，肯定知道哪些数据类型是可迭代的，哪些是不可迭代的。</p><p>但是对新手来说，可能需要借助一些函数来判别，比如 Python 内置的 <code>collections.abc</code> 模块，这个模块只有在 Python 中才有噢，在这个模块中提供了一个 Iterable 类，可以用 isinstance 来判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], Iterable) <span class="hljs-comment"># 列表</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>&#125;, Iterable) <span class="hljs-comment"># 字典</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), Iterable) <span class="hljs-comment"># 元组</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&quot;hello&quot;</span>, Iterable) <span class="hljs-comment"># 字符串</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>但是这种方法并不是百分百准确（具体下面会说到），最准确的方法，还是应该使用 for 循环。</p><h3 id="3-可迭代协议"><a href="#3-可迭代协议" class="headerlink" title="3. 可迭代协议"></a>3. 可迭代协议</h3><p>可迭代对象内部是如何实现在你对其进行 for 循环时，可以一个一个元素的返回出来呢？</p><p>这就要谈到迭代器协议。</p><p><strong>第一种场景</strong>：如果一个对象内部实现了 <code>__iter__()</code> 方法 ，并返回一个迭代器实例，那么该对象就是可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>:<br>    mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>    <br>    <span class="hljs-comment"># 返回迭代器类的实例</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.mylist)<br><br><span class="hljs-comment">## 得到可迭代对象</span><br>my_list = Array()  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(my_list, Iterable)) <span class="hljs-comment"># True</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p><strong>第二种场景</strong>：假设一个对象没有实现 <code>__iter__()</code> ，Python 解释器 <code>__getitem__()</code> 方法获取元素，如果可行，那么该对象也是一个可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>:<br>    mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.mylist[item]<br><br><span class="hljs-comment">## 得到一个可迭代对象</span><br>my_list = Array()  <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(my_list, Iterable)) <span class="hljs-comment"># False</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_list:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>此时如果你使用 <code>isinstance(my_list, Iterable)</code> 去判断是否是可迭代，就会返回 False，因为 isinstance 这种方法就是检查对象是否有 <code>__iter__</code> 方法。这也论证了使用 <code>isinstance(my_list, Iterable)</code>  去判断是否可迭代是不准确的。</p><h3 id="4-什么是迭代器"><a href="#4-什么是迭代器" class="headerlink" title="4. 什么是迭代器"></a>4. 什么是迭代器</h3><p>当你对一个可迭代对象使用 iter 函数后，它会返回一个迭代器对象，对于迭代器对象，我们可以使用 next 函数，去获取元素，每执行一次，获取一次，等到全部获取完毕，会抛出 StopIteration 提示无元素可取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = <span class="hljs-built_in">iter</span>(alist)<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;list_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x100a94b20</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><h3 id="5-迭代器协议"><a href="#5-迭代器协议" class="headerlink" title="5. 迭代器协议"></a>5. 迭代器协议</h3><p>对比可迭代对象，<code>迭代器</code>的内部只是多了一个函数而已 – <code>__next__()</code> </p><p>正因为有了它，我们才可以用 next 来获取元素。</p><p>迭代器，是在可迭代的基础上实现的。要创建一个迭代器，我们首先，得有一个可迭代对象。<br>现在就来看看，如何创建一个可迭代对象，并以可迭代对象为基础创建一个迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span>:<br>    index = <span class="hljs-number">0</span><br>    mylist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><br>    <span class="hljs-comment"># 返回该对象的迭代器类的实例</span><br>    <span class="hljs-comment"># 因为自己就是迭代器，所以返回self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-comment"># 当无元素时，必要抛出 StopIteration</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.index &lt;= <span class="hljs-built_in">len</span>(self.mylist)-<span class="hljs-number">1</span>:<br>            value = self.mylist[self.index]<br>            self.index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> value<br>        <span class="hljs-keyword">raise</span> StopIteration<br><br>my_iterator = <span class="hljs-built_in">iter</span>(Array())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(my_iterator, Iterator)) <span class="hljs-comment"># output: True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># output: 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># output: 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># output: 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(my_iterator))  <span class="hljs-comment"># StopIteration</span><br></code></pre></td></tr></table></figure><h2 id="3-6-【基础】生成器"><a href="#3-6-【基础】生成器" class="headerlink" title="3.6 【基础】生成器"></a>3.6 【基础】生成器</h2><h3 id="1-什么是生成器？"><a href="#1-什么是生成器？" class="headerlink" title="1. 什么是生成器？"></a>1. 什么是生成器？</h3><p>生成器（英文名 Generator ），是一个可以像迭代器那样使用for循环来获取元素的函数。</p><p>生成器的出现（Python 2.2 +），实现了延时计算，从而缓解了在大量数据下内存消耗过猛的问题。</p><p>当你在 Python Shell 中敲入一个生成器对象，会直接输出 <code>generator object</code> 提示你这是一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x10cae50b0</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="2-如何创建生成器？"><a href="#2-如何创建生成器？" class="headerlink" title="2. 如何创建生成器？"></a>2. 如何创建生成器？</h3><h4 id="使用列表推导式"><a href="#使用列表推导式" class="headerlink" title="使用列表推导式"></a>使用列表推导式</h4><p>在上面已经演示过，正常我们使用列表推导式时是下面这样子，使用 <code>[]</code> ，此时生成的是列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>mylist = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>mylist<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>而当你把 <code>[]</code> 换成 <code>()</code> ，返回的就不是列表了，而是一个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x10cae50b0</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="使用-yield"><a href="#使用-yield" class="headerlink" title="使用 yield"></a>使用 yield</h4><p><code>yield</code> 是什么东西呢? 它相当于我们函数里的 return，但与 return 又有所不同。</p><ul><li>当一个函数运行到 yield 后，函数的运行会暂停，并且会把 yield 后的值返回出去。</li><li>若 yield 没有接任何值，则返回 None</li><li>yield 虽然返回了，但是函数并没有结束</li></ul><p>请看如下代码，我定义了一个 <code>generator_factory</code> 函数，当我执行 <code>gen = generator_factory()</code> 时，gen 就是一个生成器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_factory</span>(<span class="hljs-params">top=<span class="hljs-number">5</span></span>):<br><span class="hljs-meta">... </span>    index = <span class="hljs-number">0</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> index &lt; top:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;index 值为: &quot;</span> + <span class="hljs-built_in">str</span>(index))<br><span class="hljs-meta">... </span>        index = index + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>        <span class="hljs-keyword">yield</span> index<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">raise</span> StopIteration<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = generator_factory()<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> generator_factory at <span class="hljs-number">0x1018340b0</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="3-生成器的使用"><a href="#3-生成器的使用" class="headerlink" title="3. 生成器的使用"></a>3. 生成器的使用</h3><p>从一个生成器对象中取出元素，和我们前面学过的通过切片访问列表中的元素不一样，它没有那么直观。</p><p>想要从生成器对象中取出元素，只有两种方法：</p><p><strong>第一种方法</strong>：使用 next 方法一个一个地把元素取出来，如果元素全部取完了，生成器会抛出 <code>StopIteration</code> 的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x1072400b0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><p><strong>第二种方法</strong>：使用 for 循环一个一个地迭代出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i)<br>...<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="4-生成器的激活"><a href="#4-生成器的激活" class="headerlink" title="4. 生成器的激活"></a>4. 生成器的激活</h3><p>生成器对象，在创建后，并不会执行任何的代码逻辑。</p><p>想要从生成器对象中获取元素，那么第一步要触发其运行，在这里称之为激活。</p><p>方法有两种：</p><ol><li>使用<code>next()</code> ：上面已经讲过</li><li>使用<code>generator.send(None)</code></li></ol><p>还以下面这段代码为例，可以看到 <code>gen.send(None)</code> 相当于执行了 <code>next(gen)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_factory</span>(<span class="hljs-params">top=<span class="hljs-number">5</span></span>):<br><span class="hljs-meta">... </span>    index = <span class="hljs-number">0</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> index &lt; top:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;index 值为: &quot;</span> + <span class="hljs-built_in">str</span>(index))<br><span class="hljs-meta">... </span>        index = index + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>        <span class="hljs-keyword">yield</span> index<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">raise</span> StopIteration<br>...<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = generator_factory()<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen.send(<span class="hljs-literal">None</span>)<br>index 值为: <span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>gen.send(<span class="hljs-literal">None</span>)<br>index 值为: <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="5-生成器的状态"><a href="#5-生成器的状态" class="headerlink" title="5. 生成器的状态"></a>5. 生成器的状态</h3><p>生成器在其生命周期中，会有如下四个状态</p><ul><li><code>GEN_CREATED</code>   # 生成器已创建，还未被激活</li><li><code>GEN_RUNNING</code>    # 解释器正在执行（只有在多线程应用中才能看到这个状态）</li><li><code>GEN_SUSPENDED</code>  # 在 yield 表达式处暂停</li><li><code>GEN_CLOSED</code>     # 生成器执行结束</li></ul><p>通过下面的示例可以很轻松地理解这一过程（<code>GEN_RUNNING</code> 这个状态只有在多线程中才能观察到，这里就不演示啦）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> getgeneratorstate<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>getgeneratorstate(gen)<br><span class="hljs-string">&#x27;GEN_CREATED&#x27;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>getgeneratorstate(gen)<br><span class="hljs-string">&#x27;GEN_SUSPENDED&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br><span class="hljs-meta">&gt;&gt;&gt; </span>getgeneratorstate(gen)<br><span class="hljs-string">&#x27;GEN_CLOSED&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="6-生成器的异常"><a href="#6-生成器的异常" class="headerlink" title="6. 生成器的异常"></a>6. 生成器的异常</h3><p>在最前面，我有定义了一个生成器函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_factory</span>(<span class="hljs-params">top=<span class="hljs-number">2</span></span>):<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> index &lt; top:<br>        index = index + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">yield</span> index<br>    <span class="hljs-keyword">raise</span> StopIteration<br></code></pre></td></tr></table></figure><p>在没有元素可返回时，我最后抛出了 <code>StopIteration</code> 异常，这是为了满足生成器的协议。</p><p>实际上，如果你不手动抛出 <code>StopIteration</code>，在生成器遇到函数 return 时，会我自动抛出 <code>StopIteration</code>。</p><p>请看下面代码，我将 <code>raise StopIteration</code> 去掉后，仍然会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_factory</span>(<span class="hljs-params">top=<span class="hljs-number">2</span></span>):<br><span class="hljs-meta">... </span>    index = <span class="hljs-number">0</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> index &lt; top:<br><span class="hljs-meta">... </span>        index = index + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>        <span class="hljs-keyword">yield</span> index<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = generator_factory()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(gen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><h1 id="第四章：控制流程"><a href="#第四章：控制流程" class="headerlink" title="第四章：控制流程"></a>第四章：控制流程</h1><h2 id="4-1-【基础】条件语句：if"><a href="#4-1-【基础】条件语句：if" class="headerlink" title="4.1 【基础】条件语句：if"></a>4.1 【基础】条件语句：if</h2><h3 id="1-简单小例子"><a href="#1-简单小例子" class="headerlink" title="1. 简单小例子"></a>1. 简单小例子</h3><p>如果满足条件 A，则执行代码块 a，否则执行代码块 b。类似这样的控制流程语句，称之为条件语句。</p><p>它的基本形式是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件：<br>    执行语句……<br><span class="hljs-keyword">else</span>：<br>    执行语句……<br></code></pre></td></tr></table></figure><p>举个最简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> age &gt;=<span class="hljs-number">18</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已经是成年人&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;还是未成年人&quot;</span>)<br>...<br>已经是成年人<br></code></pre></td></tr></table></figure><h3 id="2-多条件语句"><a href="#2-多条件语句" class="headerlink" title="2. 多条件语句"></a>2. 多条件语句</h3><p>如果需要多次判断可以利用 <code>elif</code>，它的基本形式是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> 判断条件<span class="hljs-number">1</span>：<br>    执行语句……<br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">2</span>：<br>    执行语句……<br><span class="hljs-keyword">elif</span> 判断条件<span class="hljs-number">3</span>：<br>    执行语句……<br><span class="hljs-keyword">else</span>:<br>    执行语句……<br></code></pre></td></tr></table></figure><p>举个最简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>score = <span class="hljs-number">75</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> score &gt;=<span class="hljs-number">90</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;优秀&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">80</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;良好&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">70</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;一般&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">elif</span> score &gt;= <span class="hljs-number">60</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;合格&quot;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不合格&quot;</span>)<br>...<br>一般<br></code></pre></td></tr></table></figure><h3 id="3-判断的条件"><a href="#3-判断的条件" class="headerlink" title="3. 判断的条件"></a>3. 判断的条件</h3><p>在 Python 中，值可以分为</p><ul><li><code>假值</code> ：None、空列表、空集合、空字典，空元组、空字符串、0、False 等</li><li><code>真值</code> ：非空列表、非空集合、非空字典，非空元组、非空字符串、非 0 数值、True 等</li></ul><p><code>if</code> 和 <code>elif</code> 后面可以接一个表达式（上面已经举例过），也可以接一个对象。</p><p>只要这个对象是真假，代码就会进入相应分支，如果为对象为假值，则继续下一判断。</p><p>这边随便以 0 和 1 举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>aint = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span> aint:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br>...<br>ok<br></code></pre></td></tr></table></figure><h3 id="4-多个条件组合"><a href="#4-多个条件组合" class="headerlink" title="4. 多个条件组合"></a>4. 多个条件组合</h3><p>在讲多个条件组合时，先来了解一下 Python 中的逻辑运算符。</p><p>以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td>(a and b) 返回 20。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not(a and b) 返回 False</td></tr></tbody></table><p>学习完逻辑运算符，就可以开始写多条件语句</p><ul><li>如果一个 if 条件需要同时满足多个条件，那么可以使用 <code>and</code>  或者 <code>&amp;</code></li><li>如果一个 if 条件只需要满足多个条件的其中一个，那么可以使用 <code>or</code> 或者 <code>|</code></li><li>如果一个 if 要求不满足某个条件，那么可以使用 <code>not</code> 或者 <code>!</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 需要同时满足条件 A 和条件 B</span><br><span class="hljs-keyword">if</span> 条件A <span class="hljs-keyword">and</span> 条件B:<br>...<br>  <br><span class="hljs-comment">## 只需要满足条件A或者条件B即可</span><br><span class="hljs-keyword">if</span> 条件A <span class="hljs-keyword">or</span> 条件B:<br>...<br>  <br><span class="hljs-comment">## 要求不满足条件A</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> 条件A:<br>...<br></code></pre></td></tr></table></figure><h2 id="4-2-【基础】循环语句：for"><a href="#4-2-【基础】循环语句：for" class="headerlink" title="4.2 【基础】循环语句：for"></a>4.2 【基础】循环语句：for</h2><p>for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p><p>它的基本语法是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 元素 <span class="hljs-keyword">in</span> 序列对象:<br>   代码块<br></code></pre></td></tr></table></figure><h3 id="1-普通循环"><a href="#1-普通循环" class="headerlink" title="1. 普通循环"></a>1. 普通循环</h3><p>直接上案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> phone <span class="hljs-keyword">in</span> phones:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前手机是: &quot;</span> + phone)<br>...<br>当前手机是: Apple<br>当前手机是: Huawei<br>当前手机是: Xiaomi<br></code></pre></td></tr></table></figure><h3 id="2-带索引循环"><a href="#2-带索引循环" class="headerlink" title="2. 带索引循环"></a>2. 带索引循环</h3><p>如果想在循环的时候，把索引也取出来，可以加一个 <code>enumerate</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>phones = [<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Huawei&quot;</span>, <span class="hljs-string">&quot;Xiaomi&quot;</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> index,phone <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(phones):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的第 &#123;&#125; 把手机是: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(index+<span class="hljs-number">1</span>, phone))<br>...<br>我的第 <span class="hljs-number">1</span> 把手机是: Apple<br>我的第 <span class="hljs-number">2</span> 把手机是: Huawei<br>我的第 <span class="hljs-number">3</span> 把手机是: Xiaomi<br></code></pre></td></tr></table></figure><h3 id="3-break-中断"><a href="#3-break-中断" class="headerlink" title="3. break 中断"></a>3. break 中断</h3><p>正常情况下，我们都需要 for 循环能够全部循环完，但在某些情况下，需要中断循环的执行，中断循环使用的是 <code>break</code> 关键字。</p><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前的数是 <span class="hljs-subst">&#123;i&#125;</span>, 将退出循环&quot;</span>)<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的数是 &quot;</span> + <span class="hljs-built_in">str</span>(i))<br>...<br>当前的数是 <span class="hljs-number">0</span><br>当前的数是 <span class="hljs-number">1</span>, 将退出循环<br></code></pre></td></tr></table></figure><h3 id="4-continue-下一循环"><a href="#4-continue-下一循环" class="headerlink" title="4. continue 下一循环"></a>4. continue 下一循环</h3><p>在有些循环中，不需要把 for 的循环体内的代码全部执行完毕，这种情况下，可以使用 <code>continue</code> 关键字，直接进入下一循环。</p><p>举个例子，下面的循环中当 i 等于 1 时，就直接跳过了循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">continue</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的数是 &quot;</span> + <span class="hljs-built_in">str</span>(i))<br>...<br>当前的数是 <span class="hljs-number">0</span><br>当前的数是 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="5-for-else-循环"><a href="#5-for-else-循环" class="headerlink" title="5. for - else 循环"></a>5. for - else 循环</h3><p>其实在 for 循环语句的后面，可以加一个 else 分支，当代码在 for 循环体中<strong>正常执行完</strong>，自然就会走到 else 分支中。</p><p>那么什么叫做 <strong>正常执行完</strong> 呢？就是只要不通过 break 语句中断的，都算正常执行完。</p><p>先以 continue 为例，所有的循环都非常正常，会走到 else 分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">continue</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的数是 &quot;</span> + <span class="hljs-built_in">str</span>(i))<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环非常正常&quot;</span>)<br>...<br>当前的数是 <span class="hljs-number">0</span><br>当前的数是 <span class="hljs-number">2</span><br>循环非常正常<br></code></pre></td></tr></table></figure><p>再把 <code>continue</code>  改成 <code>break</code> 后，发现不会走到 else 分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前的数是 &quot;</span> + <span class="hljs-built_in">str</span>(i))<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环非常正常&quot;</span>)<br>...<br>当前的数是 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="4-3-【基础】循环语句：while"><a href="#4-3-【基础】循环语句：while" class="headerlink" title="4.3 【基础】循环语句：while"></a>4.3 【基础】循环语句：while</h2><p>while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。</p><p>其基本形式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> 判断条件：<br>    执行语句<br></code></pre></td></tr></table></figure><h3 id="1-普通的循环"><a href="#1-普通的循环" class="headerlink" title="1. 普通的循环"></a>1. 普通的循环</h3><p>直接上案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> age &lt;= <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;孩子当前 <span class="hljs-subst">&#123;age&#125;</span> 岁，还不能上幼儿园&quot;</span>)<br>    age += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;年龄够了，可以上幼儿园了&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行后，输出结果</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">孩子当前<span class="hljs-number"> 1 </span>岁，还不能上幼儿园<br>孩子当前<span class="hljs-number"> 2 </span>岁，还不能上幼儿园<br>孩子当前<span class="hljs-number"> 3 </span>岁，还不能上幼儿园<br>年龄够了，可以上幼儿园了<br></code></pre></td></tr></table></figure><h3 id="2-无限的循环"><a href="#2-无限的循环" class="headerlink" title="2. 无限的循环"></a>2. 无限的循环</h3><p>当 while 后面的条件一直满足且循环体内一直没有 break ，此时 while 就会变成死循环，就是写 while 循环时千万要注意的。</p><p>会造成死循环，无非两种情况：</p><p>1、 使用 while True，而且循环体内又没有 break 或者 走不到 break</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    age += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2、 使用一个永远都会成立的判断条件，而且循环体内又没有 break 或者 走不到 break</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> age &gt; <span class="hljs-number">0</span>:<br>    age += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="3-while-else-语句"><a href="#3-while-else-语句" class="headerlink" title="3. while - else 语句"></a>3. while - else 语句</h3><p>和 for 循环一样， while 循环同样可以加一个 else 分支，当代码在 while 循环体中<strong>正常执行完</strong>，就会走到 else 分支中。</p><p>那么什么叫做 <strong>正常执行完</strong> 呢？就是只要不通过 break 语句中断的，都算正常执行完。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> age &lt;= <span class="hljs-number">3</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我已经 <span class="hljs-subst">&#123;age&#125;</span> 岁了&quot;</span>)<br><span class="hljs-meta">... </span>    age += <span class="hljs-number">1</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;可以上幼儿园了&quot;</span>)<br>...<br>我已经 <span class="hljs-number">1</span> 岁了<br>我已经 <span class="hljs-number">2</span> 岁了<br>我已经 <span class="hljs-number">3</span> 岁了<br>可以上幼儿园了<br></code></pre></td></tr></table></figure><p>如果在循环体内加 break ，就算是异常退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> age &lt;= <span class="hljs-number">3</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> age == <span class="hljs-number">2</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我已经 <span class="hljs-subst">&#123;age&#125;</span> 岁了&quot;</span>)<br><span class="hljs-meta">... </span>    age += <span class="hljs-number">1</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;可以上幼儿园了&quot;</span>)<br>...<br>我已经 <span class="hljs-number">1</span> 岁了<br>```![](http://image.iswbm.com/<span class="hljs-number">20210606214719.</span>png)<br><br><span class="hljs-comment">## 4.4 【进阶】五种推导式</span><br><br>推导式（英文名：comprehensions），也叫解析式，是Python的一种独有特性。<br><br>推导式是可以从一个数据序列构建另一个新的数据序列的结构体。<br><br>总共有四种推导式：<br><br><span class="hljs-number">1.</span> 列表(<span class="hljs-built_in">list</span>)推导式<br><br><span class="hljs-number">2.</span> 字典(<span class="hljs-built_in">dict</span>)推导式<br><br><span class="hljs-number">3.</span> 集合(<span class="hljs-built_in">set</span>)推导式<br><span class="hljs-number">4.</span> 生成器推导式<br><br><span class="hljs-comment">### 1. 列表推导式</span><br><br>列表推导式的基本格式<br><br>```python<br>new_list = [expression for_loop_expression <span class="hljs-keyword">if</span> condition]<br></code></pre></td></tr></table></figure><p>举个例子。</p><p>我想找出一个数值列表中为偶数的元素，并组成新列表，通常不用列表推导式，可以这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">old_list = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br>new_list = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> old_list:<br>    <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        new_list.append(item)<br><br><span class="hljs-built_in">print</span>(new_list) <span class="hljs-comment"># output: [0, 2, 4]</span><br></code></pre></td></tr></table></figure><p>一个简单的功能，写的代码倒是不少。</p><p>如果使用了列表推导式，那就简洁多了，而且代码还变得更加易读了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>old_list = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_list = [item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> old_list <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(new_list) <span class="hljs-comment"># output: [0, 2, 4]</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h3 id="2-字典推导式"><a href="#2-字典推导式" class="headerlink" title="2. 字典推导式"></a>2. 字典推导式</h3><p>字典推导式的基本格式，和 列表推导式相似，只是把 <code>[]</code> 改成了 <code>&#123;&#125;</code>，并且组成元素有两个：key 和 value，要用 <code>key_expr: value_expr </code> 表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">new_dict =&#123; key_expr: value_expr for_loop_expression <span class="hljs-keyword">if</span> condition &#125;<br></code></pre></td></tr></table></figure><p>举个例子。</p><p>我想从一个包含所有学生成绩信息的字典中，找出数学考满分的同学。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">old_student_score_info = &#123;<br>    <span class="hljs-string">&quot;Jack&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;chinese&quot;</span>: <span class="hljs-number">87</span>,<br>        <span class="hljs-string">&quot;math&quot;</span>: <span class="hljs-number">92</span>,<br>        <span class="hljs-string">&quot;english&quot;</span>: <span class="hljs-number">78</span><br>    &#125;,<br>    <span class="hljs-string">&quot;Tom&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;chinese&quot;</span>: <span class="hljs-number">92</span>,<br>        <span class="hljs-string">&quot;math&quot;</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-string">&quot;english&quot;</span>: <span class="hljs-number">89</span><br>    &#125;<br>&#125;<br><br>new_student_score_info = &#123;name: scores <span class="hljs-keyword">for</span> name, scores <span class="hljs-keyword">in</span> old_student_score_info.items() <span class="hljs-keyword">if</span> scores[<span class="hljs-string">&quot;math&quot;</span>] == <span class="hljs-number">100</span>&#125;<br><span class="hljs-built_in">print</span>(new_student_score_info)<br><span class="hljs-comment">## output: &#123;&#x27;Tom&#x27;: &#123;&#x27;chinese&#x27;: 92, &#x27;math&#x27;: 100, &#x27;english&#x27;: 89&#125;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-集合推导式"><a href="#3-集合推导式" class="headerlink" title="3. 集合推导式"></a>3. 集合推导式</h3><p>集合推导式跟列表推导式也是类似的。 唯一的区别在于它使用大括号<code>&#123;&#125;</code>，组成元素也只要一个。</p><p>基本格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">new_set = &#123; expr for_loop_expression <span class="hljs-keyword">if</span> condition &#125;<br></code></pre></td></tr></table></figure><p>举个例子</p><p>我想把一个数值列表里的数进行去重处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>old_list = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_set = &#123;item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> old_list&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(new_set)<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-生成器推导式"><a href="#4-生成器推导式" class="headerlink" title="4. 生成器推导式"></a>4. 生成器推导式</h3><p>生成器推导式跟列表推导式，非常的像，只是把 <code>[]</code> 换成了 <code>()</code></p><ul><li>列表推导式：生成的是新的列表</li><li>生成器推导式：生成的是一个生成器</li></ul><p>直接上案例了，找出一个数值列表中所有的偶数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>old_list = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_list = (item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> old_list <span class="hljs-keyword">if</span> item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>new_list<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x10292df10</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(new_list)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(new_list)<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="5-嵌套推导式"><a href="#5-嵌套推导式" class="headerlink" title="5. 嵌套推导式"></a>5. 嵌套推导式</h3><p>for 循环可以有两层，甚至更多层，同样的，上面所有的推导式，其实都可以写成嵌套的多层推导式。</p><p>但建议最多嵌套两层，最多的话，代码就会变得非常难以理解。</p><p>举个例子。</p><p>我想打印一个乘法表，使用两个for可以这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125;x&#123;&#125;=&#123;&#125;\t&#x27;</span>.<span class="hljs-built_in">format</span>(j, i, i*j), end=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">1x1</span>=1<br><span class="hljs-attribute">1x2</span>=2<span class="hljs-attribute">2x2</span>=4<br><span class="hljs-attribute">1x3</span>=3<span class="hljs-attribute">2x3</span>=6<span class="hljs-attribute">3x3</span>=9<br><span class="hljs-attribute">1x4</span>=4<span class="hljs-attribute">2x4</span>=8<span class="hljs-attribute">3x4</span>=12<span class="hljs-attribute">4x4</span>=16<br><span class="hljs-attribute">1x5</span>=5<span class="hljs-attribute">2x5</span>=10<span class="hljs-attribute">3x5</span>=15<span class="hljs-attribute">4x5</span>=20<span class="hljs-attribute">5x5</span>=25<br><span class="hljs-attribute">1x6</span>=6<span class="hljs-attribute">2x6</span>=12<span class="hljs-attribute">3x6</span>=18<span class="hljs-attribute">4x6</span>=24<span class="hljs-attribute">5x6</span>=30<span class="hljs-attribute">6x6</span>=36<br><span class="hljs-attribute">1x7</span>=7<span class="hljs-attribute">2x7</span>=14<span class="hljs-attribute">3x7</span>=21<span class="hljs-attribute">4x7</span>=28<span class="hljs-attribute">5x7</span>=35<span class="hljs-attribute">6x7</span>=42<span class="hljs-attribute">7x7</span>=49<br><span class="hljs-attribute">1x8</span>=8<span class="hljs-attribute">2x8</span>=16<span class="hljs-attribute">3x8</span>=24<span class="hljs-attribute">4x8</span>=32<span class="hljs-attribute">5x8</span>=40<span class="hljs-attribute">6x8</span>=48<span class="hljs-attribute">7x8</span>=56<span class="hljs-attribute">8x8</span>=64<br><span class="hljs-attribute">1x9</span>=9<span class="hljs-attribute">2x9</span>=18<span class="hljs-attribute">3x9</span>=27<span class="hljs-attribute">4x9</span>=36<span class="hljs-attribute">5x9</span>=45<span class="hljs-attribute">6x9</span>=54<span class="hljs-attribute">7x9</span>=63<span class="hljs-attribute">8x9</span>=72<span class="hljs-attribute">9x9</span>=81<br></code></pre></td></tr></table></figure><p>如果使用嵌套的列表推导式，可以这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span>.join([<span class="hljs-string">&#x27; &#x27;</span>.join([<span class="hljs-string">&#x27;%2d *%2d = %2d&#x27;</span> % (col, row, col * row) <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, row + <span class="hljs-number">1</span>)]) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]))<br> <span class="hljs-number">1</span> * <span class="hljs-number">1</span> =  <span class="hljs-number">1</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">2</span> =  <span class="hljs-number">2</span>  <span class="hljs-number">2</span> * <span class="hljs-number">2</span> =  <span class="hljs-number">4</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">3</span> =  <span class="hljs-number">3</span>  <span class="hljs-number">2</span> * <span class="hljs-number">3</span> =  <span class="hljs-number">6</span>  <span class="hljs-number">3</span> * <span class="hljs-number">3</span> =  <span class="hljs-number">9</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">4</span> =  <span class="hljs-number">4</span>  <span class="hljs-number">2</span> * <span class="hljs-number">4</span> =  <span class="hljs-number">8</span>  <span class="hljs-number">3</span> * <span class="hljs-number">4</span> = <span class="hljs-number">12</span>  <span class="hljs-number">4</span> * <span class="hljs-number">4</span> = <span class="hljs-number">16</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">5</span> =  <span class="hljs-number">5</span>  <span class="hljs-number">2</span> * <span class="hljs-number">5</span> = <span class="hljs-number">10</span>  <span class="hljs-number">3</span> * <span class="hljs-number">5</span> = <span class="hljs-number">15</span>  <span class="hljs-number">4</span> * <span class="hljs-number">5</span> = <span class="hljs-number">20</span>  <span class="hljs-number">5</span> * <span class="hljs-number">5</span> = <span class="hljs-number">25</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">6</span> =  <span class="hljs-number">6</span>  <span class="hljs-number">2</span> * <span class="hljs-number">6</span> = <span class="hljs-number">12</span>  <span class="hljs-number">3</span> * <span class="hljs-number">6</span> = <span class="hljs-number">18</span>  <span class="hljs-number">4</span> * <span class="hljs-number">6</span> = <span class="hljs-number">24</span>  <span class="hljs-number">5</span> * <span class="hljs-number">6</span> = <span class="hljs-number">30</span>  <span class="hljs-number">6</span> * <span class="hljs-number">6</span> = <span class="hljs-number">36</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">7</span> =  <span class="hljs-number">7</span>  <span class="hljs-number">2</span> * <span class="hljs-number">7</span> = <span class="hljs-number">14</span>  <span class="hljs-number">3</span> * <span class="hljs-number">7</span> = <span class="hljs-number">21</span>  <span class="hljs-number">4</span> * <span class="hljs-number">7</span> = <span class="hljs-number">28</span>  <span class="hljs-number">5</span> * <span class="hljs-number">7</span> = <span class="hljs-number">35</span>  <span class="hljs-number">6</span> * <span class="hljs-number">7</span> = <span class="hljs-number">42</span>  <span class="hljs-number">7</span> * <span class="hljs-number">7</span> = <span class="hljs-number">49</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">8</span> =  <span class="hljs-number">8</span>  <span class="hljs-number">2</span> * <span class="hljs-number">8</span> = <span class="hljs-number">16</span>  <span class="hljs-number">3</span> * <span class="hljs-number">8</span> = <span class="hljs-number">24</span>  <span class="hljs-number">4</span> * <span class="hljs-number">8</span> = <span class="hljs-number">32</span>  <span class="hljs-number">5</span> * <span class="hljs-number">8</span> = <span class="hljs-number">40</span>  <span class="hljs-number">6</span> * <span class="hljs-number">8</span> = <span class="hljs-number">48</span>  <span class="hljs-number">7</span> * <span class="hljs-number">8</span> = <span class="hljs-number">56</span>  <span class="hljs-number">8</span> * <span class="hljs-number">8</span> = <span class="hljs-number">64</span><br> <span class="hljs-number">1</span> * <span class="hljs-number">9</span> =  <span class="hljs-number">9</span>  <span class="hljs-number">2</span> * <span class="hljs-number">9</span> = <span class="hljs-number">18</span>  <span class="hljs-number">3</span> * <span class="hljs-number">9</span> = <span class="hljs-number">27</span>  <span class="hljs-number">4</span> * <span class="hljs-number">9</span> = <span class="hljs-number">36</span>  <span class="hljs-number">5</span> * <span class="hljs-number">9</span> = <span class="hljs-number">45</span>  <span class="hljs-number">6</span> * <span class="hljs-number">9</span> = <span class="hljs-number">54</span>  <span class="hljs-number">7</span> * <span class="hljs-number">9</span> = <span class="hljs-number">63</span>  <span class="hljs-number">8</span> * <span class="hljs-number">9</span> = <span class="hljs-number">72</span>  <span class="hljs-number">9</span> * <span class="hljs-number">9</span> = <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><h1 id="第五章：学习函数"><a href="#第五章：学习函数" class="headerlink" title="第五章：学习函数"></a>第五章：学习函数</h1><h2 id="5-1-【基础】普通函数创建与调用"><a href="#5-1-【基础】普通函数创建与调用" class="headerlink" title="5.1 【基础】普通函数创建与调用"></a>5.1 【基础】普通函数创建与调用</h2><p>函数是一种仅在调用时运行的代码块。您可以将数据（称为参数）传递到函数中，然后由函数可以把数据作为结果返回。</p><p>如果将函数比喻成蛋糕店的话，那么函数的参数就是生产蛋糕的原材料，而函数的返回值就是蛋糕成品。</p><h3 id="1-函数的创建"><a href="#1-函数的创建" class="headerlink" title="1. 函数的创建"></a>1. 函数的创建</h3><p>在 Python 中，使用 def 关键字定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数名</span>(<span class="hljs-params">参数</span>):<br>    <span class="hljs-comment"># 内部代码</span><br>    <span class="hljs-keyword">return</span> 表达式 <br></code></pre></td></tr></table></figure><p>举个例子，我这边手动实现一个计算两个数平均值的函数，这边这样子写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_average</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算平均值</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    result = (a + b)/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>在定义函数的过程中，需要注意以下几点：</p><ul><li>函数代码块以<code>def</code>关键词开头，一个空格之后接函数标识符名称和圆括号()，再接个冒号。</li><li>任何传入的参数必须放在圆括号中间。</li><li>函数的第一行语句后可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li>使用return，返回值给调用者，并结束函数。return 关键并不是必须要加，可根据实际需要决定是否要写，若不写的话，默认返回None。</li><li>return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束。</li></ul><h3 id="2-函数的调用"><a href="#2-函数的调用" class="headerlink" title="2. 函数的调用"></a>2. 函数的调用</h3><p>函数编写出来就是给人调用的。要调用一个函数，必须使用函数名后跟圆括号的方式才能调用函数。</p><p>调用的同时要根据函数的定义体，提供相应个数和类型的参数，每个参数之间用逗号分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_average</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算平均值</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    result = (a + b)/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> result<br>average = get_average(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(average)  <span class="hljs-comment"># output: 4</span><br></code></pre></td></tr></table></figure><h3 id="4-函数的返回"><a href="#4-函数的返回" class="headerlink" title="4. 函数的返回"></a>4. 函数的返回</h3><p>函数的返回值，可以是多种多样的，非常灵活：</p><ul><li><p>可以是任意类型的对象，比如字符串，数值，列表，字典等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li><li><p>可以是一个表达式，函数会直接运行表达式，然后返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_average</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> (a + b)/<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>可以是函数本身，利用这点可以实现递归调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>另外还可以返回多个值</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2.3</span> <br></code></pre></td></tr></table></figure><ul><li>可以是其他函数，利用这点可以实现装饰器。这部分属于进阶内容，感兴趣可查看另一章节内容：<a href="https://python.iswbm.com/c05/c05_06.html">5.6 精通装饰器的八种用法</a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-keyword">return</span> func()<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure></li></ul><h2 id="5-2-【基础】11个案例讲解函数参数"><a href="#5-2-【基础】11个案例讲解函数参数" class="headerlink" title="5.2. 【基础】11个案例讲解函数参数"></a>5.2. 【基础】11个案例讲解函数参数</h2><h3 id="1-参数分类"><a href="#1-参数分类" class="headerlink" title="1. 参数分类"></a>1. 参数分类</h3><p>函数，在定义的时候，可以有参数的，也可以没有参数。</p><p>从函数定义的角度来看，参数可以分为两种：</p><ol><li><code>必选参数</code>：调用函数时必须要指定的参数，在定义时没有等号</li><li><code>可选参数</code>：也叫<code>默认参数</code>，调用函数时可以指定也可以不指定，不指定就默认的参数值来。</li></ol><p>例如下面的代码中，a 和 b 属于必选参数， c 和 d 属于可选参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a,b,c=<span class="hljs-number">0</span>, d=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>从函数调用的角度来看，参数可以分为两种：</p><ol><li><code>关键字参数</code>：调用时，使用 key&#x3D;value 形式传参的，这样传递参数就可以不按定义顺序来。</li><li><code>位置参数</code>：调用时，不使用关键字参数的 key-value 形式传参，这样传参要注意按照函数定义时参数的顺序来。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a,b,c=<span class="hljs-number">0</span>, d=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">pass</span><br><br>  <span class="hljs-comment"># 关键字参数传参方法</span><br>func(a=<span class="hljs-number">10</span>, c=<span class="hljs-number">30</span>, b=<span class="hljs-number">20</span>, d=<span class="hljs-number">40</span>)<br><br>  <span class="hljs-comment"># 位置参数传参方法</span><br>func(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>最后还有一种非常特殊的参数，叫做<code>可变参数</code>。</p><p>意思是参数个数可变，可以是 0 个或者任意个，但是传参时不能指定参数名，通常使用 <code>*args</code> 和 <code>**kw</code> 来表示：</p><ul><li><code>*args</code>：接收到的所有按照位置参数方式传递进来的参数，是一个元组类型</li><li><code>**kw</code> ：接收到的所有按照关键字参数方式传递进来的参数，是一个字典类型</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*args, **kw</span>):<br>    <span class="hljs-built_in">print</span>(args)<br>    <span class="hljs-built_in">print</span>(kw)<br><br>func(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, c=<span class="hljs-number">20</span>, d=<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(10, 20)</span><br>&#123;<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">40</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-十一个案例"><a href="#2-十一个案例" class="headerlink" title="2. 十一个案例"></a>2. 十一个案例</h3><p><strong>案例一</strong>：在下面这个函数中， a 是必选参数，是必须要指定的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">a</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">10</span>) <br><span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func()  <span class="hljs-comment"># 不指定会报错</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: demo_func() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p> <strong>案例二</strong>：在下面这个函数中，b 是可选参数（默认参数），可以指定也可以不指定，不指定的话，默认为10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">b=<span class="hljs-number">10</span></span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">20</span>)<br><span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func()<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>案例三</strong>：在下面这个函数中， name 和 age 都是必选参数，在调用指定参数时，如果不使用关键字参数方式传参，需要注意顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_profile</span>(<span class="hljs-params">name, age</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;我的名字叫<span class="hljs-subst">&#123;name&#125;</span>，今年<span class="hljs-subst">&#123;age&#125;</span>岁了&quot;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>print_profile(<span class="hljs-string">&quot;王炳明&quot;</span>, <span class="hljs-number">27</span>)<br><span class="hljs-string">&#x27;我的名字叫王炳明，今年27岁了&#x27;</span><br></code></pre></td></tr></table></figure><p>如果参数太多，你不想太花精力去注意顺序，可以使用关键字参数方式传参，在指定参数时附上参数名，比如这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>print_profile(age=<span class="hljs-number">27</span>, name=<span class="hljs-string">&quot;王炳明&quot;</span>)<br><span class="hljs-string">&#x27;我的名字叫王炳明，今年27岁了&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>案例四</strong>：在下面这个函数中，<code>args</code> 参数和上面的参数名不太一样，在它前面有一个 <code>*</code>，这就表明了它是一个可变参数，可以接收任意个数的不指定参数名的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">*args</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(args)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p><strong>案例五</strong>：在下面这个函数中，<code>kw</code> 参数和上面的 <code>*args</code> 还多了一个 <code>*</code> ，总共两个 <code>**</code> ，这个意思是 <code>kw</code> 是一个可变关键字参数，可以接收任意个数的带参数名的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(kw)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(a=<span class="hljs-number">10</span>, b=<span class="hljs-number">20</span>, c=<span class="hljs-number">30</span>)<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例六</strong>：在定义时，必选参数一定要在可选参数的前面，不然运行时会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">a=<span class="hljs-number">1</span>, b</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a, b)<br><span class="hljs-meta">... </span><br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>SyntaxError: non-default argument follows default argument<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">a, b=<span class="hljs-number">1</span></span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a, b)<br><span class="hljs-meta">... </span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p><strong>案例七</strong>：在定义时，可变位置参数一定要在可变关键字参数前面，不然运行时也会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, *args</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, *args</span>):<br>                        ^<br>SyntaxError: invalid syntax<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">*args, **kw</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(args, kw)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><p><strong>案例八</strong>：可变位置参数可以放在必选参数前面，但是在调用时，必选参数必须要指定参数名来传入，否则会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">*args, b</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(args)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: demo_func() missing <span class="hljs-number">1</span> required keyword-only argument: <span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, b=<span class="hljs-number">100</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>案例九</strong>：可变关键字参数则不一样，可变关键字参数一定得放在最后，下面三个示例中，不管关键字参数后面接位置参数，还是默认参数，还是可变参数，都会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, a</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, a</span>):<br>                        ^<br>SyntaxError: invalid syntax<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, a=<span class="hljs-number">1</span></span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, a=<span class="hljs-number">1</span></span>):<br>                        ^<br>SyntaxError: invalid syntax<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, *args</span>):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">**kw, *args</span>):<br>                        ^<br>SyntaxError: invalid syntax<br></code></pre></td></tr></table></figure><p><strong>案例十</strong>：将上面的知识点串起来，四种参数类型可以在一个函数中出现，但一定要注意顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">arg1, arg2=<span class="hljs-number">10</span>, *args, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;arg1: &quot;</span>, arg1)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;arg2: &quot;</span>, arg2)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;args: &quot;</span>, args)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;kw: &quot;</span>, kw)<br></code></pre></td></tr></table></figure><p>试着调用这个函数，输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">1</span>,<span class="hljs-number">12</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, d=<span class="hljs-number">1000</span>, e=<span class="hljs-number">2000</span>)<br>arg1:  <span class="hljs-number">1</span><br>arg2:  <span class="hljs-number">12</span><br>args:  (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>)<br>kw:  &#123;<span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">2000</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例十一</strong>：使用单独的 <code>*</code>，当你在给后面的位置参数传递时，对你传参的方式有严格要求，你在传参时必须要以关键字参数的方式传参数，要写参数名，不然会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">a, b, *, c</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(a)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(b)<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: demo_func() takes <span class="hljs-number">2</span> positional arguments but <span class="hljs-number">3</span> were given<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, c=<span class="hljs-number">3</span>)<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="3-传参的坑"><a href="#3-传参的坑" class="headerlink" title="3. 传参的坑"></a>3. 传参的坑</h3><p>函数参数传递的是实际对象的内存地址。如果参数是引用类型的数据类型（列表、字典等），在函数内部修改后，就算没有把修改后的值返回回去，外面的值其实也已经发生了变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_item</span>(<span class="hljs-params">item, source_list</span>):<br><span class="hljs-meta">... </span>    source_list.append(item)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>add_item(<span class="hljs-number">2</span>, alist)<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><h2 id="5-3-【基础】匿名函数的使用"><a href="#5-3-【基础】匿名函数的使用" class="headerlink" title="5.3 【基础】匿名函数的使用"></a>5.3 【基础】匿名函数的使用</h2><p>匿名函数（英语：anonymous function）是指一类无需定义标识符（函数名）的函数。通俗来说呢，就是它可以让我们的函数，可以不需要函数名。</p><p>正常情况下，我们定义一个函数，使用的是 <code>def</code> 关键字，而当你学会使用匿名函数后，替代 <code>def</code> 的是 <code>lambda</code>。</p><p>这边使用<code>def</code> 和 <code>lambda</code> 分别举个例子，你很快就能理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mySum</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br>mySum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">## 5</span><br><br>(<span class="hljs-keyword">lambda</span> x, y: x+y)(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">## 6</span><br></code></pre></td></tr></table></figure><p>从上面的示例，我们可以看到匿名函数直接运行，省下了很多行的代码，有没有？</p><p>接下来，我们的仔细看一下它的用法</p><p>带 if&#x2F;else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;( <span class="hljs-keyword">lambda</span> x, y: x <span class="hljs-keyword">if</span> x &lt; y <span class="hljs-keyword">else</span> y )( <span class="hljs-number">1</span>, <span class="hljs-number">2</span> )<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>嵌套函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;( <span class="hljs-keyword">lambda</span> x: ( <span class="hljs-keyword">lambda</span> y: ( <span class="hljs-keyword">lambda</span> z: x + y + z  )( <span class="hljs-number">1</span> ) )( <span class="hljs-number">2</span> ) )( <span class="hljs-number">3</span> )<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>递归函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>func = <span class="hljs-keyword">lambda</span> n:<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> n * func(n-<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">5</span>)<br><span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-keyword">lambda</span> func, n: <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> n * func( func, n - <span class="hljs-number">1</span> )<br><span class="hljs-meta">&gt;&gt;&gt; </span>f(f,<span class="hljs-number">4</span>)<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>从以上示例来看，lambda 表达式和常规的函数相比，写法比较怪异，可读性相对较差。除了可以直接运行之外，好像并没有其他较为突出的功能，为什么在今天我们要介绍它呢？</p><p>首先我们要知道 lambda 是一个表达式，而不是一个语句。正因为这个特点，我们可以在一些特殊的场景中去使用它。具体是什么场景呢？接下来我们会介绍到几个非常好用的内置函数。</p><h2 id="5-4-【基础】必学高阶函数"><a href="#5-4-【基础】必学高阶函数" class="headerlink" title="5.4 【基础】必学高阶函数"></a>5.4 【基础】必学高阶函数</h2><h3 id="1-map-函数"><a href="#1-map-函数" class="headerlink" title="1. map 函数"></a>1. map 函数</h3><p>map 函数，它接收两个参数，第一个参数是一个函数对象（当然也可以是一个lambda表达式），第二个参数是一个序列。</p><p>它可以实现怎样的功能呢，我举个例子你就明白了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x*<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>可以很清楚地看到，它可以将后面序列中的每一个元素做为参数传入lambda中。</p><p>当我们不使用 map 函数时，你也许会这样子写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mylist=[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]:<br>    mylist.append(i*<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="2-filter-函数"><a href="#2-filter-函数" class="headerlink" title="2. filter 函数"></a>2. filter 函数</h3><p>filter 函数，和 map 函数相似。同样也是接收两个参数，一个lambda 表达式，一个序列。它会遍历后面序列中每一个元素，并将其做为参数传入lambda表达式中，当表达式返回 True，则元素会被保留下来，当表达式返回 False ，则元素会被丢弃。</p><p>下面这个例子，将过滤出一个列表中小于0的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &lt; <span class="hljs-number">0</span>, <span class="hljs-built_in">range</span>(-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br>[-<span class="hljs-number">5</span>, -<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="3-reduce-函数"><a href="#3-reduce-函数" class="headerlink" title="3. reduce 函数"></a>3. reduce 函数</h3><p>reduce 函数，也是类似的。它的作用是先对序列中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 lambda 函数运算，将其得到的结果再与第四个元素进行运算，以此类推下去直到后面没有元素了。</p><p><img src="http://image.iswbm.com/20200930175131.png"></p><p>这边举个例子你也就明白了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;reduce(<span class="hljs-keyword">lambda</span> x,y: x+y, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>它的运算过程分解一下是这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>+<span class="hljs-number">2</span>=<span class="hljs-number">3</span><br><span class="hljs-number">3</span>+<span class="hljs-number">3</span>=<span class="hljs-number">6</span><br><span class="hljs-number">6</span>+<span class="hljs-number">4</span>+<span class="hljs-number">10</span><br><span class="hljs-number">10</span>+<span class="hljs-number">5</span>=<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点"></a>4. 注意点</h3><p>以上几个函数，熟练的掌握它们的写法，可以让我们的代码看起来更加的 Pythonic ，在某一程度上代码看起来更加的简洁。</p><p>如果你是新手呢，你需要注意的是，以上示例是在 Python2.x 环境下演示的。而在 Python3.x 中，却有所不同，你可以自己尝试一下。</p><p>这里总结一下：</p><p>第一点，map 和 filter 函数返回的都不再是一个列表，而是一个迭代器对象。这里以map为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>map_obj = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x*<span class="hljs-number">2</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(map_obj, Iterator)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(map_obj)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(map_obj)<br>[<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>第二点，reduce 不可以直接调用，而是要先导入才能使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="5-5-【基础】反射函数的使用"><a href="#5-5-【基础】反射函数的使用" class="headerlink" title="5.5 【基础】反射函数的使用"></a>5.5 【基础】反射函数的使用</h2><p>自省，在我们日常生活中，通常是自我反省的意思。</p><p>但在计算机编程中，自省并不是这个意思，它的英文单词是 introspection，表示的是自我检查的行为或能力。</p><p>它的内容包括</p><ol><li>告诉别人，我是谁</li><li>告诉别人，我能做什么</li></ol><p>Python 是一门动态语言，有了自省，就能让程序在运行时能够获知对象的类型以及该对象下有哪些方法等。</p><h3 id="1-学习-Python-模块的入口"><a href="#1-学习-Python-模块的入口" class="headerlink" title="1. 学习 Python 模块的入口"></a>1. 学习 Python 模块的入口</h3><h4 id="help"><a href="#help" class="headerlink" title="help()"></a>help()</h4><p>在 console 模式下，输入 <code>help()</code> ，可以看到输出了一段帮助文档，教你如何使用这个 help，当你看到提示符变成了 <code>help&gt;</code> 时，这时候就进入了 help 模式。</p><p><img src="http://image.iswbm.com/image-20200606121047415.png"></p><p>此时你可以键入你想要了解的模块、语法等，help 告诉你如何使用。</p><p>比如我输入 keywords ，就可以看到 Python 里所有的关键字。再输入 modules 就可以查看 Python 中所有的内置模块。</p><p><img src="http://image.iswbm.com/image-20200606121544062.png"></p><p>输入 modules + <code>指定包名</code>，就可以查看这个包下有哪些模块</p><p><img src="http://image.iswbm.com/image-20200606121942898.png"></p><p>如果你想学习某个包要如何使用，可以直接在 help 模式下输入 <code>包名</code>，就像下面这样，我就可以获得一份 json 的帮助文档。</p><p><img src="http://image.iswbm.com/image-20200606122408522.png"></p><p>如果你想学习某个关键字的用法，可以在 help 模式下直接键入 <code>关键字</code> 查询用法，比如我直接键入 <code>for</code> 。</p><p><img src="http://image.iswbm.com/image-20200606133933401.png"></p><p>查完后，使用 quit 就可以退出 help 模式了。</p><p><img src="http://image.iswbm.com/image-20200606123145109.png"></p><p>如果你觉得进入 help 模式太麻烦，可以在 console 模式下直接查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(<span class="hljs-string">&quot;json&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><p>dir() 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则 dir() 返回当前作用域中的名称。让我们将 dir() 函数应用于 keyword 模块，并观察它揭示了什么：</p><p><img src="http://image.iswbm.com/image-20200606134519352.png"></p><h3 id="2-应用到实际开发中"><a href="#2-应用到实际开发中" class="headerlink" title="2. 应用到实际开发中"></a>2. 应用到实际开发中</h3><h4 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h4><p>type() 函数有助于我们确定对象是字符串还是整数，或是其它类型的对象。它通过返回类型对象来做到这一点，可以将这个类型对象与 types 模块中定义的类型相比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">42</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>([])<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h4><p>使用 dir() 函数会返回一个对象的属性列表。</p><p>但是，有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由 hasattr() 来完成.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(json, <span class="hljs-string">&quot;dumps&quot;</span>)<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h4><p>使用 hasattr 获知了对象拥有某个属性后，可以搭配 getattr() 函数来获取其属性值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(json, <span class="hljs-string">&quot;__path__&quot;</span>)<br>[<span class="hljs-string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/json&#x27;</span>]<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>使用 getattr 获取函数后，可以很方便地使用这个函数，比如下面这样，可以不再使写 json.dumps 这么字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dumps = <span class="hljs-built_in">getattr</span>(json, <span class="hljs-string">&quot;dumps&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dumps(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;MING&quot;</span>&#125;)<br><span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;MING&quot;&#125;&#x27;</span><br>&gt;&gt;&gt;<br><br><span class="hljs-comment">## 当然你还有更简单的方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>mydumps = json.dumps<br><span class="hljs-meta">&gt;&gt;&gt; </span>mydumps(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;MING&quot;</span>&#125;)<br><span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;MING&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h4><p><strong>id()</strong> 函数返回对象的唯一标识符，标识符是一个整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&quot;world&quot;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(a)<br><span class="hljs-number">4470767944</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(b)<br><span class="hljs-number">4499487408</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h4><p>使用 isinstance() 函数可以确定一个对象是否是某个特定类型或定制类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">10</span>, <span class="hljs-built_in">int</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-literal">False</span>, <span class="hljs-built_in">bool</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="callable"><a href="#callable" class="headerlink" title="callable()"></a>callable()</h4><p>使用 callable 可以确定一个对象是否是可调用的，比如函数，类这些对象都是可以调用的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">callable</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-literal">False</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">callable</span>(<span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h3 id="3-模块（Modules）"><a href="#3-模块（Modules）" class="headerlink" title="3. 模块（Modules）"></a>3. 模块（Modules）</h3><h4 id="doc"><a href="#doc" class="headerlink" title="_doc_"></a>_<em>doc</em>_</h4><p>使用 <code>__doc__</code> 这个魔法方法，可以查询该模块的文档，它输出的内容和 help() 一样。</p><p><img src="http://image.iswbm.com/image-20200606134858285.png"></p><h4 id="name"><a href="#name" class="headerlink" title="_name_"></a>_<em>name</em>_</h4><p>始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<br><span class="hljs-meta">&gt;&gt;&gt; </span>json.__name__<br><span class="hljs-string">&#x27;json&#x27;</span><br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json <span class="hljs-keyword">as</span> js<br><span class="hljs-meta">&gt;&gt;&gt; </span>js.__name__<br><span class="hljs-string">&#x27;json&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="file"><a href="#file" class="headerlink" title="_file_"></a>_<em>file</em>_</h4><p>包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<br><span class="hljs-meta">&gt;&gt;&gt; </span>json.__file__<br><span class="hljs-string">&#x27;/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/json/__init__.py&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="dict"><a href="#dict" class="headerlink" title="_dict_"></a>_<em>dict</em>_</h4><p>包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。</p><h3 id="4-类（Class）"><a href="#4-类（Class）" class="headerlink" title="4. 类（Class）"></a>4. 类（Class）</h3><h4 id="doc-1"><a href="#doc-1" class="headerlink" title="_doc_"></a>_<em>doc</em>_</h4><p>文档字符串。如果类没有文档，这个值是None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"><span class="hljs-meta">... </span>    people class</span><br><span class="hljs-string"><span class="hljs-meta">... </span>    &#x27;&#x27;&#x27;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>p = People()<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(p.__doc__)<br><br>    people <span class="hljs-keyword">class</span><br><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h4 id="name-1"><a href="#name-1" class="headerlink" title="_name_"></a>_<em>name</em>_</h4><p>始终是定义时的类名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>People.__name__<br><span class="hljs-string">&#x27;People&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="dict-1"><a href="#dict-1" class="headerlink" title="_dict_"></a>_<em>dict</em>_</h4><p>包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>People.__dict__<br>mappingproxy(&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-string">&#x27;\n    people class\n    &#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;People&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;People&#x27;</span> objects&gt;&#125;)<br></code></pre></td></tr></table></figure><h4 id="module"><a href="#module" class="headerlink" title="_module_"></a>_<em>module</em>_</h4><p>包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。</p><p>由于我是在 交互式命令行的环境下，所以模块是 <code>__main__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>People.__module__<br><span class="hljs-string">&#x27;__main__&#x27;</span><br></code></pre></td></tr></table></figure><p>如果将上面的代码放入 demo.py，并且从 people 模块导入 People 类，其值就是 people 模块</p><p><img src="http://image.iswbm.com/image-20200905115039771.png"></p><h4 id="bases"><a href="#bases" class="headerlink" title="_bases_"></a>_<em>bases</em>_</h4><p>直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teenager</span>: <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Teenager</span>): <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>Student.__bases__<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Teenager&#x27;</span>&gt;,)<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="5-6-【基础】偏函数的妙用"><a href="#5-6-【基础】偏函数的妙用" class="headerlink" title="5.6 【基础】偏函数的妙用"></a>5.6 【基础】偏函数的妙用</h2><p>假如一个函数定义了多个位置参数，那你每次调用时，都需要把这些个参数一个一个地传递进去。</p><p>比如下面这个函数，是用来计算 <code>x的n次方</code> 的。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n</span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p>那我每次计算 x 的 n 次方，都要传递两个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>power(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>power(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>后来我发现，我很多时候都是计算平方值，很多会去计算三次方，四次方。</p><p>那有什么办法可以偷个懒吗？</p><p>答案是，有。可以使用 <code>偏函数</code>。</p><p>偏函数（Partial Function），可以将某个函数的常用参数进行固定，避免每次调用时都要指定。</p><p>使用偏函数，需要导入 <code>functools.partial</code> ，然后利用它创建一个新函数，新函数的 n 固定等2。</p><p>具体使用请看下面的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-meta">&gt;&gt;&gt; </span>power_2=partial(power, n=<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>power_2(<span class="hljs-number">2</span>)<br><span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>power_2(<span class="hljs-number">3</span>)<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="5-7-【进阶】泛型函数的使用"><a href="#5-7-【进阶】泛型函数的使用" class="headerlink" title="5.7 【进阶】泛型函数的使用"></a>5.7 【进阶】泛型函数的使用</h2><p>根据传入参数类型的不同而调用不同的函数逻辑体，这种实现我们称之为泛型。在 Python 中叫做 <code>singledispatch</code>。</p><p><code>singledispatch</code> 是 PEP443 中引入的，如果你对此有兴趣，PEP443 应该是最好的学习文档：<a href="https://www.python.org/dev/peps/pep-0443/">https://www.python.org/dev/peps/pep-0443/</a></p><p>它使用方法极其简单，只要被<code>singledispatch</code> 装饰的函数，就是一个<code>single-dispatch</code> 的泛函数（<code>generic functions</code>）。</p><ul><li><strong>单分派</strong>：根据一个参数的类型，以不同方式执行相同的操作的行为。</li><li><strong>多分派</strong>：可根据多个参数的类型选择专门的函数的行为。</li><li><strong>泛函数</strong>：多个函数绑在一起组合成一个泛函数。</li></ul><p>这边举个简单的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> singledispatch<br><br><span class="hljs-meta">@singledispatch</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请传入合法类型的参数！&#x27;</span>)<br><br><span class="hljs-meta">@age.register(<span class="hljs-params"><span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">age</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我已经&#123;&#125;岁了。&#x27;</span>.<span class="hljs-built_in">format</span>(age))<br><br><span class="hljs-meta">@age.register(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">age</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am &#123;&#125; years old.&#x27;</span>.<span class="hljs-built_in">format</span>(age))<br><br><br>age(<span class="hljs-number">23</span>)  <span class="hljs-comment"># int</span><br>age(<span class="hljs-string">&#x27;twenty three&#x27;</span>)  <span class="hljs-comment"># str</span><br>age([<span class="hljs-string">&#x27;23&#x27;</span>])  <span class="hljs-comment"># list</span><br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">我已经<span class="hljs-number">23</span>岁了。<br><span class="hljs-selector-tag">I</span> am twenty three years old.<br>请传入合法类型的参数！<br></code></pre></td></tr></table></figure><p>说起泛型，其实在 Python 本身的一些内建函数中并不少见，比如 <code>len()</code> ， <code>iter()</code>，<code>copy.copy()</code> ，<code>pprint()</code> 等</p><p>你可能会问，它有什么用呢？实际上真没什么用，你不用它或者不认识它也完全不影响你编码。</p><p>我这里举个例子，你可以感受一下。</p><p>大家都知道，Python 中有许许多的数据类型，比如 str，list， dict， tuple 等，不同数据类型的拼接方式各不相同，所以我这里我写了一个通用的函数，可以根据对应的数据类型对选择对应的拼接方式拼接，而且不同数据类型我还应该提示无法拼接。以下是简单的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_type</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args</span>):<br>        arg1, arg2 = args[:<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(arg1) != <span class="hljs-built_in">type</span>(arg2):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;【错误】：参数类型不同，无法拼接!!&#x27;</span><br>        <span class="hljs-keyword">return</span> func(*args)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@singledispatch</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">obj, new_obj</span>):<br>    <span class="hljs-keyword">raise</span> TypeError<br><br><span class="hljs-meta">@add.register(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)</span><br><span class="hljs-meta">@check_type</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">obj, new_obj</span>):<br>    obj += new_obj<br>    <span class="hljs-keyword">return</span> obj<br><br><br><span class="hljs-meta">@add.register(<span class="hljs-params"><span class="hljs-built_in">list</span></span>)</span><br><span class="hljs-meta">@check_type</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">obj, new_obj</span>):<br>    obj.extend(new_obj)<br>    <span class="hljs-keyword">return</span> obj<br><br><span class="hljs-meta">@add.register(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>)</span><br><span class="hljs-meta">@check_type</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">obj, new_obj</span>):<br>    obj.update(new_obj)<br>    <span class="hljs-keyword">return</span> obj<br><br><span class="hljs-meta">@add.register(<span class="hljs-params"><span class="hljs-built_in">tuple</span></span>)</span><br><span class="hljs-meta">@check_type</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">obj, new_obj</span>):<br>    <span class="hljs-keyword">return</span> (*obj, *new_obj)<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;, world&#x27;</span>))<br><span class="hljs-built_in">print</span>(add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<br><span class="hljs-built_in">print</span>(add(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;wangbm&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">25</span>&#125;))<br><span class="hljs-built_in">print</span>(add((<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;huawei&#x27;</span>), (<span class="hljs-string">&#x27;vivo&#x27;</span>, <span class="hljs-string">&#x27;oppo&#x27;</span>)))<br><br><span class="hljs-comment">## list 和 字符串 无法拼接</span><br><span class="hljs-built_in">print</span>(add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-string">&#x27;4,5,6&#x27;</span>))<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">hello, world<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;wangbm&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;huawei&#x27;</span>, <span class="hljs-string">&#x27;vivo&#x27;</span>, <span class="hljs-string">&#x27;oppo&#x27;</span>)<br>【错误】：参数类型不同，无法拼接!!<br></code></pre></td></tr></table></figure><p>如果不使用singledispatch 的话，你可能会写出这样的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_type</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args</span>):<br>        arg1, arg2 = args[:<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(arg1) != <span class="hljs-built_in">type</span>(arg2):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;【错误】：参数类型不同，无法拼接!!&#x27;</span><br>        <span class="hljs-keyword">return</span> func(*args)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@check_type</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">obj, new_obj</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, <span class="hljs-built_in">str</span>) :<br>        obj += new_obj<br>        <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, <span class="hljs-built_in">list</span>) :<br>        obj.extend(new_obj)<br>        <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, <span class="hljs-built_in">dict</span>) :<br>        obj.update(new_obj)<br>        <span class="hljs-keyword">return</span> obj<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, <span class="hljs-built_in">tuple</span>) :<br>        <span class="hljs-keyword">return</span> (*obj, *new_obj)<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-string">&#x27;, world&#x27;</span>))<br><span class="hljs-built_in">print</span>(add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]))<br><span class="hljs-built_in">print</span>(add(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;wangbm&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">25</span>&#125;))<br><span class="hljs-built_in">print</span>(add((<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;huawei&#x27;</span>), (<span class="hljs-string">&#x27;vivo&#x27;</span>, <span class="hljs-string">&#x27;oppo&#x27;</span>)))<br><br><span class="hljs-comment">## list 和 字符串 无法拼接</span><br><span class="hljs-built_in">print</span>(add([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-string">&#x27;4,5,6&#x27;</span>))<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">hello, world<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;wangbm&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;<br>(<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;huawei&#x27;</span>, <span class="hljs-string">&#x27;vivo&#x27;</span>, <span class="hljs-string">&#x27;oppo&#x27;</span>)<br>【错误】：参数类型不同，无法拼接!!<br></code></pre></td></tr></table></figure><h2 id="5-8-【基础】变量的作用域"><a href="#5-8-【基础】变量的作用域" class="headerlink" title="5.8 【基础】变量的作用域"></a>5.8 【基础】变量的作用域</h2><h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><p>Python的作用域可以分为四种：</p><ul><li>L （Local）      局部作用域</li><li>E （Enclosing）  闭包函数外的函数中</li><li>G （Global）     全局作用域</li><li>B （Built-in）   内建作用域</li></ul><p>变量&#x2F;函数 的查找顺序：<br>L –&gt; E –&gt; G –&gt;B</p><p>意思是，在局部找不到的，便去局部外的局部作用域找（例如 闭包），再找不到的就去全局作业域里找，再找不到就去内建作业域中找。</p><p>会影响 变量&#x2F;函数 作用范围的有</p><ul><li>函数：def 或 lambda</li><li>类：class</li><li>关键字：global noglobal</li><li>文件：*py</li><li>推导式：[],{},()等，仅限Py3.x中，Py2.x会出现变量泄露。</li></ul><p>1、赋值在前，引用在后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## ------同作用域内------</span><br>name = <span class="hljs-string">&quot;MING&quot;</span><br><span class="hljs-built_in">print</span>(name)<br><br><span class="hljs-comment">## ------不同作用域内------</span><br>name = <span class="hljs-string">&quot;MING&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure><p>2、引用在前，赋值在后（同一作用域内）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(name)<br>name = <span class="hljs-string">&quot;MING&quot;</span><br><br><span class="hljs-comment">## UnboundLocalError: local variable &#x27;name&#x27; referenced before assignment</span><br></code></pre></td></tr></table></figure><p>3、赋值在低层，引用在高层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## L -&gt; E -&gt; G -&gt; B</span><br><span class="hljs-comment">## 从左到右，由低层到高层</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    name = <span class="hljs-string">&quot;MING&quot;</span><br><br><span class="hljs-built_in">print</span>(name)<br><span class="hljs-comment">## NameError: name &#x27;name&#x27; is not defined</span><br></code></pre></td></tr></table></figure><h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h3><p>闭包这个概念很重要噢。你一定要掌握。</p><blockquote><p>在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。其实装饰函数，很多都是闭包。</p></blockquote><p>好像并不难理解，为什么初学者会觉得闭包难以理解呢？</p><p>我解释一下，你就明白了。</p><p>一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</p><p>你可以看下面这段代码，就构成了闭包。在内函数里可以引用外函数的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>():<br>    name = <span class="hljs-string">&quot;MING&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(name)<br>    <span class="hljs-keyword">return</span> wrapper<br><br>deco()()<br><span class="hljs-comment">## 输出：MING</span><br></code></pre></td></tr></table></figure><h3 id="3-改变作用域"><a href="#3-改变作用域" class="headerlink" title="3. 改变作用域"></a>3. 改变作用域</h3><p>变量的作用域，与其定义（或赋值）的位置有关，但不是绝对相关。<br>因为我们可以在某种程度上去改变<code>向上</code>的作用范围。</p><ul><li><p>关键字：global<br>将 局部变量 变为全局变量</p></li><li><p>关键字：nonlocal<br>可以在闭包函数中，引用并使用闭包外部函数的变量（非全局的噢）</p></li></ul><p>global好理解，这里只讲下nonlocal。</p><p>先来看个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>():<br>    age = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        age += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> wrapper<br><br>deco()()<br></code></pre></td></tr></table></figure><p>运行一下，会报错。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">## UnboundLocalError: local variable <span class="hljs-string">&#x27;age&#x27;</span> referenced before assignment<br></code></pre></td></tr></table></figure><p>但是这样就OK</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>():<br>    age = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-keyword">nonlocal</span> age<br>        age += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> wrapper<br><br>deco()()<br><span class="hljs-comment">## 输出：11</span><br></code></pre></td></tr></table></figure><p>其实，你如果不使用 <code>+=</code>、<code>-=</code>等一类的操作，不加nonlocal也没有关系。这就展示了闭包的特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>():<br>    age = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(age)<br>    <span class="hljs-keyword">return</span> wrapper<br><br>deco()()<br><span class="hljs-comment">## 输出：10</span><br></code></pre></td></tr></table></figure><h3 id="4-变量集合"><a href="#4-变量集合" class="headerlink" title="4. 变量集合"></a>4. 变量集合</h3><p>在Python中，有两个内建函数，你可能用不到，但是需要掌握它们。</p><ul><li>globals() ：以dict的方式存储所有全局变量</li><li>locals()：以dict的方式存储所有局部变量</li></ul><p>globals()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a func&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>    foo=<span class="hljs-string">&quot;I am a string&quot;</span><br>    foo_dup = <span class="hljs-built_in">globals</span>().get(<span class="hljs-string">&quot;foo&quot;</span>)<br>    foo_dup()<br><br>bar()<br><span class="hljs-comment">## 输出</span><br><span class="hljs-comment">## I am a func</span><br></code></pre></td></tr></table></figure><p>locals()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">other = <span class="hljs-string">&quot;test&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foobar</span>():<br>    name = <span class="hljs-string">&quot;MING&quot;</span><br>    gender = <span class="hljs-string">&quot;male&quot;</span><br>    <span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">locals</span>().items():<br>        <span class="hljs-built_in">print</span>(key, <span class="hljs-string">&quot;=&quot;</span>, value)<br><br>foobar()<br><span class="hljs-comment">## 输出</span><br><span class="hljs-comment">## name = MING</span><br><span class="hljs-comment">## gender = male</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-9-【进阶】上下文管理器"><a href="#5-9-【进阶】上下文管理器" class="headerlink" title="5.9 【进阶】上下文管理器"></a>5.9 【进阶】上下文管理器</h2><p>当你准备从一个文件中读取内容时，通常来说，都是这么写的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(file.readlines())  <span class="hljs-comment"># 读取并打印</span><br>[<span class="hljs-string">&#x27;hello,python\n&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>file.close()  <span class="hljs-comment"># 关闭文件句柄</span><br></code></pre></td></tr></table></figure><p>上面这种方法，需要你手动关闭文件句柄，但是很多时候，程序员是会忘记这一操作的。</p><p>因为推荐你使用下面这种方法，使用 <code>with</code> 这个关键字，可以在文件读取结束后，自动关闭文件句柄。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-built_in">print</span>(file.readlines())<br></code></pre></td></tr></table></figure><p>使用 Python 的专业术语来说，<code>with</code> 的这个用法叫做 <code>上下文管理器</code>。</p><h3 id="1-什么是上下文管理器？"><a href="#1-什么是上下文管理器？" class="headerlink" title="1. 什么是上下文管理器？"></a>1. 什么是上下文管理器？</h3><p><strong>基本语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> EXPR <span class="hljs-keyword">as</span> VAR:<br>    代码块<br></code></pre></td></tr></table></figure><p>从上面这个语法中，先理清几个概念：</p><ol><li>上下文表达式：<code>with open(&#39;test.txt&#39;) as file:</code></li><li>上下文管理器：<code>open(&#39;test.txt&#39;)</code></li><li><code>file</code> 不是上下文管理器，应该是资源对象。</li></ol><h3 id="2-如何写上下文管理器？"><a href="#2-如何写上下文管理器？" class="headerlink" title="2. 如何写上下文管理器？"></a>2. 如何写上下文管理器？</h3><p>要手动实现一个上下文管理器，需要你有对类有一些了解，至少需要知道什么是类，怎么定义类。对于类的知识，我放在了第七章，因此你可以先前往学习下第七章的的第一节内容：<a href="https://python.iswbm.com/c07/c07_01.html">7.1 类的理解与使用</a> 。</p><p>学习了类的基本知识，想要自己实现这样一个上下文管理，就简单了。</p><p>你只要在一个类里实现上下文管理协议，简单点说，就是在一个类里，定义了<code>__enter__</code>和<code>__exit__</code>的方法，这个类的实例就是一个上下文管理器。</p><p>例如这个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===connect to resource===&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===close resource connection===&#x27;</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===in operation===&#x27;</span>)<br>        <br><span class="hljs-keyword">with</span> Resource() <span class="hljs-keyword">as</span> res:<br>    res.operate()<br></code></pre></td></tr></table></figure><p>我们执行一下，通过日志的打印顺序。可以知道其执行过程。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>connect to resource<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>in operation<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>close resource connection<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>从这个示例可以很明显的看出，在编写代码时，可以将资源的连接或者获取放在<code>__enter__</code>中，而将资源的关闭写在<code>__exit__</code> 中。</p><h3 id="3-为什么需要上下文管理器？"><a href="#3-为什么需要上下文管理器？" class="headerlink" title="3. 为什么需要上下文管理器？"></a>3. 为什么需要上下文管理器？</h3><p>学习时多问自己几个为什么，养成对一些细节的思考，有助于加深对知识点的理解。</p><p>为什么要使用上下文管理器？</p><p>在我看来，这和 Python 崇尚的优雅风格有关。</p><ol><li>可以以一种更加优雅的方式，操作（创建&#x2F;获取&#x2F;释放）资源，如文件操作、数据库连接；</li><li>可以以一种更加优雅的方式，处理异常；</li></ol><p>第一种，我们上面已经以资源的连接为例讲过了。</p><p>而第二种，会被大多数人所忽略。这里会重点讲一下。</p><p>大家都知道，处理异常，通常都是使用 <code>try...execept..</code> 来捕获处理的。这样做一个不好的地方是，在代码的主逻辑里，会有大量的异常处理代理，这会很大的影响我们的可读性。</p><p>好一点的做法呢，可以使用 <code>with</code> 将异常的处理隐藏起来。</p><p>仍然是以上面的代码为例，我们将<code>1/0</code> 这个<code>一定会抛出异常的代码</code>写在 <code>operate</code> 里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===connect to resource===&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===close resource connection===&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><br><span class="hljs-keyword">with</span> Resource() <span class="hljs-keyword">as</span> res:<br>    res.operate()<br></code></pre></td></tr></table></figure><p>运行一下，惊奇地发现，居然不会报错。</p><p>这就是上下文管理协议的一个强大之处，异常可以在<code>__exit__</code> 进行捕获并由你自己决定如何处理，是抛出呢还是在这里就解决了。在<code>__exit__</code> 里返回 <code>True</code>（没有return 就默认为 return False），就相当于告诉 Python解释器，这个异常我们已经捕获了，不需要再往外抛了。</p><p>在 写<code>__exit__</code> 函数时，需要注意的事，它必须要有这三个参数：</p><ul><li>exc_type：异常类型</li><li>exc_val：异常值</li><li>exc_tb：异常的错误栈信息</li></ul><p>当主逻辑代码没有报异常时，这三个参数将都为None。</p><h3 id="4-学会使用-contextlib"><a href="#4-学会使用-contextlib" class="headerlink" title="4. 学会使用 contextlib"></a>4. 学会使用 contextlib</h3><p>在上面的例子中，我们只是为了构建一个上下文管理器，却写了一个类。如果只是要实现一个简单的功能，写一个类未免有点过于繁杂。这时候，我们就想，如果只写一个函数就可以实现上下文管理器就好了。</p><p>这个点Python早就想到了。它给我们提供了一个装饰器，你只要按照它的代码协议来实现函数内容，就可以将这个函数对象变成一个上下文管理器。</p><p>我们按照 contextlib 的协议来自己实现一个打开文件（with open）的上下文管理器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><span class="hljs-meta">@contextlib.contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_func</span>(<span class="hljs-params">file_name</span>):<br>    <span class="hljs-comment"># __enter__方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;open file:&#x27;</span>, file_name, <span class="hljs-string">&#x27;in __enter__&#x27;</span>)<br>    file_handler = <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;r&#x27;</span>)<br><br>    <span class="hljs-comment"># 【重点】：yield</span><br>    <span class="hljs-keyword">yield</span> file_handler<br><br>    <span class="hljs-comment"># __exit__方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;close file:&#x27;</span>, file_name, <span class="hljs-string">&#x27;in __exit__&#x27;</span>)<br>    file_handler.close()<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">with</span> open_func(<span class="hljs-string">&#x27;/Users/MING/mytest.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_in:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_in:<br>        <span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure><p>在被装饰函数里，必须是一个生成器（带有yield），而yield之前的代码，就相当于<code>__enter__</code>里的内容。yield 之后的代码，就相当于<code>__exit__</code> 里的内容。</p><p>上面这段代码只能实现上下文管理器的第一个目的（管理资源），并不能实现第二个目的（处理异常）。</p><p>如果要处理异常，可以改成下面这个样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><span class="hljs-meta">@contextlib.contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_func</span>(<span class="hljs-params">file_name</span>):<br>    <span class="hljs-comment"># __enter__方法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;open file:&#x27;</span>, file_name, <span class="hljs-string">&#x27;in __enter__&#x27;</span>)<br>    file_handler = <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;r&#x27;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> file_handler<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-comment"># deal with exception</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the exception was thrown&#x27;</span>)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;close file:&#x27;</span>, file_name, <span class="hljs-string">&#x27;in __exit__&#x27;</span>)<br>        file_handler.close()<br><br>        <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">with</span> open_func(<span class="hljs-string">&#x27;/Users/MING/mytest.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_in:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_in:<br>        <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br>        <span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure><p>好像只要讲到上下文管理器，大多数人都会谈到打开文件这个经典的例子。</p><p>但是在实际开发中，可以使用到上下文管理器的例子也不少。我这边举个我自己的例子。</p><p>在OpenStack中，给一个虚拟机创建快照时，需要先创建一个临时文件夹，来存放这个本地快照镜像，等到本地快照镜像创建完成后，再将这个镜像上传到Glance。然后删除这个临时目录。</p><p>这段代码的主逻辑是<code>创建快照</code>，而<code>创建临时目录 </code>，属于前置条件，<code>删除临时目录</code>，是收尾工作。</p><p>虽然代码量很少，逻辑也不复杂，但是“<code>创建临时目录，使用完后再删除临时目录</code>”这个功能，在一个项目中很多地方都需要用到，如果可以将这段逻辑处理写成一个工具函数作为一个上下文管理器，那代码的复用率也大大提高。</p><p>代码是这样的</p><p><img src="http://image.iswbm.com/20190310172800.png"></p><h3 id="5-总结起来"><a href="#5-总结起来" class="headerlink" title="5. 总结起来"></a>5. 总结起来</h3><p>使用上下文管理器有三个好处：</p><ol><li>提高代码的复用率；</li><li>提高代码的优雅度；</li><li>提高代码的可读性；<br><img src="http://image.iswbm.com/20210606214719.png"></li></ol><h2 id="5-10-【进阶】装饰器的六种写法"><a href="#5-10-【进阶】装饰器的六种写法" class="headerlink" title="5.10 【进阶】装饰器的六种写法"></a>5.10 【进阶】装饰器的六种写法</h2><h3 id="Hello，装饰器"><a href="#Hello，装饰器" class="headerlink" title="Hello，装饰器"></a>Hello，装饰器</h3><p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。</p><p>它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。</p><p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p><p>装饰器的使用方法很固定</p><ul><li>先定义一个装饰器（帽子）</li><li>再定义你的业务函数或者类（人）</li><li>最后把这装饰器（帽子）扣在这个函数（人）头上</li></ul><p>就像下面这样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 定义装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-keyword">return</span> func()<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-comment">## 定义业务函数并进行装饰</span><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">function</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello, decorator&quot;</span>)<br></code></pre></td></tr></table></figure><p>实际上，装饰器并不是编码必须性，意思就是说，你不使用装饰器完全可以，它的出现，应该是使我们的代码</p><ul><li>更加优雅，代码结构更加清晰</li><li>将实现特定的功能代码封装成装饰器，提高代码复用率，增强代码可读性</li></ul><p>接下来，我将以实例讲解，如何编写出各种简单及复杂的装饰器。</p><h3 id="第一种：普通装饰器"><a href="#第一种：普通装饰器" class="headerlink" title="第一种：普通装饰器"></a>第一种：普通装饰器</h3><p>首先咱来写一个最普通的装饰器，它实现的功能是：</p><ul><li>在函数执行前，先记录一行日志</li><li>在函数执行完，再记录一行日志</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 这是装饰器函数，参数 func 是被装饰的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我准备开始执行：&#123;&#125; 函数了:&#x27;</span>.<span class="hljs-built_in">format</span>(func.__name__))<br><br>        <span class="hljs-comment"># 真正执行的是这行。</span><br>        func(*args, **kw)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主人，我执行完啦。&#x27;</span>)<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>假如，我的业务函数是，计算两个数之和。写好后，直接给它带上帽子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@logger</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;&#125; + &#123;&#125; = &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x, y, x+y))<br></code></pre></td></tr></table></figure><p>然后执行一下 add 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">200</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p>来看看输出了什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">我准备开始执行：add 函数了:<br><span class="hljs-number">200</span> + <span class="hljs-number">50</span> = <span class="hljs-number">250</span><br>我执行完啦。<br></code></pre></td></tr></table></figure><h3 id="第二种：带参数的函数装饰器"><a href="#第二种：带参数的函数装饰器" class="headerlink" title="第二种：带参数的函数装饰器"></a>第二种：带参数的函数装饰器</h3><p>通过上面两个简单的入门示例，你应该能体会到装饰器的工作原理了。</p><p>不过，装饰器的用法还远不止如此，深究下去，还大有文章。今天就一起来把这个知识点学透。</p><p>回过头去看看上面的例子，装饰器是不能接收参数的。其用法，只能适用于一些简单的场景。不传参的装饰器，只能对被装饰函数，执行固定逻辑。</p><p>装饰器本身是一个函数，做为一个函数，如果不能传参，那这个函数的功能就会很受限，只能执行固定的逻辑。这意味着，如果装饰器的逻辑代码的执行需要根据不同场景进行调整，若不能传参的话，我们就要写两个装饰器，这显然是不合理的。</p><p>比如我们要实现一个可以定时发送邮件的任务（一分钟发送一封），定时进行时间同步的任务（一天同步一次），就可以自己实现一个 periodic_task （定时任务）的装饰器，这个装饰器可以接收一个时间间隔的参数，间隔多长时间执行一次任务。</p><p>可以这样像下面这样写，由于这个功能代码比较复杂，不利于学习，这里就不贴了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@periodic_task(<span class="hljs-params">spacing=<span class="hljs-number">60</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_mail</span>():<br>     <span class="hljs-keyword">pass</span><br>  <br><span class="hljs-meta">@periodic_task(<span class="hljs-params">spacing=<span class="hljs-number">86400</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ntp</span>()<br>    <span class="hljs-keyword">pass</span> <br></code></pre></td></tr></table></figure><p>那我们来自己创造一个伪场景，可以在装饰器里传入一个参数，指明国籍，并在函数执行前，用自己国家的母语打一个招呼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 小明，中国人</span><br><span class="hljs-meta">@say_hello(<span class="hljs-params"><span class="hljs-string">&quot;china&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xiaoming</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment">## jack，美国人</span><br><span class="hljs-meta">@say_hello(<span class="hljs-params"><span class="hljs-string">&quot;america&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">jack</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>那我们如果实现这个装饰器，让其可以实现 <code>传参</code> 呢？</p><p>会比较复杂，需要两层嵌套。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">contry</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">if</span> contry == <span class="hljs-string">&quot;china&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好!&quot;</span>)<br>            <span class="hljs-keyword">elif</span> contry == <span class="hljs-string">&quot;america&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello.&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-comment"># 真正执行函数的地方</span><br>            func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> deco<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>来执行一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">xiaoming()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------------&quot;</span>)<br>jack()<br></code></pre></td></tr></table></figure><p>看看输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">你好!<br>------------<br>hello.<br></code></pre></td></tr></table></figure><h3 id="第三种：不带参数的类装饰器"><a href="#第三种：不带参数的类装饰器" class="headerlink" title="第三种：不带参数的类装饰器"></a>第三种：不带参数的类装饰器</h3><p>以上都是基于函数实现的装饰器，在阅读别人代码时，还可以时常发现还有基于类实现的装饰器。</p><p>基于类装饰器的实现，必须实现 <code>__call__</code> 和 <code>__init__</code>两个内置函数。<br><code>__init__</code> ：接收被装饰函数<br><code>__call__</code> ：实现装饰逻辑。</p><p>还是以日志打印这个简单的例子为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">logger</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[INFO]: the function &#123;func&#125;() is running...&quot;</span>\<br>            .<span class="hljs-built_in">format</span>(func=self.func.__name__))<br>        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)<br><br><span class="hljs-meta">@logger</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;say &#123;&#125;!&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br>say(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行一下，看看输出</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">[INFO]: the <span class="hljs-keyword">function</span> <span class="hljs-title">say</span>() <span class="hljs-keyword">is</span> running...<br>say hello!<br></code></pre></td></tr></table></figure><h3 id="第四种：带参数的类装饰器"><a href="#第四种：带参数的类装饰器" class="headerlink" title="第四种：带参数的类装饰器"></a>第四种：带参数的类装饰器</h3><p>上面不带参数的例子，你发现没有，只能打印<code>INFO</code>级别的日志，正常情况下，我们还需要打印<code>DEBUG</code> <code>WARNING</code>等级别的日志。 这就需要给类装饰器传入参数，给这个函数指定级别了。</p><p>带参数和不带参数的类装饰器有很大的不同。</p><p><code>__init__</code> ：不再接收被装饰函数，而是接收传入参数。<br><code>__call__</code> ：接收被装饰函数，实现装饰逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">logger</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, level=<span class="hljs-string">&#x27;INFO&#x27;</span></span>):<br>        self.level = level<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>): <span class="hljs-comment"># 接受函数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;level&#125;]: the function &#123;func&#125;() is running...&quot;</span>\<br>                .<span class="hljs-built_in">format</span>(level=self.level, func=func.__name__))<br>            func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper  <span class="hljs-comment">#返回函数</span><br><br><span class="hljs-meta">@logger(<span class="hljs-params">level=<span class="hljs-string">&#x27;WARNING&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">something</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;say &#123;&#125;!&quot;</span>.<span class="hljs-built_in">format</span>(something))<br><br>say(<span class="hljs-string">&quot;hello&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们指定<code>WARNING</code>级别，运行一下，来看看输出。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">[WARNING]: the <span class="hljs-keyword">function</span> <span class="hljs-title">say</span>() <span class="hljs-keyword">is</span> running...<br>say hello!<br></code></pre></td></tr></table></figure><h3 id="第五种：使用偏函数与类实现装饰器"><a href="#第五种：使用偏函数与类实现装饰器" class="headerlink" title="第五种：使用偏函数与类实现装饰器"></a>第五种：使用偏函数与类实现装饰器</h3><p>绝大多数装饰器都是基于函数和闭包实现的，但这并非制造装饰器的唯一方式。</p><p>事实上，Python 对某个对象是否能通过装饰器（ <code>@decorator</code>）形式使用只有一个要求：<strong>decorator 必须是一个“可被调用（callable）的对象</strong>。</p><p>对于这个 callable 对象，我们最熟悉的就是函数了。</p><p>除函数之外，类也可以是 callable 对象，只要实现了<code>__call__</code> 函数（上面几个例子已经接触过了）。</p><p>还有容易被人忽略的偏函数其实也是 callable 对象。</p><p>接下来就来说说，如何使用 类和偏函数结合实现一个与众不同的装饰器。</p><p>如下所示，DelayFunc 是一个实现了 <code>__call__</code> 的类，delay 返回一个偏函数，在这里 delay 就可以做为一个装饰器。（以下代码摘自 Python工匠：使用装饰器的小技巧）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayFunc</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,  duration, func</span>):<br>        self.duration = duration<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Wait for <span class="hljs-subst">&#123;self.duration&#125;</span> seconds...&#x27;</span>)<br>        time.sleep(self.duration)<br>        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eager_call</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Call without delay&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">duration</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    装饰器：推迟某个函数的执行。</span><br><span class="hljs-string">    同时提供 .eager_call 方法立即执行</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 此处为了避免定义额外函数，</span><br><span class="hljs-comment"># 直接使用 functools.partial 帮助构造 DelayFunc 实例</span><br>    <span class="hljs-keyword">return</span> functools.partial(DelayFunc, duration)<br></code></pre></td></tr></table></figure><p>我们的业务函数很简单，就是相加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@delay(<span class="hljs-params">duration=<span class="hljs-number">2</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a+b<br></code></pre></td></tr></table></figure><p>来看一下执行过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>add    <span class="hljs-comment"># 可见 add 变成了 Delay 的实例</span><br>&lt;__main__.DelayFunc <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107bd0be0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)  <span class="hljs-comment"># 直接调用实例，进入 __call__</span><br>Wait <span class="hljs-keyword">for</span> <span class="hljs-number">2</span> seconds...<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>add.func <span class="hljs-comment"># 实现实例方法</span><br>&lt;function add at <span class="hljs-number">0x107bef1e0</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="第六种：能装饰类的装饰器"><a href="#第六种：能装饰类的装饰器" class="headerlink" title="第六种：能装饰类的装饰器"></a>第六种：能装饰类的装饰器</h3><p>用 Python 写单例模式的时候，常用的有三种写法。其中一种，是用装饰器来实现的。</p><p>以下便是我自己写的装饰器版的单例写法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">instances = &#123;&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleton</span>(<span class="hljs-params">cls</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_instance</span>(<span class="hljs-params">*args, **kw</span>):<br>cls_name = cls.__name__<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===== 1 ====&#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls_name <span class="hljs-keyword">in</span> instances:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===== 2 ====&#x27;</span>)<br>instance = cls(*args, **kw)<br>instances[cls_name] = instance<br><span class="hljs-keyword">return</span> instances[cls_name]<br><span class="hljs-keyword">return</span> get_instance<br><br><span class="hljs-meta">@singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>_instance = <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;===== 3 ====&#x27;</span>)<br>self.name = name<br></code></pre></td></tr></table></figure><p>可以看到我们用singleton 这个装饰函数来装饰 User 这个类。装饰器用在类上，并不是很常见，但只要熟悉装饰器的实现过程，就不难以实现对类的装饰。在上面这个例子中，装饰器就只是实现对类实例的生成的控制而已。</p><p>其实例化的过程，你可以参考我这里的调试过程，加以理解。</p><p><img src="http://image.iswbm.com/20190512113917.png"></p><h1 id="第六章：错误异常"><a href="#第六章：错误异常" class="headerlink" title="第六章：错误异常"></a>第六章：错误异常</h1><h2 id="6-1-【基础】什么是异常？"><a href="#6-1-【基础】什么是异常？" class="headerlink" title="6.1 【基础】什么是异常？"></a>6.1 【基础】什么是异常？</h2><p>在程序运行过程中，总会遇到各种各样的问题和错误。</p><ul><li><p>有些错误是我们编写代码时自己造成的，比如语法错误、调用错误，甚至逻辑错误。下面这个例子，在输入 if 后输入回车了，没有按照 Python 的语法规则来，所以直接抛出了语法错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">if</span><br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span><br>     ^<br>SyntaxError: invalid syntax<br></code></pre></td></tr></table></figure></li><li><p>还有一些错误，则是不可预料的错误，但是完全有可能发生的，比如文件不存在、磁盘空间不足、网络堵塞、系统错误等等。下面这个例子，使用 open 函数打开 <code>demo.txt</code> 文件，可是在当前目录下并没有这个文件，所以一定会打开失败，抛出了IOError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>IOError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;demo.txt&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><p>这些导致程序在运行过程中出现异常中断和退出的错误，我们统称为异常。正常情况下，异常都不会被程序处理，而是以错误信息的形式展现出来。</p><p>异常有很多种类型，Python内置了几十种常见的异常，就在builtins模块内，它们无需特别导入，就可以直接使用。需要注意的是，所有的异常都是异常类，首字母是大写的！</p><p>在发生异常的时候，Python会打印出异常信息，信息的前面部分显示了异常发生的上下文环境，并以调用栈的形式显示具体信息。异常类型作为信息的一部分也会被打印出来，例如ZeroDivisionError，TypeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span>/<span class="hljs-number">0</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ZeroDivisionError: integer division <span class="hljs-keyword">or</span> modulo by zero<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span> + <span class="hljs-string">&quot;1&quot;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> +: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>正常情况下，我们都不需要去记住 Python 到底内置了哪些错误和异常类型，除非你需要去捕获它，关于捕获的内容，我会放在下一节。这一节先来认识一下 Python 中有哪些常见的错误和异常，对于新手，下面的内容大概过一下就好，不用深究，因为这些在你以后的编码中都会遇到的。</p><h3 id="1-SyntaxError"><a href="#1-SyntaxError" class="headerlink" title="1.SyntaxError"></a>1.SyntaxError</h3><p>SyntaxError，是语法错误，可能是新手在学习 Python 时最容易遇到的错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br>                   ^<br>SyntaxError: invalid syntax<br></code></pre></td></tr></table></figure><p>解析器会输出出现语法错误的那一行，并显示一个“箭头”，指向这行里面检测到的第一个错误。 错误是由箭头指示的位置 <em>上面</em> 的 token 引起的（或者至少是在这里被检测出的）：在示例中，在 <a href="https://docs.python.org/zh-cn/3/library/functions.html#print"><code>print()</code></a> 这个函数中检测到了错误，因为在它前面少了个冒号 (<code>&#39;:&#39;</code>) 。文件名和行号也会被输出，以便输入来自脚本文件时你能知道去哪检查。</p><h3 id="2、TypeError"><a href="#2、TypeError" class="headerlink" title="2、TypeError"></a>2、TypeError</h3><p>TypeError，是类型错误，也就是说将某个操作或功能应用于不合适类型的对象时引发，比如整型与字符型进行加减法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a-b<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> -: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3、IndexError"><a href="#3、IndexError" class="headerlink" title="3、IndexError"></a>3、IndexError</h3><p>IndexError，是指索引出现了错误，比如最常见下标索引超出了序列边界</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist[<span class="hljs-number">5</span>]<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><h3 id="4、KeyError"><a href="#4、KeyError" class="headerlink" title="4、KeyError"></a>4、KeyError</h3><p>KeyError是关键字错误，这个异常主要发生在字典中，比如当用户试图访问一个字典中不存在的键时会被引发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>profile[<span class="hljs-string">&quot;age&quot;</span>]<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>KeyError: <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="5、ValueError"><a href="#5、ValueError" class="headerlink" title="5、ValueError"></a>5、ValueError</h3><p>ValueError为值错误，当用户传入一个调用者不期望的值时会引发，即使这个值的类型是正确的，比如想获取一个列表中某个不存在值的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;a&quot;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="6、AttributeError"><a href="#6、AttributeError" class="headerlink" title="6、AttributeError"></a>6、AttributeError</h3><p>AttributeError是属性错误，当用户试图访问一个对象不存在的属性时会引发。</p><p>比如字典有get方法，而列表却没有，所以对一个列表对象调用该方法就会引发该异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>alist.get(<span class="hljs-number">0</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;list&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;get&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7、NameError"><a href="#7、NameError" class="headerlink" title="7、NameError"></a>7、NameError</h3><p>NameError是指变量名称发生错误，比如用户试图调用一个还未被赋值或初始化的变量时会被触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>name<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure><h3 id="8、IOError"><a href="#8、IOError" class="headerlink" title="8、IOError"></a>8、IOError</h3><p>IOError 为打开文件错误，当用户试图以读取方式打开一个不存在的文件时引发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>fb = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;demo.txt&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>IOError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;demo.txt&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="9、StopIteration"><a href="#9、StopIteration" class="headerlink" title="9、StopIteration"></a>9、StopIteration</h3><p>StopIteration为迭代器错误，当访问至迭代器最后一个值时仍然继续访问，就会引发这种异常，提醒用户迭代器中已经没有值可供访问了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>agen = <span class="hljs-built_in">iter</span>(alist)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(agen)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(agen)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(agen)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><h3 id="10、AssertionError"><a href="#10、AssertionError" class="headerlink" title="10、AssertionError"></a>10、AssertionError</h3><p>AssertionError 为断言错误，当用户利用断言语句检测异常时，如果断言语句检测的表达式为假，则会引发这种异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>alist = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(alist, <span class="hljs-built_in">list</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(alist, <span class="hljs-built_in">dict</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AssertionError<br></code></pre></td></tr></table></figure><h3 id="11-IndentationError"><a href="#11-IndentationError" class="headerlink" title="11. IndentationError"></a>11. IndentationError</h3><p>Python 是一门严格缩进的语言，如果缩进有问题，就会导致解释器解析异常，抛出 IndentationError</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>        ^<br>IndentationError: expected an indented block<br></code></pre></td></tr></table></figure><h3 id="12-ImportError"><a href="#12-ImportError" class="headerlink" title="12. ImportError"></a>12. ImportError</h3><p>当你在使用 import 导包的时候，如果因为包名错误或者路径不对、包未安装，都会抛出 ImportError</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> oxx<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ImportError: No module named oxx<br></code></pre></td></tr></table></figure><p>上面这些异常应该是平时编程中遇见频率比较高的一部分，还有更多的异常，可以前往官方文档：<a href="https://docs.python.org/3/library/exceptions.html##">https://docs.python.org/3/library/exceptions.html##</a> 6.2 【基础】如何抛出和捕获异常？</p><h3 id="1-如何抛出异常？"><a href="#1-如何抛出异常？" class="headerlink" title="1. 如何抛出异常？"></a>1. 如何抛出异常？</h3><p>异常的产生有两种来源：</p><ul><li>一种是程序自动抛出，比如 <code>1/0</code> 会自动抛出 ZeroDivisionError</li><li>一种是开发者主动抛出，使用 <code>raise</code> 关键字抛出。</li></ul><p>在 Python 中是使用 <code>raise</code> 关键字来抛出异常的，比如在下面这个函数中，如果不存在目标文件，则会抛出一个 Exception 通用异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isfile(filename):<br>        <span class="hljs-keyword">raise</span> Exception<br></code></pre></td></tr></table></figure><h3 id="2-如何捕获异常？"><a href="#2-如何捕获异常？" class="headerlink" title="2. 如何捕获异常？"></a>2. 如何捕获异常？</h3><p>出现错误或者异常没有关系，关键在于你要学会预判程序可能会出现的错误或异常，然后在代码中捕获这些异常并处理。</p><p>异常的捕获的语法有如下四种：</p><h4 id="第一种语法"><a href="#第一种语法" class="headerlink" title="第一种语法"></a>第一种语法</h4><p>只捕捉但是不想获取异常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>代码A<br><span class="hljs-keyword">except</span> [EXCEPTION]:<br>代码B<br></code></pre></td></tr></table></figure><h4 id="第二种语法"><a href="#第二种语法" class="headerlink" title="第二种语法"></a>第二种语法</h4><p>不但捕捉了还要获取异常信息，赋值给 e 后，后面你可以把异常信息打印到日志中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>代码A<br><span class="hljs-keyword">except</span> [EXCEPTION] <span class="hljs-keyword">as</span> e:<br>代码B<br></code></pre></td></tr></table></figure><p>有了上面的基础语法，可以扩展出下面三种常用的异常捕获的写法。</p><h4 id="第三种语法"><a href="#第三种语法" class="headerlink" title="第三种语法"></a>第三种语法</h4><p>正常使用 <code>try ... except ...</code></p><p>如果代码A发生了异常，则会走到代码B的逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    代码A<br><span class="hljs-keyword">except</span> [exception] <span class="hljs-keyword">as</span> e :<br>    代码B<br></code></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发生了异常：错误信息如下: \n&quot;</span> + <span class="hljs-built_in">str</span>(e))<br><span class="hljs-meta">... </span><br>发生了异常：错误信息如下: <br>integer division <span class="hljs-keyword">or</span> modulo by zero<br></code></pre></td></tr></table></figure><h4 id="第四种语法"><a href="#第四种语法" class="headerlink" title="第四种语法"></a>第四种语法</h4><p>使用 <code>try ... except ... else</code> </p><p>如果代码A发生了异常，则会走到代码B的逻辑，如果没有发生异常，则会走到代码C</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    代码A<br><span class="hljs-keyword">except</span> [exception] <span class="hljs-keyword">as</span> e:<br>    代码B<br><span class="hljs-keyword">else</span>:<br>    代码C<br></code></pre></td></tr></table></figure><p>举个例子</p><p>不发生异常的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-number">4</span>/<span class="hljs-number">2</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发生了异常：错误信息如下: \n&quot;</span> + <span class="hljs-built_in">str</span>(e))<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序正常运行&quot;</span>)<br><span class="hljs-meta">... </span><br><span class="hljs-number">2</span><br>程序正常运行<br></code></pre></td></tr></table></figure><p>发生异常的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发生了异常：错误信息如下: \n&quot;</span> + <span class="hljs-built_in">str</span>(e))<br><span class="hljs-meta">... </span><span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序正常运行&quot;</span>)<br><span class="hljs-meta">... </span><br>发生了异常：错误信息如下: <br>integer division <span class="hljs-keyword">or</span> modulo by zero<br></code></pre></td></tr></table></figure><ul><li>第三种：使用 <code>try ... except ... finally</code></li></ul><p>如果代码A发生了异常，则会走到代码B的逻辑，最后不管有没有发生异常都会走到代码C</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    代码A<br><span class="hljs-keyword">except</span> [exception] <span class="hljs-keyword">as</span> e:<br>    代码B<br><span class="hljs-keyword">finally</span>:<br>    代码C<br></code></pre></td></tr></table></figure><p>举个例子</p><p>发生异常的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发生了异常：错误信息如下: \n&quot;</span> + <span class="hljs-built_in">str</span>(e))<br><span class="hljs-meta">... </span><span class="hljs-keyword">finally</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序运行结束!!&quot;</span>)<br><span class="hljs-meta">... </span><br>发生了异常：错误信息如下: <br>integer division <span class="hljs-keyword">or</span> modulo by zero<br>程序运行结束!!<br></code></pre></td></tr></table></figure><p>不发生异常的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-number">4</span>/<span class="hljs-number">2</span><br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发生了异常：错误信息如下: \n&quot;</span> + <span class="hljs-built_in">str</span>(e))<br><span class="hljs-meta">... </span><span class="hljs-keyword">finally</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;程序运行结束!!&quot;</span>)<br><span class="hljs-meta">... </span><br><span class="hljs-number">2</span><br>程序运行结束!!<br></code></pre></td></tr></table></figure><h3 id="3-捕获多个异常？"><a href="#3-捕获多个异常？" class="headerlink" title="3. 捕获多个异常？"></a>3. 捕获多个异常？</h3><h4 id="每个except捕获一个异常"><a href="#每个except捕获一个异常" class="headerlink" title="每个except捕获一个异常"></a>每个except捕获一个异常</h4><p>一个 try 语句可能有多个 except 子句，以指定不同异常的处理程序，但是最多会执行一个处理程序。 </p><p>当代码 A 在运行中抛出了异常时，Python 解释器会逐行运行代码，如果抛出的异常是 <code>exception1</code> 那么后面直接运行代码B，运行完 B 后，就不会再判断后面两个 except 语句了。</p><p>而如果不是 <code>exception1</code> ，而是 <code>exception2</code> ，那会运行代码C，而不会再运行第三个 except 语句了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    代码A<br><span class="hljs-keyword">except</span> [exception1] <span class="hljs-keyword">as</span> e:<br>    代码B<br><span class="hljs-keyword">except</span> [exception2] <span class="hljs-keyword">as</span> e:<br>    代码C<br><span class="hljs-keyword">except</span> [exception3] <span class="hljs-keyword">as</span> e:<br>    代码D<br></code></pre></td></tr></table></figure><p>举个例子吧，下面这段代码，由于 <code>1/0</code> 会抛出 <code>ZeroDivisionError</code> 错误，所以前面两个异常匹配都不成功，而在最后一个 except 成功匹配上，最终打印出 <code>除数不能为 0</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> IOError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IO读写出错&quot;</span>)<br><span class="hljs-keyword">except</span> FloatingPointError:<br>    <span class="hljs-comment"># 浮点计算错误</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算错误&quot;</span>)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-comment"># 除数不能为 0</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算错误&quot;</span>)<br><span class="hljs-comment">## output: 计算错误</span><br></code></pre></td></tr></table></figure><h4 id="一个except捕获多个异常"><a href="#一个except捕获多个异常" class="headerlink" title="一个except捕获多个异常"></a>一个except捕获多个异常</h4><p>上面的例子可以看出来，第二个异常和第三个异常是属于同一类，就是 <code>计算错误</code>，异常处理的代码是一样的，那有没有办法将它们合并在一起呢，简化一下代码呢？</p><p>答案是，可以的。</p><p>在 except 后面其实是可以接多个异常的，多个异常之间使用括号包裹。只要匹配上一个就算捕获到，就会进入相应的代码分支。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> IOError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;IO读写出错&quot;</span>)<br><span class="hljs-keyword">except</span> (ZeroDivisionError, FloatingPointError):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算出错&quot;</span>)<br><span class="hljs-comment">## output: 计算错误</span><br></code></pre></td></tr></table></figure><h2 id="6-3-【基础】如何自定义异常？"><a href="#6-3-【基础】如何自定义异常？" class="headerlink" title="6.3 【基础】如何自定义异常？"></a>6.3 【基础】如何自定义异常？</h2><p>大多数情况下，内置的错误和异常已经够用了，但是有时候你还是需要自定义一些异常。</p><p>自定义异常，需要你对 <code>类</code> 与 <code>继承</code> 有一些了解，对于类的知识，我放在了第七章，因此你可以先前往学习下第七章的的下面两节内容：</p><ul><li><a href="https://python.iswbm.com/c07/c07_01.html">7.1 类的理解与使用</a> </li><li><a href="https://python.iswbm.com/c07/c07_05.html">7.5 类的继承（Inheritance）</a></li></ul><p>等学习完后再回过头来学习本节内容。</p><p>自定义异常应该继承 <code>Exception</code> 类，直接继承或者间接继承都可以，自定义的异常或错误类，下面使用 <code>InputError</code> ，表示接受用户输入时发生问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, msg</span>):<br>        self.message = msg<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.message<br></code></pre></td></tr></table></figure><p>异常的名字都以<code>Error</code>结尾，我们在为自定义异常命名的时候也需要遵守这一规范，就跟标准的异常命名一样。</p><p>定义完后，再看如下代码，我在 try 里调用 get_input 函数，如果发现用户没有输入内容，就使用 <code>raise</code> 关键字来抛出 <code>InputError</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_input</span>():<br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的姓名：&quot;</span>)<br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span>:<br>        <span class="hljs-keyword">raise</span> InputError(<span class="hljs-string">&quot;未输入内容&quot;</span>)<br><br><span class="hljs-keyword">try</span>:<br>    get_input()<br><span class="hljs-keyword">except</span> InputError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h2 id="6-4-【进阶】如何关闭异常自动关联上下文？"><a href="#6-4-【进阶】如何关闭异常自动关联上下文？" class="headerlink" title="6.4 【进阶】如何关闭异常自动关联上下文？"></a>6.4 【进阶】如何关闭异常自动关联上下文？</h2><p>当你在处理异常时，由于处理不当或者其他问题，再次抛出另一个异常时，往外抛出的异常也会携带原始的异常信息。</p><p>就像这样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>)<br></code></pre></td></tr></table></figure><p>从输出可以看到两个异常信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;demo.py&quot;</span>, line <span class="hljs-number">2</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br><br>During handling of the above exception, another exception occurred:<br><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>)<br>RuntimeError: Something bad happened<br></code></pre></td></tr></table></figure><p>如果在异常处理程序或 finally 块中引发异常，默认情况下，异常机制会隐式工作会将先前的异常附加为新异常的 <code>__context__</code>属性。这就是 Python 默认开启的自动关联异常上下文。</p><p>如果你想自己控制这个上下文，可以加个 from 关键字（<code>from</code> 语法会有个限制，就是第二个表达式必须是另一个异常类或实例。），来表明你的新异常是直接由哪个异常引起的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>) <span class="hljs-keyword">from</span> exc<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;demo.py&quot;</span>, line <span class="hljs-number">2</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br><br>The above exception was the direct cause of the following exception:<br><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>) <span class="hljs-keyword">from</span> exc<br>RuntimeError: Something bad happened<br></code></pre></td></tr></table></figure><p>当然，你也可以通过<code>with_traceback()</code>方法为异常设置上下文<code>__context__</code>属性，这也能在<code>traceback</code>更好的显示异常信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;bad thing&quot;</span>).with_traceback(exc)<br></code></pre></td></tr></table></figure><p>最后，如果我想彻底关闭这个自动关联异常上下文的机制？有什么办法呢？</p><p>可以使用 <code>raise...from None</code>，从下面的例子上看，已经没有了原始异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">$ cat demo.py<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>) <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br>$<br>$ python demo.py<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;demo.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;Something bad happened&quot;</span>) <span class="hljs-keyword">from</span> <span class="hljs-literal">None</span><br>RuntimeError: Something bad happened<br>(PythonCodingTime)<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="6-5-【进阶】异常处理的三个好习惯"><a href="#6-5-【进阶】异常处理的三个好习惯" class="headerlink" title="6.5 【进阶】异常处理的三个好习惯"></a>6.5 【进阶】异常处理的三个好习惯</h2><p>本文作者：piglei</p><p>本文来源：<a href="https://github.com/piglei/one-python-craftsman">https://github.com/piglei/one-python-craftsman</a></p><hr><p>如果你用 Python 编程，那么你就无法避开异常，因为异常在这门语言里无处不在。打个比方，当你在脚本执行时按 <code>ctrl+c</code> 退出，解释器就会产生一个 <code>KeyboardInterrupt</code> 异常。而 <code>KeyError</code>、<code>ValueError</code>、<code>TypeError</code> 等更是日常编程里随处可见的老朋友。</p><p>异常处理工作由“捕获”和“抛出”两部分组成。“捕获”指的是使用 <code>try ... except</code> 包裹特定语句，妥当的完成错误流程处理。而恰当的使用 <code>raise</code> 主动“抛出”异常，更是优雅代码里必不可少的组成部分。</p><p>在这篇文章里，我会分享与异常处理相关的 3 个好习惯。继续阅读前，我希望你已经了解了下面这些知识点：</p><ul><li>异常的基本语法与用法<em>（建议阅读官方文档 <a href="https://docs.python.org/3.6/tutorial/errors.html">“Errors and Exceptions”</a>）</em></li><li>为什么要使用异常代替错误返回<em>（建议阅读<a href="https://www.zlovezl.cn/articles/function-returning-tips/">《让函数返回结果的技巧》</a>）</em></li><li>为什么在写 Python 时鼓励使用异常 <em>（建议阅读 <a href="https://jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/">“Write Cleaner Python: Use Exceptions”</a>）</em></li></ul><h3 id="1-只做最精确的异常捕获"><a href="#1-只做最精确的异常捕获" class="headerlink" title="1. 只做最精确的异常捕获"></a>1. 只做最精确的异常捕获</h3><p>假如你不够了解异常机制，就难免会对它有一种天然恐惧感。你可能会觉得：<em>异常是一种不好的东西，好的程序就应该捕获所有的异常，让一切都平平稳稳的运行。</em>而抱着这种想法写出的代码，里面通常会出现大段含糊的异常捕获逻辑。</p><p>让我们用一段可执行脚本作为样例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_website_title</span>(<span class="hljs-params">url, filename</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;获取某个地址的网页标题，然后将其写入到文件中</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    :returns: 如果成功保存，返回 True，否则打印错误，返回 False</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        resp = requests.get(url)<br>        obj = re.search(<span class="hljs-string">r&#x27;&lt;title&gt;(.*)&lt;/title&gt;&#x27;</span>, resp.text)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> obj:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;save failed: title tag not found in page content&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        title = obj.grop(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>            fp.write(title)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;save failed: unable to save title of <span class="hljs-subst">&#123;url&#125;</span> to <span class="hljs-subst">&#123;filename&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    save_website_title(<span class="hljs-string">&#x27;https://www.qq.com&#x27;</span>, <span class="hljs-string">&#x27;qq_title.txt&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>脚本里的 <code>save_website_title</code> 函数做了好几件事情。它首先通过网络获取网页内容，然后利用正则匹配出标题，最后将标题写在本地文件里。而这里有两个步骤很容易出错：<strong>网络请求</strong> 与 <strong>本地文件操作</strong>。所以在代码里，我们用一个大大的 <code>try ... except</code> 语句块，将这几个步骤都包裹了起来。<strong>安全第一</strong> ⛑。</p><p>那么，这段看上去简洁易懂的代码，里面藏着什么问题呢？</p><p>如果你旁边刚好有一台安装了 Python 的电脑，那么你可以试着跑一遍上面的脚本。你会发现，上面的代码是不能成功执行的。而且你还会发现，无论你如何修改网址和目标文件的值，程序仍然会报错 <em>“save failed: unable to…”</em>。为什么呢？</p><p>问题就藏在这个硕大无比的 <code>try ... except</code> 语句块里。假如你把眼睛贴近屏幕，非常仔细的检查这段代码。你会发现在编写函数时，我犯了一个<strong>小错误</strong>，我把获取正则匹配串的方法错打成了 <code>obj.grop(1)</code>，少了一个 ‘u’（<code>obj.group(1)</code>）。</p><p>但正是因为那个过于庞大、含糊的异常捕获，这个由打错方法名导致的原本该被抛出的 <code>AttibuteError</code> 却被吞噬了。从而给我们的 debug 过程增加了不必要的麻烦。</p><p>异常捕获的目的，不是去捕获尽可能多的异常。假如我们从一开始就坚持：<strong>只做最精准的异常捕获</strong>。那么这样的问题就根本不会发生，精准捕获包括：</p><ul><li>永远只捕获那些可能会抛出异常的语句块</li><li>尽量只捕获精确的异常类型，而不是模糊的 <code>Exception</code></li></ul><p>依照这个原则，我们的样例应该被改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> requests.exceptions <span class="hljs-keyword">import</span> RequestException<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">save_website_title</span>(<span class="hljs-params">url, filename</span>):<br>    <span class="hljs-keyword">try</span>:<br>        resp = requests.get(url)<br>    <span class="hljs-keyword">except</span> RequestException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;save failed: unable to get page content: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 这段正则操作本身就是不应该抛出异常的，所以我们没必要使用 try 语句块</span><br>    <span class="hljs-comment"># 假如 group 被误打成了 grop 也没关系，程序马上就会通过 AttributeError 来</span><br>    <span class="hljs-comment"># 告诉我们。</span><br>    obj = re.search(<span class="hljs-string">r&#x27;&lt;title&gt;(.*)&lt;/title&gt;&#x27;</span>, resp.text)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> obj:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;save failed: title tag not found in page content&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    title = obj.group(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>            fp.write(title)<br>    <span class="hljs-keyword">except</span> IOError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;save failed: unable to write to file <span class="hljs-subst">&#123;filename&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="2-别让异常破坏抽象一致性"><a href="#2-别让异常破坏抽象一致性" class="headerlink" title="2. 别让异常破坏抽象一致性"></a>2. 别让异常破坏抽象一致性</h3><p>大约四五年前，当时的我正在开发某移动应用的后端 API 项目。如果你也有过开发后端 API 的经验，那么你一定知道，这样的系统都需要制定一套<strong>“API 错误码规范”</strong>，来为客户端处理调用错误时提供方便。</p><p>一个错误码返回大概长这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTTP Status Code: 400</span><br><span class="hljs-comment">// Content-Type: application/json</span><br>&#123;<br>    <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;UNABLE_TO_UPVOTE_YOUR_OWN_REPLY&quot;</span>,<br>    <span class="hljs-string">&quot;detail&quot;</span>: <span class="hljs-string">&quot;你不能推荐自己的回复&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在制定好错误码规范后，接下来的任务就是如何实现它。当时的项目使用了 Django 框架，而 Django 的错误页面正是使用了异常机制实现的。打个比方，如果你想让一个请求返回 404 状态码，那么只要在该请求处理过程中执行 <code>raise Http404</code> 即可。</p><p>所以，我们很自然的从 Django 获得了灵感。首先，我们在项目内定义了错误码异常类：<code>APIErrorCode</code>。然后依据“错误码规范”，写了很多继承该类的错误码。当需要返回错误信息给用户时，只需要做一次 <code>raise</code> 就能搞定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">raise</span> error_codes.UNABLE_TO_UPVOTE<br><span class="hljs-keyword">raise</span> error_codes.USER_HAS_BEEN_BANNED<br><span class="hljs-meta">... </span>...<br></code></pre></td></tr></table></figure><p>毫无意外，所有人都很喜欢用这种方式来返回错误码。因为它用起来非常方便，无论调用栈多深，只要你想给用户返回错误码，调用 <code>raise error_codes.ANY_THING</code> 就好。</p><p>随着时间推移，项目也变得越来越庞大，抛出 <code>APIErrorCode</code> 的地方也越来越多。有一天，我正准备复用一个底层图片处理函数时，突然碰到了一个问题。</p><p>我看到了一段让我非常纠结的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 在某个处理图像的模块内部</span><br><span class="hljs-comment">## &lt;PROJECT_ROOT&gt;/util/image/processor.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_image</span>(<span class="hljs-params">...</span>):<br>    <span class="hljs-keyword">try</span>:<br>        image = Image.<span class="hljs-built_in">open</span>(fp)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 说明（非项目原注释）：该异常将会被 Django 的中间件捕获，往前端返回</span><br>        <span class="hljs-comment"># &quot;上传的图片格式有误&quot; 信息</span><br>        <span class="hljs-keyword">raise</span> error_codes.INVALID_IMAGE_UPLOADED<br>    ... ...<br></code></pre></td></tr></table></figure><p><code>process_image</code> 函数会尝试解析一个文件对象，如果该对象不能被作为图片正常打开，就抛出 <code>error_codes.INVALID_IMAGE_UPLOADED （APIErrorCode 子类）</code> 异常，从而给调用方返回错误代码 JSON。</p><p>让我给你从头理理这段代码。最初编写 <code>process_image</code> 时，我虽然把它放在了 <code>util.image</code> 模块里，但当时调这个函数的地方就只有 <em>“处理用户上传图片的 POST 请求”</em> 而已。为了偷懒，我让函数直接抛出 <code>APIErrorCode</code> 异常来完成了错误处理工作。</p><p>再来说当时的问题。那时我需要写一个在后台运行的批处理图片脚本，而它刚好可以复用 <code>process_image</code> 函数所实现的功能。但这时不对劲的事情出现了，如果我想复用该函数，那么：</p><ul><li>我必须去捕获一个名为 <code>INVALID_IMAGE_UPLOADED</code> 的异常<ul><li><strong>哪怕我的图片根本就不是来自于用户上传</strong></li></ul></li><li>我必须引入 <code>APIErrorCode</code> 异常类作为依赖来捕获异常<ul><li><strong>哪怕我的脚本和 Django API 根本没有任何关系</strong></li></ul></li></ul><p><strong>这就是异常类抽象层级不一致导致的结果。</strong>APIErrorCode 异常类的意义，在于表达一种能够直接被终端用户（人）识别并消费的“错误代码”。<strong>它在整个项目里，属于最高层的抽象之一。</strong>但是出于方便，我们却在底层模块里引入并抛出了它。这打破了 <code>image.processor</code> 模块的抽象一致性，影响了它的可复用性和可维护性。</p><p>这类情况属于“模块抛出了<strong>高于</strong>所属抽象层级的异常”。避免这类错误需要注意以下几点：</p><ul><li>让模块只抛出与当前抽象层级一致的异常<ul><li>比如 <code>image.processer</code> 模块应该抛出自己封装的 <code>ImageOpenError</code> 异常</li></ul></li><li>在必要的地方进行异常包装与转换<ul><li>比如，应该在贴近高层抽象（视图 View 函数）的地方，将图像处理模块的 <code>ImageOpenError</code> 低级异常包装转换为 <code>APIErrorCode</code> 高级异常</li></ul></li></ul><p>修改后的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## &lt;PROJECT_ROOT&gt;/util/image/processor.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageOpenError</span>(<span class="hljs-title class_ inherited__">Exception</span>):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_image</span>(<span class="hljs-params">...</span>):<br>    <span class="hljs-keyword">try</span>:<br>        image = Image.<span class="hljs-built_in">open</span>(fp)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> ImageOpenError(exc=e)<br>    ... ...<br>    <br><span class="hljs-comment">## &lt;PROJECT_ROOT&gt;/app/views.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo_view_function</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">try</span>:<br>        process_image(fp)<br>    <span class="hljs-keyword">except</span> ImageOpenError:<br>        <span class="hljs-keyword">raise</span> error_codes.INVALID_IMAGE_UPLOADED<br></code></pre></td></tr></table></figure><p>除了应该避免抛出<strong>高于</strong>当前抽象级别的异常外，我们同样应该避免泄露<strong>低于</strong>当前抽象级别的异常。</p><p>如果你用过 <code>requests</code> 模块，你可能已经发现它请求页面出错时所抛出的异常，并不是它在底层所使用的 <code>urllib3</code> 模块的原始异常，而是通过 <code>requests.exceptions</code> 包装过一次的异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>    requests.get(<span class="hljs-string">&#x27;https://www.invalid-host-foo.com&#x27;</span>)<br><span class="hljs-meta">... </span><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(e))<br>...<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;requests.exceptions.ConnectionError&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>这样做同样是为了保证异常类的抽象一致性。因为 urllib3 模块是 requests 模块依赖的底层实现细节，而这个细节有可能在未来版本发生变动。所以必须对它抛出的异常进行恰当的包装，避免未来的底层变更对 <code>requests</code> 用户端错误处理逻辑产生影响。</p><h3 id="3-异常处理不应该喧宾夺主"><a href="#3-异常处理不应该喧宾夺主" class="headerlink" title="3. 异常处理不应该喧宾夺主"></a>3. 异常处理不应该喧宾夺主</h3><p>在前面我们提到异常捕获要精准、抽象级别要一致。但在现实世界中，如果你严格遵循这些流程，那么很有可能会碰上另外一个问题：<strong>异常处理逻辑太多，以至于扰乱了代码核心逻辑</strong>。具体表现就是，代码里充斥着大量的 <code>try</code>、<code>except</code>、<code>raise</code> 语句，让核心逻辑变得难以辨识。</p><p>让我们看一段例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_avatar</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;用户上传新头像&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        avatar_file = request.FILES[<span class="hljs-string">&#x27;avatar&#x27;</span>]<br>    <span class="hljs-keyword">except</span> KeyError:<br>        <span class="hljs-keyword">raise</span> error_codes.AVATAR_FILE_NOT_PROVIDED<br><br>    <span class="hljs-keyword">try</span>:<br>       resized_avatar_file = resize_avatar(avatar_file)<br>    <span class="hljs-keyword">except</span> FileTooLargeError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> error_codes.AVATAR_FILE_TOO_LARGE<br>    <span class="hljs-keyword">except</span> ResizeAvatarError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> error_codes.AVATAR_FILE_INVALID<br><br>    <span class="hljs-keyword">try</span>:<br>        request.user.avatar = resized_avatar_file<br>        request.user.save()<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">raise</span> error_codes.INTERNAL_SERVER_ERROR<br>    <span class="hljs-keyword">return</span> HttpResponse(&#123;&#125;)<br></code></pre></td></tr></table></figure><p>这是一个处理用户上传头像的视图函数。这个函数内做了三件事情，并且针对每件事都做了异常捕获。如果做某件事时发生了异常，就返回对用户友好的错误到前端。</p><p>这样的处理流程纵然合理，但是显然代码里的异常处理逻辑有点“喧宾夺主”了。一眼看过去全是代码缩进，很难提炼出代码的核心逻辑。</p><p>早在 2.5 版本时，Python 语言就已经提供了对付这类场景的工具：“上下文管理器（context manager）”。上下文管理器是一种配合 <code>with</code> 语句使用的特殊 Python 对象，通过它，可以让异常处理工作变得更方便。</p><p>那么，如何利用上下文管理器来改善我们的异常处理流程呢？让我们直接看代码吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">raise_api_error</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;captures specified exception and raise ApiErrorCode instead</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :raises: AttributeError if code_name is not valid</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, captures, code_name</span>):<br>        self.captures = captures<br>        self.code = <span class="hljs-built_in">getattr</span>(error_codes, code_name)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 该方法将在进入上下文时调用</span><br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-comment"># 该方法将在退出上下文时调用</span><br>        <span class="hljs-comment"># exc_type, exc_val, exc_tb 分别表示该上下文内抛出的</span><br>        <span class="hljs-comment"># 异常类型、异常值、错误栈</span><br>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-keyword">if</span> exc_type == self.captures:<br>            <span class="hljs-keyword">raise</span> self.code <span class="hljs-keyword">from</span> exc_val<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在上面的代码里，我们定义了一个名为 <code>raise_api_error</code> 的上下文管理器，它在进入上下文时什么也不做。但是在退出上下文时，会判断当前上下文中是否抛出了类型为 <code>self.captures</code> 的异常，如果有，就用 <code>APIErrorCode</code> 异常类替代它。</p><p>使用该上下文管理器后，整个函数可以变得更清晰简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_avatar</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;用户上传新头像&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">with</span> raise_api_error(KeyError, <span class="hljs-string">&#x27;AVATAR_FILE_NOT_PROVIDED&#x27;</span>):<br>        avatar_file = request.FILES[<span class="hljs-string">&#x27;avatar&#x27;</span>]<br><br>    <span class="hljs-keyword">with</span> raise_api_error(ResizeAvatarError, <span class="hljs-string">&#x27;AVATAR_FILE_INVALID&#x27;</span>),\<br>            raise_api_error(FileTooLargeError, <span class="hljs-string">&#x27;AVATAR_FILE_TOO_LARGE&#x27;</span>):<br>        resized_avatar_file = resize_avatar(avatar_file)<br><br>    <span class="hljs-keyword">with</span> raise_api_error(Exception, <span class="hljs-string">&#x27;INTERNAL_SERVER_ERROR&#x27;</span>):<br>        request.user.avatar = resized_avatar_file<br>        request.user.save()<br>    <span class="hljs-keyword">return</span> HttpResponse(&#123;&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>Hint：建议阅读 <a href="https://www.python.org/dev/peps/pep-0343/">PEP 343 – The “with” Statement | Python.org</a>，了解与上下文管理器有关的更多知识。</p><p>模块 <a href="https://docs.python.org/3/library/contextlib.html">contextlib</a> 也提供了非常多与编写上下文管理器相关的工具函数与样例。</p></blockquote><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>在这篇文章中，我分享了与异常处理相关的三个建议。最后再总结一下要点：</p><ul><li>只捕获可能会抛出异常的语句，避免含糊的捕获逻辑</li><li>保持模块异常类的抽象一致性，必要时对底层异常类进行包装</li><li>使用“上下文管理器”可以简化重复的异常处理逻辑</li></ul><h1 id="第七章：类与对象"><a href="#第七章：类与对象" class="headerlink" title="第七章：类与对象"></a>第七章：类与对象</h1><h2 id="7-1-【基础】类的理解与使用"><a href="#7-1-【基础】类的理解与使用" class="headerlink" title="7.1 【基础】类的理解与使用"></a>7.1 【基础】类的理解与使用</h2><h3 id="1-通俗理解类"><a href="#1-通俗理解类" class="headerlink" title="1. 通俗理解类"></a>1. 通俗理解类</h3><p>类（英文名 class），是具有相同特性（属性）和行为（方法）的对象（实例）的抽象模板。</p><p>从定义上来理解类，是一件非常吃力的事情，特别是对那些没有任何基础的初学者。</p><p>下面我举例来说明类中一些关键术语都是什么意思：</p><ul><li>类：动物属于一个类，植物属于一个类</li><li>实例：猫和狗都属于同一类，就是动物类，那么猫和狗是动物类的实例&#x2F;对象。</li><li>属性：类中所有的变量，都叫做属性。</li><li>方法：类中的所有函数，都叫做方法。</li></ul><p>类与对象的关系就如模具和铸件的关系，类的实例化的结果就是对象，而对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为（方法）的对象。</p><h3 id="2-如何定义类？"><a href="#2-如何定义类？" class="headerlink" title="2. 如何定义类？"></a>2. 如何定义类？</h3><p>定义一个类，使用的是 class 关键字</p><p>下边我定义了一个 Animal 的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    age = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> 跑起来了&quot;</span>)<br></code></pre></td></tr></table></figure><p>其中</p><ul><li><code>Animal</code> 是类名</li><li><code>__init__</code> 是构造函数，用于实例的初始化</li><li><code>self.name</code> 是实例属性，<code>age</code>  是类属性</li><li><code>run</code> 是方法，第一个参数 self 是什么意思呢？这个咱后面再讲。</li></ul><p>除了上面这种写法外</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 第一种写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>  ...<br></code></pre></td></tr></table></figure><p>还有另外两种写法，与之是等价的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 第二种写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>():<br>  ...<br>  <br><span class="hljs-comment">## 第二种写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<br>  ...<br></code></pre></td></tr></table></figure><p>因为在 Python 3 中，无论你是否显示继承自 object，Python 解释器都会默认你继承 object ，这是新式类的写法，与之对应的是 Python 2 的经典类写法（Python 2 已经远去，无需要再了解经典类写法）。</p><h3 id="3-如何实例化？"><a href="#3-如何实例化？" class="headerlink" title="3. 如何实例化？"></a>3. 如何实例化？</h3><p>定义了类之后，就可以通过下边的写法实例化它，并访问属性，调用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-meta">... </span>        self.name = name<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> 跑起来了&quot;</span>)<br>...<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)  <span class="hljs-comment"># 实例化出 dog 对象</span><br></code></pre></td></tr></table></figure><p>在实例化时传入的参数 <code>name=&quot;小黑&quot;</code> 传进入到构造函数 <code>__init__</code> 中，最终赋值 <code>self.name</code> 成为实例的属性。</p><h3 id="4-方法的调用"><a href="#4-方法的调用" class="headerlink" title="4. 方法的调用"></a>4. 方法的调用</h3><p>实例化成对象后，如果访问实例属性，可以用 <code>对象.属性名</code> 进行访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog.name  <span class="hljs-comment"># 访问属性</span><br><span class="hljs-string">&#x27;小黑&#x27;</span><br></code></pre></td></tr></table></figure><p>如果要调用方法，有两种方法</p><ol><li>通过 <code>对象.方法名</code>：使用这种方法，在定义方法时 self 就代表对象（dog），调用时无需再传入了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog.run()  <span class="hljs-comment"># 调用方法</span><br>小黑 跑起来了<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 <code>类.方法名</code>：使用这种方法，self 参数要传入实例对象</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Animal.run(dog)<br>小黑 跑起来了<br></code></pre></td></tr></table></figure><h2 id="7-2-【基础】静态方法与类方法"><a href="#7-2-【基础】静态方法与类方法" class="headerlink" title="7.2 【基础】静态方法与类方法"></a>7.2 【基础】静态方法与类方法</h2><h3 id="1-写法上的差异"><a href="#1-写法上的差异" class="headerlink" title="1. 写法上的差异"></a>1. 写法上的差异</h3><p>类的方法可以分为：</p><ol><li>静态方法：有 <code>staticmethod</code> 装饰的函数</li><li>类方法：有 <code>classmethod</code> 装饰的函数</li><li>实例方法：没有任何装饰器的普通函数</li></ol><p>举个例子，如下这段代码中，<code>run</code> 普通的实例方法，<code>eat</code>  是静态方法，<code>jump</code> 是类方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>跑起来啦&quot;</span>)<br>        <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在吃饭...&quot;</span>)<br>        <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">cls, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>跳起来啦&quot;</span>)<br></code></pre></td></tr></table></figure><p>这三种方法，在写法有很大的区别：</p><p>1、普通的实例方法，在定义时，他的第一个方法固定是 self，如果是从实例调用，那么 self 参数 不需要传入，如果是通过类调用，那么 self 要传入已经实例化的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog.run()<br>小黑跑起来啦<br><span class="hljs-meta">&gt;&gt;&gt; </span>Animal.run(dog)<br>小黑跑起来啦<br></code></pre></td></tr></table></figure><p>2、静态方法，在定义时，不需要 self 参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog.eat()<br>正在吃饭...<br><span class="hljs-meta">&gt;&gt;&gt; </span>Animal.eat()<br>正在吃饭...<br></code></pre></td></tr></table></figure><p>3、类方法，在定义时，第一个参数固定是 cls，为 class 的简写，代表类本身。不管是通过实例还是类调用类方法，都不需要传入 cls 的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>dog=Animal(name=<span class="hljs-string">&quot;小黑&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog.jump(<span class="hljs-string">&quot;小黑&quot;</span>)<br>小黑跳起来啦<br><span class="hljs-meta">&gt;&gt;&gt; </span>Animal.jump(<span class="hljs-string">&quot;小黑&quot;</span>)<br>小黑跳起来啦<br></code></pre></td></tr></table></figure><h3 id="2-方法与函数区别"><a href="#2-方法与函数区别" class="headerlink" title="2. 方法与函数区别"></a>2. 方法与函数区别</h3><p>在前面，我们很经常提到方法和函数，为免有同学将他们混为一谈，我这里总结一下他们的区别。</p><p>在 Python 3.x 中，</p><ol><li><p>普通函数（未定位在类里）和静态方法，都是函数（<code>function</code> ）。</p></li><li><p>实例方法（@staticmethod）和类方法，都是方法（<code>method</code> ）。</p></li></ol><p>这些结论其实都可以使用 <code>type</code> 函数得到验证。</p><p>先准备如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>跑起来啦&quot;</span>)<br>        <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在吃饭...&quot;</span>)<br>        <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">jump</span>(<span class="hljs-params">cls, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>跳起来啦&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>然后进入 Python Console 模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(demo_func)  <span class="hljs-comment"># 普通函数</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(dog.eat)   <span class="hljs-comment"># 静态方法</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(dog.run)  <span class="hljs-comment"># 实例方法</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(dog.jump)  <span class="hljs-comment"># 类方法</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;method&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>到这里，你应该会有疑问了吧？</p><p>类方法和实例方法，名字本身就有方法，也是方法也说得过去。那静态方法呢，为什么不是方法而是函数呢？</p><p>对此，我的理解是：方法是一种和对象（实例或者类）绑定后的特殊函数。</p><p>方法本质上还是函数，不同之处在于它与对象进行绑定。## 7.3 【基础】私有变量与私有方法</p><h3 id="1-下划线妙用"><a href="#1-下划线妙用" class="headerlink" title="1. 下划线妙用"></a>1. 下划线妙用</h3><p>在 Python 中，下划线可是非常推荐使用的符号：</p><ol><li>变量名推荐使用下划线分隔的蛇形命名法</li><li>魔法方法、构造函数都需要使用双下划线</li><li>对于暂时用不到的变量值，可以赋值给单下划线 <code>_</code> 进行占位</li></ol><p>根据分类，我把下划线写法分成下面五种：</p><ul><li>单前导下划线：<code>_var</code> </li><li>单末尾下划线：<code>var_</code> </li><li>双前导下划线：<code>__var</code></li><li>双前导和末尾下划线：<code>__var__</code></li><li>单下划线：<code>_</code></li></ul><p>由于篇幅所限，本篇将只介绍跟标题（私有变量与私有方法）有关的用法，也就是访问控制。</p><p>上面五种写法中，涉及到访问控制的有：<code>_var</code>  和 <code>__var</code></p><h3 id="2-单前导下划线-var"><a href="#2-单前导下划线-var" class="headerlink" title="2. 单前导下划线 _var"></a>2. 单前导下划线 _var</h3><p>下划线前缀的含义是告知其他程序员：<strong>以单个下划线开头的变量或方法仅供内部使用</strong>。</p><p>请看下面这个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>:<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>       self.foo = <span class="hljs-number">11</span><br>       self._bar = <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>如果你实例化此类，然后分别访问 <code>self.foo</code> 和 <code>self._bar</code> 会发生什么情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo = Demo()<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo.foo<br><span class="hljs-number">11</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>demo._bar<br><span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>结果是：外界都可以直接访问这两个属性。</p><p>但实际上，二者是有区别的。PEP 8 有提及，如果一个属性的有单前导下划线，则该属性应该仅供内部访问。</p><p>但这并不是强制性的，不然上面我们也不可能通过 <code>self._bar</code> 访问到 22，但做为一名 Python 程序员最好遵守这一共识。</p><h3 id="3-双前导下划线-var"><a href="#3-双前导下划线-var" class="headerlink" title="3. 双前导下划线 __var"></a>3. 双前导下划线 __var</h3><p>双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。</p><p>这也叫做<strong>名称修饰(name mangling)</strong> - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。</p><p>我知道这听起来很抽象。因此，我组合了一个小小的代码示例来予以说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>:<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>       self.foo = <span class="hljs-number">11</span><br>       self._bar = <span class="hljs-number">22</span><br>       self.__baz = <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>将其进行实例化，然后使用 <code>dir()</code> 函数查看这个对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo = Demo()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(demo)<br>[<span class="hljs-string">&#x27;_Demo__baz&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;_bar&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>]<br></code></pre></td></tr></table></figure><p>不难发现，<code>foo</code> 和 <code>_bar</code> 都很正常，可以使用 <code>demo.属性名</code> 进行访问。</p><p>但 <code>__baz</code> 明显和 <code>foo</code> 、 <code>_bar</code>  不一样，尝试访问后却报了 AttributeError，属性不存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo.__baz<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Demo&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__baz&#x27;</span><br></code></pre></td></tr></table></figure><p>如果你仔细观察，你会看到此对象上有一个名为<code>_Demo__baz</code>的属性。这就是Python解释器所做的名称修饰。它这样做是为了防止变量在子类中被重写。</p><p>如果想访问，那得按照 dir 提示的写法去访问，在 <code>__baz</code> 前面加上 <code>_类名</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo._Demo__baz<br><span class="hljs-number">33</span><br></code></pre></td></tr></table></figure><p>总结可得，使用双下划线开头的属性变量，就是一个私有变量。</p><p>这样的规则在属性上生效，在方法上也同样适用。</p><p>如果一个实例方法，以双下划线开头，那么这个方法就是一个私有的方法，不能由实例对象或者类直接调用。</p><p>必须得通过 <code>实例._类名__方法名</code> 来调用。</p><h3 id="4-总结一下"><a href="#4-总结一下" class="headerlink" title="4. 总结一下"></a>4. 总结一下</h3><p>Python并没有真正的私有化支持，但可用下划线得到伪私有。</p><p> 尽量避免定义以下划线开头的变量。</p><ul><li>私有变量：以双下划线前导的变量，可以使用 <code>实例._类名__变量名</code> 进行访问</li><li>私有方法：以双下划线前导的方法，可以使用 <code>实例._类名__方法名()</code> 进行访问</li></ul><p>私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。对于这些内容我放到了下一节的的封装，请继续往后学习。</p><h2 id="7-4-【基础】类的封装（Encapsulation）"><a href="#7-4-【基础】类的封装（Encapsulation）" class="headerlink" title="7.4 【基础】类的封装（Encapsulation）"></a>7.4 【基础】类的封装（Encapsulation）</h2><p>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现。</p><p>要了解封装，离不开“私有化”，就是将类或者是函数中的某些属性限制在某个区域之内，外部无法直接调用。</p><p>关于什么是 <code>私有化变量和私有化函数</code>，在上一节我已经很详细的讲过啦。</p><p>私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。这就是封装。</p><p>正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。类通过将函数和变量封装在内部，实现了比函数更高一级的封装。</p><p>请看下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>xh = Person(name=<span class="hljs-string">&quot;小红&quot;</span>, age=<span class="hljs-number">27</span>)<br><span class="hljs-keyword">if</span> xh.age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;xh.name&#125;</span>已经是成年人了&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;xh.name&#125;</span>还是未年人&quot;</span>)<br></code></pre></td></tr></table></figure><p>我定义了一个 Person 的类，它有 name 和 age 两个属性。</p><p>如果想判断小明是不是成年人，需要使用 <code>xh.age</code> 来与 18 比较。</p><p>对于很多女生还来说，年龄是非常隐私的。如果不想年龄被人随意就获取，可以在 <code>age</code> 前加两个下划线，将其变成一个私有变量。外界就无法随随便便就知道某个人年龄啦。</p><p>如此一来，想要知道一个人是否是成年人，该怎么办呢？</p><p>这时候，就该 <code>封装</code> 出场啦。</p><p>我可以定义一个用于专门判断一个人是否成年人的函数，对 <code>self.__age</code> 这个属性进行封装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.__age = age<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_adult</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__age &gt;= <span class="hljs-number">18</span><br><br>xh = Person(name=<span class="hljs-string">&quot;小红&quot;</span>, age=<span class="hljs-number">27</span>)<br>xh.is_adult()<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="7-5-【基础】类的继承（Inheritance）"><a href="#7-5-【基础】类的继承（Inheritance）" class="headerlink" title="7.5 【基础】类的继承（Inheritance）"></a>7.5 【基础】类的继承（Inheritance）</h2><p>类的继承，跟人类繁衍的关系相似。</p><p>被继承的类称为基类（也叫做父类），继承而得的类叫派生类（也叫子类），这种关系就像人类的父子关系。</p><p>继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。</p><p>继承的语法结构是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br></code></pre></td></tr></table></figure><h3 id="1-单继承"><a href="#1-单继承" class="headerlink" title="1. 单继承"></a>1. 单继承</h3><p>举个例子：下面的代码中。先是定义了一个 People 类，里面有一个 speak 方法。然后再定义一个 Student 类，并继承自 People 类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 父类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, weight</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> 说: 我<span class="hljs-subst">&#123;self.age&#125;</span>岁。&quot;</span>)<br><br><span class="hljs-comment">## 单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, weight, grade</span>):<br>        <span class="hljs-comment"># 调用父类的实例化方法</span><br>        People.__init__(self, name, age, weight)<br>        self.grade = grade<br></code></pre></td></tr></table></figure><p>由于继承的机制，Student 实例会拥有 People 类所有属性和方法，比如下边我可以直接调用 People 类的 speak 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>xm = Student(name=<span class="hljs-string">&quot;小明&quot;</span>, age=<span class="hljs-number">10</span>, weight=<span class="hljs-number">50</span>, grade=<span class="hljs-string">&quot;三年级&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>xm.speak()<br>小明 说: 我 <span class="hljs-number">10</span> 岁。<br></code></pre></td></tr></table></figure><p>你如果不想使用父类的方法，你可以重写它以覆盖父类的 <code>speak</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 单继承示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, weight, grade</span>):<br>        <span class="hljs-comment"># 调用父类的实例化方法</span><br>        People.__init__(self, name, age, weight)<br>        self.grade = grade<br><br>    <span class="hljs-comment"># 重写父类的speak方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> 说: 我<span class="hljs-subst">&#123;self.age&#125;</span>岁了，我在读<span class="hljs-subst">&#123;self.grade&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时，再调用的话，就会调用自己的方法了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>xm = Student(name=<span class="hljs-string">&quot;小明&quot;</span>, age=<span class="hljs-number">10</span>, weight=<span class="hljs-number">50</span>, grade=<span class="hljs-string">&quot;三年级&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>xm.speak()<br>小明 说: 我<span class="hljs-number">10</span>岁了，我在读三年级<br></code></pre></td></tr></table></figure><h3 id="2-多继承"><a href="#2-多继承" class="headerlink" title="2. 多继承"></a>2. 多继承</h3><p>Python 还支持多继承，可以继承自多个类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(父类<span class="hljs-number">1</span>, 父类<span class="hljs-number">2</span>, 父类<span class="hljs-number">3.</span>..):<br></code></pre></td></tr></table></figure><p>多继承的话，情况会比单继承复杂得多。</p><p>假设多个父类都有一个 foo 方法，并且子类没有重写 foo 方法，那么 子类 的实例在调用 foo 方法时，应该使用哪个父类的 foo 方法呢？</p><p>关于这一点，只要简单的做个验证就行啦。</p><p>有如下代码，定义了 7 个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">D</span>):<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">C</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am B&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span>:<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>(<span class="hljs-title class_ inherited__">G</span>):<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>(<span class="hljs-title class_ inherited__">F</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am E&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(B, E):<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>它们的继承关系是</p><p><img src="http://image.iswbm.com/image-20201213150058921.png"></p><p>运行后的结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.show()<br>i am B<br></code></pre></td></tr></table></figure><p>在类A中，没有show()这个方法，于是它只能去它的父类里查找，它首先在B类中找，结果找到了，于是直接执行B类的show()方法。可见，在A的定义中，继承参数的书写有先后顺序，写在前面的被优先继承。</p><h3 id="3-继承顺序"><a href="#3-继承顺序" class="headerlink" title="3. 继承顺序"></a>3. 继承顺序</h3><p>那如果B没有show方法，而是D有呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am D&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">D</span>):<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">C</span>):<span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">G</span>:<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>(<span class="hljs-title class_ inherited__">G</span>):<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>(<span class="hljs-title class_ inherited__">F</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am E&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(B, E):<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>执行结果是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = A()<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.show()<br>i am D<br></code></pre></td></tr></table></figure><p>由此可见，多继承的顺序使用的是从左向右再深度优先的原则。</p><p><img src="http://image.iswbm.com/image-20201213151434342.png"></p><h3 id="4-MRO-算法"><a href="#4-MRO-算法" class="headerlink" title="4. MRO 算法"></a>4. MRO 算法</h3><p>上面的继承案例是只是非常简单的一种场景，在实际应用中，会远比这个来得复杂。</p><p>此时如果你单纯的将其理解成</p><ul><li>从左向右</li><li>深度优先</li></ul><p>就会发现很场景下想要理清的方法解析顺序（MRO）是非常难的。</p><p>在这种情况下，你还可以有两种方法：</p><ol><li>使用 <code>__mro__</code> 来查询</li><li>使用 merge算法进行推导</li></ol><h4 id="使用-mro-查询"><a href="#使用-mro-查询" class="headerlink" title="使用 mro 查询"></a>使用 mro 查询</h4><p>比如在下面这个菱形继承中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20201004123106.png"></p><p>可以使用 <code>__mro__</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(D.__mro__)<br></code></pre></td></tr></table></figure><p>或者借助 inspect 模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> inspect<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span> inspect.getmro(D)<br></code></pre></td></tr></table></figure><p>得到的结果都将是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.D&#x27;</span>&gt;, <br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.B&#x27;</span>&gt;, <br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.C&#x27;</span>&gt;, <br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, <br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><h4 id="使用-merge-推导"><a href="#使用-merge-推导" class="headerlink" title="使用 merge 推导"></a>使用 merge 推导</h4><p><img src="http://image.iswbm.com/20201004123115.png"></p><ol><li>检查第一个列表的头元素（如 L[B1] 的头），记作 H。</li><li>若 H 未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作 H，继续该步骤。</li><li>重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系，Python 会抛出异常。</li></ol><p>你可以在草稿纸上，参照上面的merge算法，写出如下过程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">L<span class="hljs-selector-attr">[object]</span> = <span class="hljs-selector-attr">[object]</span><br>L<span class="hljs-selector-attr">[D]</span> = <span class="hljs-selector-attr">[D, object]</span><br>L<span class="hljs-selector-attr">[E]</span> = <span class="hljs-selector-attr">[E, object]</span><br>L<span class="hljs-selector-attr">[F]</span> = <span class="hljs-selector-attr">[F, object]</span><br>L<span class="hljs-selector-attr">[B]</span> = <span class="hljs-selector-attr">[B, D, E, object]</span><br>L<span class="hljs-selector-attr">[C]</span> = <span class="hljs-selector-attr">[C, D, F, object]</span><br>L<span class="hljs-selector-attr">[A]</span> = <span class="hljs-selector-attr">[A]</span> + <span class="hljs-built_in">merge</span>(L<span class="hljs-selector-attr">[B]</span>, L<span class="hljs-selector-attr">[C]</span>, <span class="hljs-selector-attr">[B]</span>, <span class="hljs-selector-attr">[C]</span>)<br>     = <span class="hljs-selector-attr">[A]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[B, D, E, object]</span>, <span class="hljs-selector-attr">[C, D, F, object]</span>, <span class="hljs-selector-attr">[B]</span>, <span class="hljs-selector-attr">[C]</span>)<br>     = <span class="hljs-selector-attr">[A, B]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[D, E, object]</span>, <span class="hljs-selector-attr">[C, D, F, object]</span>, <span class="hljs-selector-attr">[C]</span>)<br>     = <span class="hljs-selector-attr">[A, B, C]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[D, E, object]</span>, <span class="hljs-selector-attr">[D, F, object]</span>)<br>     = <span class="hljs-selector-attr">[A, B, C, D]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[E, object]</span>, <span class="hljs-selector-attr">[F, object]</span>)<br>     = <span class="hljs-selector-attr">[A, B, C, D, E]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[object]</span>, <span class="hljs-selector-attr">[F, object]</span>)<br>     = <span class="hljs-selector-attr">[A, B, C, D, E, F]</span> + <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[object]</span>, <span class="hljs-selector-attr">[object]</span>)<br>     = <span class="hljs-selector-attr">[A, B, C, D, E, F, object]</span><br></code></pre></td></tr></table></figure><h3 id="附录：参考文章"><a href="#附录：参考文章" class="headerlink" title="附录：参考文章"></a>附录：参考文章</h3><hr><ul><li><a href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a></li><li><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html">https://www.cnblogs.com/whatisfantasy/p/6046991.html</a></li></ul><h2 id="7-6-【基础】类的多态（Polymorphism）"><a href="#7-6-【基础】类的多态（Polymorphism）" class="headerlink" title="7.6 【基础】类的多态（Polymorphism）"></a>7.6 【基础】类的多态（Polymorphism）</h2><p>多态，是指在同一类型下的不同形态。</p><p>比如下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">American</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, boys&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chinese</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好，老铁&quot;</span>)<br>        <br>p1 = American()<br>p2 = Chinese()<br></code></pre></td></tr></table></figure><p>American 和 Chinese 都继承了 People 类，但他们在 <code>speak()</code> 函数下，却有不同的形态表现。American 说英文，Chinese 说汉语。</p><p>倘若现在有一个 <code>do_speak</code> 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_speak</span>(<span class="hljs-params">people</span>):<br>    people.speak()<br><br>do_speak(p1)<br>do_speak(p2)<br></code></pre></td></tr></table></figure><p>那么无论传入的 American 实例还是 Chinese 实例，只要他有实现 speak 方法都可以。</p><p>这就是 Python 中非常有名鸭子类型：<strong>一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</strong></p><p>套入刚刚的代码实例中，就是一个对象，只要有 speak 方法，那么他就是一个 <code>do_speak</code> 方法所需要的 people 对象。</p><p>可能有人会觉得，这些内容很自然啊，没什么不好理解，不觉得多态有什么特殊，Python就是这样啊！</p><p>如果你学过 JAVA 这一类强类型静态语言，就不会这么觉得了，对于JAVA，必须指定函数参数的数据类型，只能传递对应参数类型或其子类型的参数，不能传递其它类型的参数，show_kind()函数只能接收animal、dog、cat和pig类型，而不能接收job类型。就算接收dog、cat和pig类型，也是通过面向对象的多态机制实现的。## 7.7 【基础】类的 property 属性</p><p>在之前的学习中，对象的属性，我们都是通过把变量值赋值给对象本身来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-keyword">pass</span><br>...<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&quot;王炳明&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = <span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p>直接赋值会存在一个问题，就是无法对属性值进行合法性较验，比如我给 age 赋值的是负数，在业务上这种数据是不合法的。但上面那种写法是无法检查出来的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = -<span class="hljs-number">27</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age<br>-<span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p>为了实现属性的合法性校验，Python 引入的 property 属性。</p><p>请看下面这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._age<br><br><span class="hljs-meta">    @age.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">150</span>:<br>            self._age = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 150]&quot;</span>)<br></code></pre></td></tr></table></figure><p>此时再对 age 属性进行赋值就会对 value 的值进行合法性检查，小于 0 或者 大于 150 的都是不合法数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = -<span class="hljs-number">27</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">10</span>, <span class="hljs-keyword">in</span> age<br>ValueError: Valid value must be <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>, <span class="hljs-number">150</span>]<br></code></pre></td></tr></table></figure><p>由此我们知道了 <code>property</code> ，其实是 Python 中一个内置的装饰器，它可以在新式类中把一个函数 <code>改造</code> 成属性。</p><ul><li><p>当你读取属性值时，会进入被 <code>property</code> 装饰的函数。</p></li><li><p>当你对属性进行赋值时，会进入被 <code>@xx.setter</code> 装饰的函数。</p></li><li><p>两个装饰器，一定是 <code>@property</code> 在前面，而 <code>@xx.setter</code> 在后</p></li></ul><h2 id="7-8-【进阶】类的-Mixin-设计模式"><a href="#7-8-【进阶】类的-Mixin-设计模式" class="headerlink" title="7.8 【进阶】类的 Mixin 设计模式"></a>7.8 【进阶】类的 Mixin 设计模式</h2><p>类的单继承，是开发者再熟悉不过的继承方式，写起来也毫不费力。</p><p>而多继承呢，见得很多，写得很少。在很多的项目代码里，你还会见到一种很奇怪的类，他们有一个命名上的共同点，就是在类名的结尾，都喜欢用 Mixin。</p><h3 id="1-认识Mixin模式"><a href="#1-认识Mixin模式" class="headerlink" title="1. 认识Mixin模式"></a>1. 认识Mixin模式</h3><p>那我们今天就来讲讲这个 Mixin，对于这个Mixin，如何理解？它其实是一种设计模式，如果开发者之间没有产生这样一种设计模式的共识，那么设计模式将不复存在。</p><p>为了让大家，对这个 Mixin 有一个更直观的理解，我摘录了网上一段说明。</p><p>继承是一个”is-a”关系。比如轿车类继承交通工具类，因为轿车是一个(“is-a”)交通工具。一个物品不可能是多种不同的东西，因此就不应该存在多重继承。不过有没有这种情况，一个类的确是需要继承多个类呢？</p><p>答案是有，我们还是拿交通工具来举例子，民航飞机是一种交通工具，对于土豪们来说直升机也是一种交通工具。对于这两种交通工具，它们都有一个功能是飞行，但是轿车没有。所以，我们不可能将飞行功能写在交通工具这个父类中。但是如果民航飞机和直升机都各自写自己的飞行方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会出现许多重复代码）。</p><p>怎么办，那就只好让这两种飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么破？</p><p>这时候 Mixin 就闪亮登场了。飞行只是飞机做为交通工具的一种（增强）属性，我们可以为这个飞行的功能单独定义一个（增强）类，称之为 Mixin 类。这个类，是做为增强功能，添加到子类中的。为了让其他开发者，一看就知道这是个 Mixin 类，一般都要求开发者遵循规范，在类名末尾加上 Mixin 。</p><p>举个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlaneMixin</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I am flying&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>(Vehicle, PlaneMixin):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>使用Mixin类实现多重继承要遵循以下几个规范</p><ul><li>责任明确：必须表示某一种功能，而不是某个物品；</li><li>功能单一：若有多个功能，那就写多个Mixin类；</li><li>绝对独立：不能依赖于子类的实现；子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。</li></ul><h3 id="2-不使用Mixin的弊端"><a href="#2-不使用Mixin的弊端" class="headerlink" title="2. 不使用Mixin的弊端"></a>2. 不使用Mixin的弊端</h3><p>你肯定会问，不使用 Mixin 行吗？</p><p>当然可以，这个问题就像在问，我不遵循 PEP8 代码规范行吗？完全没问题，只是不推荐那样做。</p><p>那么到底有什么理由，让我们要去用到 Mixin 设计模式呢？</p><p>不使用的话，大概有如下三点弊端：</p><p><strong>1、结构复杂</strong></p><p>单继承中一个类的父类是什么，父类的父类是什么非常明确。多继承一个类有多个父类，父类又有多个父类，继承关系复杂。</p><p><strong>2、优先顺序模糊</strong></p><p>多个父类中有同名方法，在开发过程中，容易造成思维混乱，子类不知道继承哪个父类，会增加开发难度。关于子类的继承顺序，有一个比较复杂的 C3 算法，如果你还不清楚，可以点击我的另一篇文章 ，了解一下。</p><p><strong>3、功能冲突</strong></p><p>多重继承有多个父类，但是子类只能继承一个，对于同名方法，就会导致另一个父类的方法失效。</p><h2 id="7-9-【进阶】类的魔术方法（超全整理）"><a href="#7-9-【进阶】类的魔术方法（超全整理）" class="headerlink" title="7.9 【进阶】类的魔术方法（超全整理）"></a>7.9 【进阶】类的魔术方法（超全整理）</h2><p>什么是魔法方法呢？它们在面向对象的Python的处处皆是。</p><p>它们是一些可以让你对类添加<code>魔法</code>的特殊方法。它们经常是两个下划线包围来命名的（比如 <code>__init__</code> ， <code>__lt__</code> ）。</p><p>本文整理自：<a href="https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id28"> (译)Python魔法方法指南</a>，内容非常多，不适合新手全文阅读，如果你是跟着教程从头看到这的，建议先跳过本文内容。而如果你是一名有经验的 Python 老手，可以考虑全文通读，会加深你对 Python 魔法方法的理解。</p><h3 id="01-构造方法"><a href="#01-构造方法" class="headerlink" title="01. 构造方法"></a>01. 构造方法</h3><p>我们最为熟知的基本的魔法方法就是 <code>__init__</code> ，我们可以用它来指明一个对象初始化的行为。然而，当我们调用 x &#x3D; SomeClass() 的时候， <code>__init__</code> 并不是第一个被调用的方法。事实上，第一个被调用的是 <code>__new__</code> ，这个 方法才真正地创建了实例。当这个对象的生命周期结束的时候， <code>__del__</code> 会被调用。让我们近一步理解这三个方法：</p><ul><li><p><code>__new__(cls,[…)</code></p><p><code>__new__</code> 是对象实例化时第一个调用的方法，它只取下 cls 参数，并把其他参数传给 <code>__init__</code> 。<code>__new__</code> 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。我不打算深入讨论 <code>__new__</code> ，因为它并不是很有用， Python文档 中 有详细的说明。</p></li><li><p><code>__init__(self,[…])</code></p><p>类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x &#x3D; SomeClass(10, ‘foo’) ， <code>__init__</code> 就会接到参数 10 和 ‘foo’ 。<code>__init__</code> 在Python的类定义中用的最多。</p></li><li><p><code>__del__(self)</code></p><p><code>__new__</code> 和 <code>__init__</code> 是对象的构造器， <code>__del__</code> 是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于 x.<code>__del__()</code>。而是定义了当对象被垃圾回收时的行为。当对象需要在销毁时做一些处理的时候这个方法很有用，比如 socket 对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候， <code>__del__</code> 并不会 执行。所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p></li></ul><p>这里有个 <code>__init__</code> 和 <code>__del__</code> 的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os.path <span class="hljs-keyword">import</span> join<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileObject</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;文件对象的装饰类，用来保证文件被删除时能够正确关闭。&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filepath=<span class="hljs-string">&#x27;~&#x27;</span>, filename=<span class="hljs-string">&#x27;sample.txt&#x27;</span></span>):<br>        <span class="hljs-comment"># 使用读写模式打开filepath中的filename文件</span><br>        self.file = <span class="hljs-built_in">open</span>(join(filepath, filename), <span class="hljs-string">&#x27;r+&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        self.file.close()<br>        <span class="hljs-keyword">del</span> self.file<br></code></pre></td></tr></table></figure><h3 id="02-操作符"><a href="#02-操作符" class="headerlink" title="02. 操作符"></a>02. 操作符</h3><p>使用Python魔法方法的一个巨大优势就是可以构建一个拥有Python内置类型行为的对象。这意味着你可以避免使用非标准的、丑陋的方式来表达简单的操作。在一些语言中，这样做很常见:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> instance.equals(other_instance):<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>你当然可以在Python也这么做，但是这样做让代码变得冗长而混乱。不同的类库可能对同一种比较操作采用不同的方法名称，这让使用者需要做很多没有必要的工作。运用魔法方法的魔力，我们可以定义方法 <code>__eq__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> instance == other_instance:<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>这是魔法力量的一部分，这样我们就可以创建一个像内建类型那样的对象了！</p><h4 id="2-1-比较操作符"><a href="#2-1-比较操作符" class="headerlink" title="2.1 比较操作符"></a>2.1 比较操作符</h4><p>Python包含了一系列的魔法方法，用于实现对象之间直接比较，而不需要采用方法调用。同样也可以重载Python默认的比较方法，改变它们的行为。下面是这些方法的列表：</p><ul><li><p><code>__cmp__(self, other)</code></p><p><code>__cmp__</code> 是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（&lt;,&#x3D;&#x3D;,!&#x3D;,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。<code>__cmp__</code> 应该在 self &lt; other 时返回一个负整数，在 self &#x3D;&#x3D; other 时返回0，在 self &gt; other 时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。如果你需要实现所有的比较形式，而且它们的判断标准类似，那么 <code>__cmp__</code> 是一个很好的方法，可以减少代码重复，让代码更简洁。</p></li><li><p><code>__eq__(self, other)</code></p><p>定义等于操作符(&#x3D;&#x3D;)的行为。</p></li><li><p><code>__ne__(self, other)</code></p><p>定义不等于操作符(!&#x3D;)的行为。</p></li><li><p><code>__lt__(self, other)</code></p><p>定义小于操作符(&lt;)的行为。</p></li><li><p><code>__gt__(self, other)</code></p><p>定义大于操作符(&gt;)的行为。</p></li><li><p><code>__le__(self, other)</code></p><p>定义小于等于操作符(&lt;)的行为。</p></li><li><p><code>__ge__(self, other)</code></p><p>定义大于等于操作符(&gt;)的行为。</p></li></ul><p>举个例子，假如我们想用一个类来存储单词。我们可能想按照字典序（字母顺序）来比较单词，字符串的默认比较行为就是这样。我们可能也想按照其他规则来比较字符串，像是长度，或者音节的数量。在这个例子中，我们使用长度作为比较标准，下面是一种实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Word</span>(<span class="hljs-title class_ inherited__">str</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;单词类，按照单词长度来定义比较行为&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, word</span>):<br>        <span class="hljs-comment"># 注意，我们只能使用 `__new__` ，因为str是不可变类型</span><br>        <span class="hljs-comment"># 所以我们必须提前初始化它（在实例创建时）</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">in</span> word:<br>            <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Value contains spaces. Truncating to first space.&quot;</span><br>            word = word[:word.index(<span class="hljs-string">&#x27; &#x27;</span>)]<br>            <span class="hljs-comment"># Word现在包含第一个空格前的所有字母</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.__new__(cls, word)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__gt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) &gt; <span class="hljs-built_in">len</span>(other)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) &lt; <span class="hljs-built_in">len</span>(other)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__ge__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) &gt;= <span class="hljs-built_in">len</span>(other)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) &lt;= <span class="hljs-built_in">len</span>(other)<br></code></pre></td></tr></table></figure><p>现在我们可以创建两个 Word 对象（ Word(‘foo’) 和 Word(‘bar’))然后根据长度来比较它们。注意我们没有定义 <code>__eq__</code> 和 <code>__ne__</code> ，这是因为有时候它们会导致奇怪的结果（很明显， Word(‘foo’) &#x3D;&#x3D; Word(‘bar’) 得到的结果会是true）。根据长度测试是否相等毫无意义，所以我们使用 str 的实现来比较相等。</p><p>从上面可以看到，不需要实现所有的比较魔法方法，就可以使用丰富的比较操作。标准库还在 functools 模块中提供了一个类装饰器，只要我们定义 <code>__eq__</code> 和另外一个操作符（ <code>__gt__</code>, <code>__lt__</code> 等），它就可以帮我们实现比较方法。这个特性只在 Python 2.7 中可用。当它可用时，它能帮助我们节省大量的时间和精力。要使用它，只需要它 @total_ordering 放在类的定义之上就可以了</p><h4 id="2-2-数值操作符"><a href="#2-2-数值操作符" class="headerlink" title="2.2 数值操作符"></a>2.2 数值操作符</h4><p>就像你可以使用比较操作符来比较类的实例，你也可以定义数值操作符的行为。固定好你的安全带，这样的操作符真的有很多。看在组织的份上，我把它们分成了五类：一元操作符，常见算数操作符，反射算数操作符（后面会涉及更多），增强赋值操作符，和类型转换操作符。</p><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>一元操作符只有一个操作符。</p><ul><li><p><code>__pos__(self)</code></p><p>实现取正操作，例如 +some_object。</p></li><li><p><code>__neg_(self)</code></p><p>实现取负操作，例如 -some_object。</p></li><li><p><code>__abs__(self)</code></p><p>实现内建绝对值函数 abs() 操作。</p></li><li><p><code>__invert__(self)</code></p><p>实现取反操作符 ~。</p></li><li><p><code>__round__(self， n)</code></p><p>实现内建函数 round() ，n 是近似小数点的位数。</p></li><li><p><code>__floor__(self)</code></p><p>实现 math.floor() 函数，即向下取整。</p></li><li><p><code>__ceil__(self)</code></p><p>实现 math.ceil() 函数，即向上取整。</p></li><li><p><code>__trunc__(self)</code></p><p>实现 math.trunc() 函数，即截断整数。</p></li></ul><h4 id="常见算数操作符"><a href="#常见算数操作符" class="headerlink" title="常见算数操作符"></a>常见算数操作符</h4><p>现在，我们来看看常见的二元操作符（和一些函数），像+，-，*之类的，它们很容易从字面意思理解。</p><ul><li><p><code>__add__(self, other)</code></p><p>实现加法操作。</p></li><li><p><code>__sub__(self, other)</code></p><p>实现减法操作。</p></li><li><p><code>__mul__(self, other)</code></p><p>实现乘法操作。</p></li><li><p><code>__floordiv__(self, other)</code></p><p>实现使用 &#x2F;&#x2F; 操作符的整数除法。</p></li><li><p><code>__div__(self, other)</code></p><p>实现使用 &#x2F; 操作符的除法。</p></li><li><p><code>__truediv__(self, other)</code></p><p>实现 <em>true</em> 除法，这个函数只有使用 <code>from __future__ import division</code> 时才有作用。</p></li><li><p><code>__mod__(self, other)</code></p><p>实现 % 取余操作。</p></li><li><p><code>__divmod__(self, other)</code></p><p>实现 divmod 内建函数。</p></li><li><p><code>__pow__(self)</code></p><p>实现 ** 操作符。</p></li><li><p><code>__lshift__(self, other)</code></p><p>实现左移位运算符 &lt;&lt; 。</p></li><li><p><code>__rshift__(self, other)</code></p><p>实现右移位运算符 &gt;&gt; 。</p></li><li><p><code>__and__(self, other)</code></p><p>实现按位与运算符 &amp; 。</p></li><li><p><code>__or__(self, other)</code></p><p>实现按位或运算符 | 。</p></li><li><p><code>__xor__(self, other)</code></p><p>实现按位异或运算符 ^ 。</p></li></ul><h4 id="反射算数运算符"><a href="#反射算数运算符" class="headerlink" title="反射算数运算符"></a>反射算数运算符</h4><p>还记得刚才我说会谈到反射运算符吗？可能你会觉得它是什么高端霸气上档次的概念，其实这东西挺简单的，下面举个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">some_object + other<br></code></pre></td></tr></table></figure><p>这是“常见”的加法，反射是一样的意思，只不过是运算符交换了一下位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">other + some_object<br></code></pre></td></tr></table></figure><p>所有反射运算符魔法方法和它们的常见版本做的工作相同，只不过是处理交换连个操作数之后的情况。绝大多数情况下，反射运算和正常顺序产生的结果是相同的，所以很可能你定义 <code>__radd__</code> 时只是调用一下 <code>__add__</code>。注意一点，操作符左侧的对象（也就是上面的 other ）一定不要定义（或者产生 NotImplemented 异常） 操作符的非反射版本。例如，在上面的例子中，只有当 other 没有定义 <code>__add__</code> 时 some_object.<code>__radd__</code> 才会被调用。</p><ul><li><p><code>__radd__(self, other)</code></p><p>实现反射加法操作。</p></li><li><p><code>__rsub__(self, other)</code></p><p>实现反射减法操作。</p></li><li><p><code>__rmul__(self, other)</code></p><p>实现反射乘法操作。</p></li><li><p><code>__rfloordiv__(self, other)</code></p><p>实现使用 &#x2F;&#x2F; 操作符的整数反射除法。</p></li><li><p><code>__rdiv__(self, other)</code></p><p>实现使用 &#x2F; 操作符的反射除法。</p></li><li><p><code>__rtruediv__(self, other)</code></p><p>实现 <em>true</em> 反射除法，这个函数只有使用 <code>from __future__ import division</code> 时才有作用。</p></li><li><p><code>__rmod__(self, other)</code></p><p>实现 % 反射取余操作符。</p></li><li><p><code>__rdivmod__(self, other)</code></p><p>实现调用 divmod(other, self) 时 divmod 内建函数的操作。</p></li><li><p><code>__rpow__(self)</code></p><p>实现 ** 反射操作符。</p></li><li><p><code>__rlshift__(self, other)</code></p><p>实现反射左移位运算符 &lt;&lt; 的作用。</p></li><li><p><code>__rshift__(self, other)</code></p><p>实现反射右移位运算符 &gt;&gt; 的作用。</p></li><li><p><code>__rand__(self, other)</code></p><p>实现反射按位与运算符 &amp; 。</p></li><li><p><code>__ror__(self, other)</code></p><p>实现反射按位或运算符 | 。</p></li><li><p><code>__rxor__(self, other)</code></p><p>实现反射按位异或运算符 ^ 。</p></li></ul><h4 id="增强赋值运算符"><a href="#增强赋值运算符" class="headerlink" title="增强赋值运算符"></a>增强赋值运算符</h4><p>Python同样提供了大量的魔法方法，可以用来自定义增强赋值操作的行为。或许你已经了解增强赋值，它融合了“常见”的操作符和赋值操作，如果你还是没听明白，看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">5</span><br>x += <span class="hljs-number">1</span> <span class="hljs-comment"># 也就是 x = x + 1</span><br></code></pre></td></tr></table></figure><p>这些方法都应该返回左侧操作数应该被赋予的值（例如， a +&#x3D; b <code>__iadd__</code> 也许会返回 a + b ，这个结果会被赋给 a ）,下面是方法列表：</p><ul><li><p><code>__iadd__(self, other)</code></p><p>实现加法赋值操作。</p></li><li><p><code>__isub__(self, other)</code></p><p>实现减法赋值操作。</p></li><li><p><code>__imul__(self, other)</code></p><p>实现乘法赋值操作。</p></li><li><p><code>__ifloordiv__(self, other)</code></p><p>实现使用 &#x2F;&#x2F;&#x3D; 操作符的整数除法赋值操作。</p></li><li><p><code>__idiv__(self, other)</code></p><p>实现使用 &#x2F;&#x3D; 操作符的除法赋值操作。</p></li><li><p><code>__itruediv__(self, other)</code></p><p>实现 <em>true</em> 除法赋值操作，这个函数只有使用<code>from __future__  import division</code> 时才有作用。</p></li><li><p><code>__imod__(self, other)</code></p><p>实现 %&#x3D; 取余赋值操作。</p></li><li><p><code>__ipow__(self)</code></p><p>实现 **&#x3D; 操作。</p></li><li><p><code>__ilshift__(self, other)</code></p><p>实现左移位赋值运算符 &lt;&lt;&#x3D; 。</p></li><li><p><code>__irshift__(self, other)</code></p><p>实现右移位赋值运算符 &gt;&gt;&#x3D; 。</p></li><li><p><code>__iand__(self, other)</code></p><p>实现按位与运算符 &amp;&#x3D; 。</p></li><li><p><code>__ior__(self, other)</code></p><p>实现按位或赋值运算符 | 。</p></li><li><p><code>__ixor__(self, other)</code></p><p>实现按位异或赋值运算符 ^&#x3D; 。</p></li></ul><h4 id="类型转换操作符"><a href="#类型转换操作符" class="headerlink" title="类型转换操作符"></a>类型转换操作符</h4><p>Python也有一系列的魔法方法用于实现类似 float() 的内建类型转换函数的操作。它们是这些：</p><ul><li><p><code>__int__(self)</code></p><p>实现到int的类型转换。</p></li><li><p><code>__long__(self)</code></p><p>实现到long的类型转换。</p></li><li><p><code>__float__(self)</code></p><p>实现到float的类型转换。</p></li><li><p><code>__complex__(self)</code></p><p>实现到complex的类型转换。</p></li><li><p><code>__oct__(self)</code></p><p>实现到八进制数的类型转换。</p></li><li><p><code>__hex__(self)</code></p><p>实现到十六进制数的类型转换。</p></li><li><p><code>__index__(self)</code></p><p>实现当对象用于切片表达式时到一个整数的类型转换。如果你定义了一个可能会用于切片操作的数值类型，你应该定义 <code>__index__</code>。</p></li><li><p><code>__trunc__(self)</code></p><p>当调用 math.trunc(self) 时调用该方法，<code>__trunc__</code>应该返回 self 截取到一个整数类型（通常是long类型）的值。</p></li><li><p><code>__coerce__(self)</code></p><p>该方法用于实现混合模式算数运算，如果不能进行类型转换， <code>__coerce__</code> 应该返回 None 。反之，它应该返回一个二元组 self 和 other ，这两者均已被转换成相同的类型。</p></li></ul><h3 id="03-类的表示"><a href="#03-类的表示" class="headerlink" title="03. 类的表示"></a>03. 类的表示</h3><p>使用字符串来表示类是一个相当有用的特性。在Python中有一些内建方法可以返回类的表示，相对应的，也有一系列魔法方法可以用来自定义在使用这些内建函数时类的行为。</p><ul><li><p><code>__str__(self)</code></p><p>定义对类的实例调用 str() 时的行为。</p></li><li><p><code>__repr__(self)</code></p><p>定义对类的实例调用 repr() 时的行为。str() 和 repr() 最主要的差别在于“目标用户”。repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而 str() 则产生人类可读的输出。</p></li><li><p><code>__unicode__(self)</code></p><p>定义对类的实例调用 unicode() 时的行为。unicode() 和 str() 很像，只是它返回unicode字符串。注意，如果调用者试图调用 str() 而你的类只实现了 <code>__unicode__</code>() ，那么类将不能正常工作。所有你应该总是定义 <code>__str__</code>() ，以防有些人没有闲情雅致来使用unicode。</p></li><li><p><code>__format__(self)</code></p><p>定义当类的实例用于新式字符串格式化时的行为，例如， “Hello, 0:abc!”.format(a) 会导致调用 <code>a.__format__(&quot;abc&quot;)</code> 。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个魔法方法会非常有用。</p></li><li><p><code>__hash__(self)</code></p><p>定义对类的实例调用 hash() 时的行为。它必须返回一个整数，其结果会被用于字典中键的快速比较。同时注意一点，实现这个魔法方法通常也需要实现 <code>__eq__</code> ，并且遵守如下的规则：a &#x3D;&#x3D; b 意味着 hash(a) &#x3D;&#x3D; hash(b)。</p></li><li><p><code>__nonzero__(self)</code></p><p>定义对类的实例调用 bool() 时的行为，根据你自己对类的设计，针对不同的实例，这个魔法方法应该相应地返回True或False。</p></li><li><p><code>__dir__(self)</code></p><p>定义对类的实例调用 dir() 时的行为，这个方法应该向调用者返回一个属性列表。一般来说，没必要自己实现 <code>__dir__</code> 。但是如果你重定义了 <code>__getattr__</code> 或者 <code>__getattribute__</code> （下个部分会介绍），乃至使用动态生成的属性，以实现类的交互式使用，那么这个魔法方法是必不可少的。</p></li></ul><p>到这里，我们基本上已经结束了魔法方法指南中无聊并且例子匮乏的部分。既然我们已经介绍了较为基础的魔法方法，是时候涉及更高级的内容了。</p><h3 id="04-访问控制"><a href="#04-访问控制" class="headerlink" title="04. 访问控制"></a>04. 访问控制</h3><p>很多从其他语言转向Python的人都抱怨Python的类缺少真正意义上的封装（即没办法定义私有属性然后使用公有的getter和setter）。然而事实并非如此。实际上Python不是通过显式定义的字段和方法修改器，而是通过魔法方法实现了一系列的封装。</p><ul><li><code>__getattr__(self, name)</code></li></ul><p>当用户试图访问一个根本不存在（或者暂时不存在）的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引，使用废弃属性时给出警告（如果你愿意，仍然可以计算并且返回该属性），以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用，所以这不能算是一个真正的封装的办法。</p><ul><li><code>__setattr__(self, name, value)</code></li></ul><p>和 <code>__getattr__</code> 不同， <code>__setattr__</code> 可以用于真正意义上的封装。它允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。然后，一定要小心使用 <code>__setattr__</code> ，这个列表最后的例子中会有所展示。</p><ul><li><code>__delattr__(self, name)</code></li></ul><p>这个魔法方法和 <code>__setattr__</code>几乎相同，只不过它是用于处理删除属性时的行为。和 <code>_setattr__</code> 一样，使用它时也需要多加小心，防止产生无限递归（在 <code>__delattr__</code> 的实现中调用 del self.name 会导致无限递归）。</p><ul><li><code>__getattribute__(self, name)</code></li></ul><p><code>__getattribute__</code> 看起来和上面那些方法很合得来，但是最好不要使用它。<code>__getattribute__</code> 只能用于新式类。在最新版的Python中所有的类都是新式类，在老版Python中你可以通过继承 object 来创建新式类。<code>__getattribute__</code> 允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题（通过调用基类的 <code>__getattribute__</code> 来避免）。<code>__getattribute__</code> 基本上可以替代 <code>__getattr__</code> 。只有当它被实现，并且显式地被调用，或者产生 AttributeError 时它才被使用。这个魔法方法可以被使用（毕竟，选择权在你自己），我不推荐你使用它，因为它的使用范围相对有限（通常我们想要在赋值时进行特殊操作，而不是取值时），而且实现这个方法很容易出现Bug。</p><p>自定义这些控制属性访问的魔法方法很容易导致问题，考虑下面这个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name. value</span>):<br>    self.name = value<br>    <span class="hljs-comment"># 因为每次属性幅值都要调用 __setattr__()，所以这里的实现会导致递归</span><br>    <span class="hljs-comment"># 这里的调用实际上是 self.__setattr(&#x27;name&#x27;, value)。因为这个方法一直</span><br>    <span class="hljs-comment"># 在调用自己，因此递归将持续进行，直到程序崩溃</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):<br>    self.__dict__[name] = value <span class="hljs-comment"># 使用 __dict__ 进行赋值</span><br>    <span class="hljs-comment"># 定义自定义行为</span><br></code></pre></td></tr></table></figure><p>再次重申，Python的魔法方法十分强大，能力越强责任越大，了解如何正确的使用魔法方法更加重要。</p><p>到这里，我们对Python中自定义属性存取控制有了什么样的印象？它并不适合轻度的使用。实际上，它有些过分强大，而且违反直觉。然而它之所以存在，是因为一个更大的原则：Python不指望让杜绝坏事发生，而是想办法让做坏事变得困难。自由是至高无上的权利，你真的可以随心所欲。下面的例子展示了实际应用中某些特殊的属性访问方法（注意我们之所以使用 super 是因为不是所有的类都有 <code>__dict__</code> 属性）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccessCounter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; 一个包含了一个值并且实现了访问计数器的类</span><br><span class="hljs-string">    每次值的变化都会导致计数器自增&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>            <span class="hljs-built_in">super</span>(AccessCounter, self).__setattr__(<span class="hljs-string">&#x27;counter&#x27;</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">super</span>(AccessCounter, self).__setattr__(<span class="hljs-string">&#x27;value&#x27;</span>, val)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, name, value</span>):<br>            <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;value&#x27;</span>:<br>                    <span class="hljs-built_in">super</span>(AccessCounter, self).__setattr_(<span class="hljs-string">&#x27;counter&#x27;</span>, self.counter + <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 使计数器自增变成不可避免</span><br>        <span class="hljs-comment"># 如果你想阻止其他属性的赋值行为</span><br>        <span class="hljs-comment"># 产生 AttributeError(name) 就可以了</span><br>        <span class="hljs-built_in">super</span>(AccessCounter, self).__setattr__(name, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, name</span>):<br>            <span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;value&#x27;</span>:<br>                    <span class="hljs-built_in">super</span>(AccessCounter, self).__<span class="hljs-built_in">setattr</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, self.counter + <span class="hljs-number">1</span>)<br>                    <span class="hljs-built_in">super</span>(AccessCounter, self).__<span class="hljs-built_in">delattr</span>(name)<br></code></pre></td></tr></table></figure><h3 id="05-自定义序列"><a href="#05-自定义序列" class="headerlink" title="05. 自定义序列"></a>05. 自定义序列</h3><p>有许多办法可以让你的Python类表现得像是内建序列类型（字典，元组，列表，字符串等）。这些魔法方式是目前为止我最喜欢的。它们给了你难以置信的控制能力，可以让你的类与一系列的全局函数完美结合。在了解激动人心的内容之前，首先你需要掌握一些预备知识。</p><p>既然讲到创建自己的序列类型，就不得不说一说协议了。协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。</p><p>为什么我们要讲协议？因为在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义 <code>__len__</code> 和 <code>__getitem__</code> (后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义 <code>__setitem__</code> 和 <code>__delitem__</code> 。最后，如果你想让你的对象可以迭代，你需要定义 <code>__iter__</code> ，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 <code>__iter__</code> （返回它自己）和 next 方法。</p><h4 id="5-1-容器背后的魔法方法"><a href="#5-1-容器背后的魔法方法" class="headerlink" title="5.1 容器背后的魔法方法"></a>5.1 容器背后的魔法方法</h4><ul><li><p><code>__len__</code>(self)</p><p>返回容器的长度，可变和不可变类型都需要实现。</p></li><li><p><code>__getitem__</code>(self, key)</p><p>定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。</p></li><li><p><code>__setitem__</code>(self, key)</p><p>定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。</p></li><li><p><code>__iter__</code>(self, key)</p><p>它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 iter() 函数调用，以及在类似 for x in container: 的循环中被调用。迭代器是他们自己的对象，需要定义 <code>__iter__</code> 方法并在其中返回自己。</p></li><li><p><code>__reversed__</code>(self)</p><p>定义了对容器使用 reversed() 内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，</p></li><li><p><code>__contains__</code>(self, item)</p><p><code>__contains__</code> 定义了使用 in 和 not in 进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果 <code>__contains__</code> 没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回 True 。</p></li><li><p><code>__missing__</code>(self ,key)</p><p><code>__missing__</code> 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[“george’] 时就会调用 d.<code>__missing__</code>(“george”) ）。</p></li></ul><h4 id="5-2-一个例子"><a href="#5-2-一个例子" class="headerlink" title="5.2 一个例子"></a>5.2 一个例子</h4><p>让我们来看一个实现了一些函数式结构的列表，可能在其他语言中这种结构更常见（例如Haskell）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FunctionalList</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;一个列表的封装类，实现了一些额外的函数式</span><br><span class="hljs-string">    方法，例如head, tail, init, last, drop和take。&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, values=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> values <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.values = []<br>        <span class="hljs-keyword">else</span>:<br>            self.values = values<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.values)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-comment"># 如果键的类型或值不合法，列表会返回异常</span><br>        <span class="hljs-keyword">return</span> self.values[key]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        self.values[key] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">del</span> self.values[key]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.values)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reversed__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reversed</span>(self.values)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, value</span>):<br>        self.values.append(value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">head</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 取得第一个元素</span><br>        <span class="hljs-keyword">return</span> self.values[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tail</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 取得除第一个元素外的所有元素</span><br>        <span class="hljs-keyword">return</span> self.valuse[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 取得除最后一个元素外的所有元素</span><br>        <span class="hljs-keyword">return</span> self.values[:-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">last</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 取得最后一个元素</span><br>        <span class="hljs-keyword">return</span> self.values[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drop</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-comment"># 取得除前n个元素外的所有元素</span><br>        <span class="hljs-keyword">return</span> self.values[n:]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">take</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-comment"># 取得前n个元素</span><br>        <span class="hljs-keyword">return</span> self.values[:n]<br></code></pre></td></tr></table></figure><p>就是这些，一个（微不足道的）有用的例子，向你展示了如何实现自己的序列。当然啦，自定义序列有更大的用处，而且绝大部分都在标准库中实现了（Python是自带电池的，记得吗？），像 Counter , OrderedDict 和 NamedTuple 。</p><h3 id="06-反射"><a href="#06-反射" class="headerlink" title="06. 反射"></a>06. 反射</h3><p>你可以通过定义魔法方法来控制用于反射的内建函数 isinstance 和 issubclass 的行为。下面是对应的魔法方法：</p><ul><li><p><code>__instancecheck__(self, instance)</code></p><p>检查一个实例是否是你定义的类的一个实例（例如 isinstance(instance, class) ）。</p></li><li><p><code>__subclasscheck__(self, subclass)</code></p><p>检查一个类是否是你定义的类的子类（例如 issubclass(subclass, class) ）。</p></li></ul><p>这几个魔法方法的适用范围看起来有些窄，事实也正是如此。我不会在反射魔法方法上花费太多时间，因为相比其他魔法方法它们显得不是很重要。但是它们展示了在Python中进行面向对象编程（或者总体上使用Python进行编程）时很重要的一点：不管做什么事情，都会有一个简单方法，不管它常用不常用。这些魔法方法可能看起来没那么有用，但是当你真正需要用到它们的时候，你会感到很幸运，因为它们还在那儿（也因为你阅读了这本指南！）</p><h3 id="07-抽象基类"><a href="#07-抽象基类" class="headerlink" title="07. 抽象基类"></a>07. 抽象基类</h3><p>请参考 <em><a href="http://docs.python.org/2/library/abc.html">http://docs.python.org/2/library/abc.html</a></em></p><h3 id="08-可调用的对象"><a href="#08-可调用的对象" class="headerlink" title="08. 可调用的对象"></a>08. 可调用的对象</h3><p>你可能已经知道了，在Python中，函数是一等的对象。这意味着它们可以像其他任何对象一样被传递到函数和方法中，这是一个十分强大的特性。</p><p>Python中一个特殊的魔法方法允许你自己类的对象表现得像是函数，然后你就可以“调用”它们，把它们传递到使用函数做参数的函数中，等等等等。这是另一个强大而且方便的特性，让使用Python编程变得更加幸福。</p><ul><li><p><code>__call__(self, [args…])</code></p><p>允许类的一个实例像函数那样被调用。本质上这代表了 x() 和 x.<code>__call__</code>() 是相同的。注意 <code>__call__</code> 可以有多个参数，这代表你可以像定义其他任何函数一样，定义 <code>__call__</code> ，喜欢用多少参数就用多少。</p></li></ul><p><code>__call__</code> 在某些需要经常改变状态的类的实例中显得特别有用。“调用”这个实例来改变它的状态，是一种更加符合直觉，也更加优雅的方法。一个表示平面上实体的类是一个不错的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;表示一个实体的类，调用它的实例</span><br><span class="hljs-string">        可以更新实体的位置&#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size, x, y</span>):<br>                self.x, self.y = x, y<br>                self.size = size<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, x, y</span>):<br>                <span class="hljs-string">&#x27;&#x27;&#x27;改变实体的位置&#x27;&#x27;&#x27;</span><br>                self.x, self.y = x, y<br></code></pre></td></tr></table></figure><h3 id="09-上下文管理器"><a href="#09-上下文管理器" class="headerlink" title="09. 上下文管理器"></a>09. 上下文管理器</h3><p>在Python 2.5中引入了一个全新的关键词，随之而来的是一种新的代码复用方法—— with 声明。上下文管理的概念在Python中并不是全新引入的（之前它作为标准库的一部分实现），直到PEP 343被接受，它才成为一种一级的语言结构。可能你已经见过这种写法了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;foo.txt&#x27;</span>) <span class="hljs-keyword">as</span> bar:<br>    <span class="hljs-comment"># 使用bar进行某些操作</span><br></code></pre></td></tr></table></figure><p>当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个魔法方法所定义：</p><ul><li><p><code>__enter__(self)</code></p><p>定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。注意 <code>__enter__</code> 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。</p></li><li><p><code>__exit__(self, exception_type, exception_value, traceback)</code></p><p>定义当 with 声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行， exception_type , exception_value 和 traceback 会是 None 。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保 <code>__exit__</code> 在完成工作之后返回 True 。如果你不想处理异常，那就让它发生吧。</p></li></ul><p>对一些具有良好定义的且通用的设置和清理行为的类，<code>__enter__</code> 和 <code>__exit__</code>会显得特别有用。你也可以使用这几个方法来创建通用的上下文管理器，用来包装其他对象。下面是一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Closer</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;一个上下文管理器，可以在with语句中</span><br><span class="hljs-string">    使用close()自动关闭对象&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, obj</span>):<br>        self.obj = obj<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self, obj</span>):<br>        <span class="hljs-keyword">return</span> self.obj <span class="hljs-comment"># 绑定到目标</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exception_type, exception_value, traceback</span>):<br>        <span class="hljs-keyword">try</span>:<br>                self.obj.close()<br>        <span class="hljs-keyword">except</span> AttributeError: <span class="hljs-comment"># obj不是可关闭的</span><br>                <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Not closable.&#x27;</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <span class="hljs-comment"># 成功地处理了异常</span><br></code></pre></td></tr></table></figure><p>这是一个 Closer 在实际使用中的例子，使用一个FTP连接来演示（一个可关闭的socket):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> magicmethods <span class="hljs-keyword">import</span> Closer<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> FTP<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Closer(FTP(<span class="hljs-string">&#x27;ftp.somesite.com&#x27;</span>)) <span class="hljs-keyword">as</span> conn:<br><span class="hljs-meta">... </span>        conn.<span class="hljs-built_in">dir</span>()<br>...<br><span class="hljs-comment">## 为了简单，省略了某些输出</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>conn.<span class="hljs-built_in">dir</span>()<br><span class="hljs-comment">## 很长的 AttributeError 信息，不能使用一个已关闭的连接</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Closer(<span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>)) <span class="hljs-keyword">as</span> i:<br><span class="hljs-meta">... </span>        i += <span class="hljs-number">1</span><br>...<br>Not closable.<br><span class="hljs-meta">&gt;&gt;&gt; </span>i<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>看到我们的包装器是如何同时优雅地处理正确和不正确的调用了吗？这就是上下文管理器和魔法方法的力量。Python标准库包含一个 contextlib 模块，里面有一个上下文管理器 contextlib.closing() 基本上和我们的包装器完成的是同样的事情（但是没有包含任何当对象没有close()方法时的处理）。</p><h3 id="10-创建描述符对象"><a href="#10-创建描述符对象" class="headerlink" title="10. 创建描述符对象"></a>10. 创建描述符对象</h3><p>描述符是一个类，当使用取值，赋值和删除 时它可以改变其他对象。描述符不是用来单独使用的，它们需要被一个拥有者类所包含。描述符可以用来创建面向对象数据库，以及创建某些属性之间互相依赖的类。描述符在表现具有不同单位的属性，或者需要计算的属性时显得特别有用（例如表现一个坐标系中的点的类，其中的距离原点的距离这种属性）。</p><p>要想成为一个描述符，一个类必须具有实现 <code>__get__</code> , <code>__set__</code> 和 <code>__delete__</code> 三个方法中至少一个。</p><p>让我们一起来看一看这些魔法方法：</p><ul><li><p><code>__get__(self, instance, owner)</code></p><p>定义当试图取出描述符的值时的行为。instance 是拥有者类的实例， owner 是拥有者类本身。</p></li><li><p><code>__set__(self, instance, owner)</code></p><p>定义当描述符的值改变时的行为。instance 是拥有者类的实例， value 是要赋给描述符的值。</p></li><li><p><code>__delete__(self, instance, value)</code></p><p>定义当描述符的值被删除时的行为。instance 是拥有者类的实例</p></li></ul><p>现在，来看一个描述符的有效应用：单位转换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;米的描述符。&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value=<span class="hljs-number">0.0</span></span>):<br>        self.value = <span class="hljs-built_in">float</span>(value)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.value<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>            self.value = <span class="hljs-built_in">float</span>(value)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foot</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;英尺的描述符。&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>            <span class="hljs-keyword">return</span> instance.meter * <span class="hljs-number">3.2808</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>            instance.meter = <span class="hljs-built_in">float</span>(value) / <span class="hljs-number">3.2808</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用于描述距离的类，包含英尺和米两个描述符。&#x27;&#x27;&#x27;</span><br>    meter = Meter()<br>    foot = Foot()<br></code></pre></td></tr></table></figure><h3 id="11-拷贝"><a href="#11-拷贝" class="headerlink" title="11. 拷贝"></a>11. 拷贝</h3><p>有些时候，特别是处理可变对象时，你可能想拷贝一个对象，改变这个对象而不影响原有的对象。这时就需要用到Python的 copy 模块了。然而（幸运的是），Python模块并不具有感知能力， 因此我们不用担心某天基于Linux的机器人崛起。但是我们的确需要告诉Python如何有效率地拷贝对象。</p><ul><li><p><code>__copy__(self)</code></p><p>定义对类的实例使用 copy.copy() 时的行为。copy.copy() 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。</p></li><li><p><code>__deepcopy__(self, memodict=)</code></p><p>定义对类的实例使用 copy.deepcopy() 时的行为。copy.deepcopy() 返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。memodict 是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 copy.deepcopy() ，使用 memodict 作为第一个参数。</p></li></ul><p>这些魔法方法有什么用武之地呢？像往常一样，当你需要比默认行为更加精确的控制时。例如，如果你想拷贝一个对象，其中存储了一个字典作为缓存（可能会很大），拷贝缓存可能是没有意义的。如果这个缓存可以在内存中被不同实例共享，那么它就应该被共享。</p><h3 id="12-Pickling"><a href="#12-Pickling" class="headerlink" title="12. Pickling"></a>12. Pickling</h3><p>如果你和其他的Python爱好者共事过，很可能你已经听说过Pickling了。Pickling是Python数据结构的序列化过程，当你想存储一个对象稍后再取出读取时，Pickling会显得十分有用。然而它同样也是担忧和混淆的主要来源。</p><p>Pickling是如此的重要，以至于它不仅仅有自己的模块（ pickle ），还有自己的协议和魔法方法。首先，我们先来简要的介绍一下如何pickle已存在的对象类型（如果你已经知道了，大可跳过这部分内容）。</p><h4 id="12-1-小试牛刀"><a href="#12-1-小试牛刀" class="headerlink" title="12.1 小试牛刀"></a>12.1 小试牛刀</h4><p>我们一起来pickle吧。假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用 exec() 或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>data = &#123;<span class="hljs-string">&#x27;foo&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>                <span class="hljs-string">&#x27;bar&#x27;</span>: (<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;world!&#x27;</span>),<br>                <span class="hljs-string">&#x27;baz&#x27;</span>: <span class="hljs-literal">True</span>&#125;<br>jar = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>pickle.dump(data, jar) <span class="hljs-comment"># 将pickle后的数据写入jar文件</span><br>jar.close()<br></code></pre></td></tr></table></figure><p>过了几个小时，我们想把它取出来，我们只需要反pickle它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>pkl_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-comment"># 与pickle后的数据连接</span><br>data = pickle.load(pkl_file) <span class="hljs-comment"># 把它加载进一个变量</span><br><span class="hljs-built_in">print</span> data<br>pkl_file.close()<br></code></pre></td></tr></table></figure><p>将会发生什么？正如你期待的，它就是我们之前的 data 。</p><p>现在，还需要谨慎地说一句：pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。</p><h4 id="12-2-Pickle你的对象"><a href="#12-2-Pickle你的对象" class="headerlink" title="12.2 Pickle你的对象"></a>12.2 Pickle你的对象</h4><p>Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。</p><ul><li><p><code>__getinitargs__(self)</code></p><p>如果你想让你的类在反pickle时调用 <code>__init__</code> ，你可以定义 <code>__getinitargs__</code>(self) ，它会返回一个参数元组，这个元组会传递给 <code>__init__</code> 。注意，这个方法只能用于旧式类。</p></li><li><p><code>__getnewargs__(self)</code></p><p>对新式类来说，你可以通过这个方法改变类在反pickle时传递给 <code>__new__</code> 的参数。这个方法应该返回一个参数元组。</p></li><li><p><code>__getstate__(self)</code></p><p>你可以自定义对象被pickle时被存储的状态，而不使用对象的 <code>__dict__</code> 属性。这个状态在对象被反pickle时会被 <code>__setstate__</code> 使用。</p></li><li><p><code>__setstate__(self)</code></p><p>当一个对象被反pickle时，如果定义了 <code>__setstate__</code> ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 <code>__dict__</code> 属性。这个魔法方法和 <code>__getstate__</code> 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。</p></li><li><p><code>__reduce__(self)</code></p><p>当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。<strong>reduce</strong> 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 <code>__setstate__</code> 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；</p></li><li><p><code>__reduce_ex__(self)</code></p><p><code>__reduce_ex__</code> 的存在是为了兼容性。如果它被定义，在pickle时 <code>__reduce_ex__</code> 会代替 <code>__reduce__</code> 被调用。<code>__reduce__</code> 也可以被定义，用于不支持 <code>__reduce_ex__</code> 的旧版pickle的API调用。</p></li></ul><h4 id="12-3-一个例子"><a href="#12-3-一个例子" class="headerlink" title="12.3 一个例子"></a>12.3 一个例子</h4><p>我们的例子是 Slate ，它会记住它的值曾经是什么，以及那些值是什么时候赋给它的。然而 每次被pickle时它都会变成空白，因为当前的值不会被存储:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Slate</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;存储一个字符串和一个变更日志的类</span><br><span class="hljs-string">        每次被pickle都会忘记它当前的值&#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>                self.value = value<br>                self.last_change = time.asctime()<br>                self.history = &#123;&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">self, new_value</span>):<br>                <span class="hljs-comment"># 改变当前值，将上一个值记录到历史</span><br>                self.history[self.last_change] = self.value<br>                self.value = new_value)<br>                self.last_change = time.asctime()<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_change</span>(<span class="hljs-params">self</span>):<br>                <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Changelog for Slate object:&#x27;</span><br>                <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> self.history.items():<br>                        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;%s\t %s&#x27;</span> % (k,v)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>):<br>                <span class="hljs-comment"># 故意不返回self.value或self.last_change</span><br>                <span class="hljs-comment"># 我们想在反pickle时得到一个空白的slate</span><br>                <span class="hljs-keyword">return</span> self.history<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setstate__</span>(<span class="hljs-params">self</span>):<br>                <span class="hljs-comment"># 使self.history = slate，last_change</span><br>                <span class="hljs-comment"># 和value为未定义</span><br>                self.history = state<br>                self.value, self.last_change = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h3 id="13-总结在最后"><a href="#13-总结在最后" class="headerlink" title="13. 总结在最后"></a>13. 总结在最后</h3><p>这本指南的目标是使所有阅读它的人都能有所收获，无论他们有没有使用Python或者进行面向对象编程的经验。如果你刚刚开始学习Python，你会得到宝贵的基础知识，了解如何写出具有丰富特性的，优雅而且易用的类。如果你是中级的Python程序员，你或许能掌握一些新的概念和技巧，以及一些可以减少代码行数的好办法。如果你是专家级别的Python爱好者，你又重新复习了一遍某些可能已经忘掉的知识，也可能顺便了解了一些新技巧。无论你的水平怎样，我希望这趟遨游Python特殊方法的旅行，真的对你产生了魔法般的效果（实在忍不住不说最后这个双关）。<img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="7-10-【进阶】神奇的元类编程（metaclass）"><a href="#7-10-【进阶】神奇的元类编程（metaclass）" class="headerlink" title="7.10 【进阶】神奇的元类编程（metaclass）"></a>7.10 【进阶】神奇的元类编程（metaclass）</h2><h3 id="1-类是如何产生的"><a href="#1-类是如何产生的" class="headerlink" title="1. 类是如何产生的"></a>1. 类是如何产生的</h3><p>类是如何产生？这个问题也许你会觉得很傻。</p><p>实则不然，很多初学者只知道使用继承的表面形式来创建一个类，却不知道其内部真正的创建是由 <code>type</code> 来创建的。</p><p>type？这不是判断对象类型的函数吗？</p><p>是的，type通常用法就是用来判断对象的类型。但除此之外，他最大的用途是用来动态创建类。当Python扫描到class的语法的时候，就会调用type函数进行类的创建。</p><h3 id="2-如何使用type创建类"><a href="#2-如何使用type创建类" class="headerlink" title="2. 如何使用type创建类"></a>2. 如何使用type创建类</h3><p>首先，<code>type()</code> 需要接收三个参数</p><ol><li>类的名称，若不指定，也要传入空字符串：<code>&quot;&quot;</code></li><li>父类，注意以tuple的形式传入，若没有父类也要传入空tuple：<code>()</code>，默认继承object</li><li>绑定的方法或属性，注意以dict的形式传入</li></ol><p>来看个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 准备一个基类（父类）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am people&quot;</span>)<br><br><span class="hljs-comment">## 准备一个方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment">## 使用type来创建User类</span><br>User = <span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;User&quot;</span>, (BaseClass, ), &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;say&quot;</span>:say&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-理解什么是元类"><a href="#3-理解什么是元类" class="headerlink" title="3. 理解什么是元类"></a>3. 理解什么是元类</h3><p>什么是类？可能谁都知道，类就是用来创建对象的「模板」。</p><p>那什么是元类呢？一句话通俗来说，元类就是创建类的「模板」。</p><p>为什么type能用来创建类？因为它本身是一个元类。使用元类创建类，那就合理了。</p><p>type是Python在背后用来创建所有类的元类，我们熟知的类的始祖 <code>object</code> 也是由type创建的。更有甚者，连type自己也是由type自己创建的，这就过份了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">type</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">object</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">int</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>如果要形象的来理解的话，就看下面这三行话。</p><ul><li>str：用来创建字符串对象的类。</li><li>int：是用来创建整数对象的类。</li><li>type：是用来创建类对象的类。</li></ul><p>反过来看</p><ul><li>一个实例的类型，是类</li><li>一个类的类型，是元类</li><li>一个元类的类型，是type</li></ul><p>写个简单的小示例来验证下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaPerson</span>(<span class="hljs-title class_ inherited__">type</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(metaclass=MetaPerson):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">pass</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>Tom = Person()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Tom))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Tom.__class__))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.MetaPerson&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Tom.__class__.__class__))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>下面再来看一个稍微完整的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 注意要从type继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in BaseClass&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(metaclass=BaseClass):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in User&quot;</span>)<br>        self.name = name<br>        <br><span class="hljs-comment">## in BaseClass</span><br><br>user = User(<span class="hljs-string">&quot;wangbm&quot;</span>)<br><span class="hljs-comment">## in User</span><br></code></pre></td></tr></table></figure><p>综上，我们知道了类是元类的实例，所以在创建一个普通类时，其实会走元类的 <code>__new__</code>。</p><p>同时，我们又知道在类里实现了 <code>__call__</code> 就可以让这个类的实例变成可调用。</p><p>所以在我们对普通类进行实例化时，实际是对一个元类的实例（也就是普通类）进行直接调用，所以会走进元类的 <code>__call__</code></p><p>在这里可以借助 「单例的实现」举一个例子，你就清楚了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MetaSingleton</span>(<span class="hljs-title class_ inherited__">type</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cls:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cls.__name__))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====1====&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&quot;_instance&quot;</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====2====&quot;</span>)<br>cls._instance = <span class="hljs-built_in">type</span>.__call__(cls, *args, **kwargs)<br><span class="hljs-keyword">return</span> cls._instance<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(metaclass=MetaSingleton):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kw</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====3====&quot;</span>)<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> kw:<br><span class="hljs-built_in">setattr</span>(self, k, v)<br></code></pre></td></tr></table></figure><p>验证结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u1 = User(<span class="hljs-string">&#x27;wangbm1&#x27;</span>)<br>cls:User<br>====<span class="hljs-number">1</span>====<br>====<span class="hljs-number">2</span>====<br>====<span class="hljs-number">3</span>====<br><span class="hljs-meta">&gt;&gt;&gt; </span>u1.age = <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>u2 = User(<span class="hljs-string">&#x27;wangbm2&#x27;</span>)<br>cls:User<br>====<span class="hljs-number">1</span>====<br><span class="hljs-meta">&gt;&gt;&gt; </span>u2.age<br><span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>u1 <span class="hljs-keyword">is</span> u2<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="4-使用元类的意义"><a href="#4-使用元类的意义" class="headerlink" title="4. 使用元类的意义"></a>4. 使用元类的意义</h3><p>正常情况下，我们都不会使用到元类。但是这并不意味着，它不重要。假如某一天，我们需要写一个框架，很有可能就需要你对元类要有进一步的研究。</p><p>元类有啥用，用我通俗的理解，元类的作用过程：</p><ol><li>拦截类的创建</li><li>拦截下后，进行修改</li><li>修改完后，返回修改后的类</li></ol><p>所以，很明显，为什么要用它呢？不要它会怎样？</p><p>使用元类，是要对类进行定制修改。使用元类来动态生成元类的实例，而99%的开发人员是不需要动态修改类的，因为这应该是框架才需要考虑的事。</p><p>但是，这样说，你一定不会服气，到底元类用来干什么？其实元类的作用就是<code>创建API</code>，一个最典型的应用是 <code>Django ORM</code>。</p><h3 id="5-元类实战：ORM"><a href="#5-元类实战：ORM" class="headerlink" title="5. 元类实战：ORM"></a>5. 元类实战：ORM</h3><p>使用过Django ORM的人都知道，有了ORM，使得我们操作数据库，变得异常简单。</p><p>ORM的一个类(User)，就对应数据库中的一张表。id,name,email,password 就是字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    <span class="hljs-built_in">id</span> = IntField(<span class="hljs-string">&#x27;id&#x27;</span>)<br>    name = StrField(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    email = StrField(<span class="hljs-string">&#x27;email&#x27;</span>)<br>    password = StrField(<span class="hljs-string">&#x27;password&#x27;</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        db_table = <span class="hljs-string">&quot;user&quot;</span><br></code></pre></td></tr></table></figure><p>如果我们要插入一条数据，我们只需这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 实例化成一条记录</span><br>u = User(<span class="hljs-built_in">id</span>=<span class="hljs-number">20180424</span>, name=<span class="hljs-string">&quot;xiaoming&quot;</span>, <br>         email=<span class="hljs-string">&quot;xiaoming@163.com&quot;</span>, password=<span class="hljs-string">&quot;abc123&quot;</span>)<br><br><span class="hljs-comment">## 保存这条记录</span><br>u.save()<br></code></pre></td></tr></table></figure><p>通常用户层面，只需要懂应用，就像上面这样操作就可以了。</p><p>但是今天我并不是来教大家如何使用ORM，我们是用来探究ORM内部究竟是如何实现的。我们也可以自己写一个简易的ORM。</p><p>从上面的<code>User</code>类中，我们看到<code>StrField</code>和<code>IntField</code>，从字段意思上看，我们很容易看出这代表两个字段类型。字段名分别是<code>id</code>,<code>username</code>,<code>email</code>,<code>password</code>。</p><p><code>StrField</code>和<code>IntField</code>在这里的用法，叫做<code>属性描述符</code>。<br>简单来说呢，<code>属性描述符</code>可以实现对属性值的类型，范围等一切做约束，意思就是说变量id只能是int类型，变量name只能是str类型，否则将会抛出异常。</p><p>那如何实现这两个<code>属性描述符</code>呢？请看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numbers<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Field</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntField</span>(<span class="hljs-title class_ inherited__">Field</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        self._value = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self._value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, numbers.Integral):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;int value need&quot;</span>)<br>        self._value = value<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrField</span>(<span class="hljs-title class_ inherited__">Field</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        self._value = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self._value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;string value need&quot;</span>)<br>        self._value = value<br></code></pre></td></tr></table></figure><p>我们看到<code>User</code>类继承自<code>BaseModel</code>，这个<code>BaseModel</code>里，定义了数据库操作的各种方法，譬如我们使用的<code>save</code>函数，也可以放在这里面的。所以我们就可以来写一下这个<code>BaseModel</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span>(metaclass=ModelMetaClass):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *args, **kw</span>):<br>        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> kw.items():<br>            <span class="hljs-comment"># 这里执行赋值操作，会进行数据描述符的__set__逻辑</span><br>            <span class="hljs-built_in">setattr</span>(self, k, v)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__init__()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self</span>):<br>        db_columns=[]<br>        db_values=[]<br>        <span class="hljs-keyword">for</span> column, value <span class="hljs-keyword">in</span> self.fields.items():<br>            db_columns.append(<span class="hljs-built_in">str</span>(column))<br>            db_values.append(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">getattr</span>(self, column)))<br>        sql = <span class="hljs-string">&quot;insert into &#123;table&#125; (&#123;columns&#125;) values(&#123;values&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(<br>                table=self.db_table, columns=<span class="hljs-string">&#x27;,&#x27;</span>.join(db_columns),<br>                values=<span class="hljs-string">&#x27;,&#x27;</span>.join(db_values))<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>从<code>BaseModel</code>类中，save函数里面有几个新变量。</p><ol><li>fields: 存放所有的字段属性</li><li>db_table：表名</li></ol><p>我们思考一下这个<code>u</code>实例的创建过程：</p><p><code>type</code> -&gt; <code>ModelMetaClass</code> -&gt; <code>BaseModel</code> -&gt; <code>User</code> -&gt; <code>u</code></p><p>这里会有几个问题。</p><ul><li>init的参数是User实例时传入的，所以传入的id是int类型，name是str类型。看起来没啥问题，若是这样，我上面的数据描述符就失效了，不能起约束作用。所以我们希望init接收到的id是IntField类型，name是StrField类型。</li><li>同时，我们希望这些字段属性，能够自动归类到fields变量中。因为，做为BaseModel，它可不是专门为User类服务的，它还要兼容各种各样的表。不同的表，表里有不同数量，不同属性的字段，这些都要能自动类别并归类整理到一起。这是一个ORM框架最基本的。</li><li>我们希望对表名有两种选择，一个是User中若指定Meta信息，比如表名，就以此为表名，若未指定就以类名的小写 做为表名。虽然BaseModel可以直接取到User的db_table属性，但是如果在数据库业务逻辑中，加入这段复杂的逻辑，显然是很不优雅的。</li></ul><p>上面这几个问题，其实都可以通过元类的<code>__new__</code>函数来完成。</p><p>下面就来看看，如何用元类来解决这些问题呢？请看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelMetaClass</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;BaseModel&quot;</span>:<br>            <span class="hljs-comment"># 第一次进入__new__是创建BaseModel类，name=&quot;BaseModel&quot;</span><br>            <span class="hljs-comment"># 第二次进入__new__是创建User类及其实例，name=&quot;User&quot;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><br>        <span class="hljs-comment"># 根据属性类型，取出字段</span><br>        fields = &#123;k:v <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> attrs.items() <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v, Field)&#125;<br><br>        <span class="hljs-comment"># 如果User中有指定Meta信息，比如表名，就以此为准</span><br>        <span class="hljs-comment"># 如果没有指定，就默认以 类名的小写 做为表名，比如User类，表名就是user</span><br>        _meta = attrs.get(<span class="hljs-string">&quot;Meta&quot;</span>, <span class="hljs-literal">None</span>)<br>        db_table = name.lower()<br>        <span class="hljs-keyword">if</span> _meta <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            table = <span class="hljs-built_in">getattr</span>(_meta, <span class="hljs-string">&quot;db_table&quot;</span>, <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">if</span> table <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                db_table = table<br><br>        <span class="hljs-comment"># 注意原来由User传递过来的各项参数attrs，最好原模原样的返回，</span><br>        <span class="hljs-comment"># 如果不返回，有可能下面的数据描述符不起作用</span><br>        <span class="hljs-comment"># 除此之外，我们可以往里面添加我们自定义的参数</span><br>        attrs[<span class="hljs-string">&quot;db_table&quot;</span>] = db_table<br>        attrs[<span class="hljs-string">&quot;fields&quot;</span>] = fields<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br></code></pre></td></tr></table></figure><h3 id="6-new-有什么用？"><a href="#6-new-有什么用？" class="headerlink" title="6. _new_ 有什么用？"></a>6. _<em>new</em>_ 有什么用？</h3><p>在没有元类的情况下，每次创建实例，在先进入 <code>__init__</code> 之前都会先进入 <code> __new__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in BaseClass&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in User&quot;</span>)<br>self.name = name<br></code></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>u = User(<span class="hljs-string">&#x27;wangbm&#x27;</span>)<br><span class="hljs-keyword">in</span> BaseClass<br><span class="hljs-keyword">in</span> User<br><span class="hljs-meta">&gt;&gt;&gt; </span>u.name<br><span class="hljs-string">&#x27;wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>在有元类的情况下，每次创建类时，会都先进入 元类的 <code>__new__</code> 方法，如果你要对类进行定制，可以在这时做一些手脚。</p><p>综上，元类的<code>__new__</code>和普通类的不一样：</p><ul><li>元类的<code>__new__</code> 在创建类时就会进入，它可以获取到上层类的一切属性和方法，包括类名，魔法方法。</li><li>而普通类的<code>__new__</code> 在实例化时就会进入，它仅能获取到实例化时外界传入的属性。</li></ul><h3 id="附录：参考文章-1"><a href="#附录：参考文章-1" class="headerlink" title="附录：参考文章"></a>附录：参考文章</h3><ul><li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p09_meta_programming.html">Python Cookbook - 元编程</a></li><li><a href="http://blog.jobbole.com/21351/">深刻理解Python中的元类</a></li></ul><h2 id="7-11-【进阶】深藏不露的描述符（Descriptor）"><a href="#7-11-【进阶】深藏不露的描述符（Descriptor）" class="headerlink" title="7.11 【进阶】深藏不露的描述符（Descriptor）"></a>7.11 【进阶】深藏不露的描述符（Descriptor）</h2><p>在前几节里，有介绍过 property 的用法，property 实现将一系列函数改造成对象属性，并实现参数的访问检查。</p><p>很少有人会去深究这里面的原理究竟是什么？实际上对于大部分开发者而言，只要学会应用即可，无需深入探讨。</p><p>因此本节内容是 Python 的进阶知识点，若你是新手，请跳过此章节，否则会打击你的学习自信心。</p><p>打开天窗说亮话，实际上 property 的内部原理是 <code>描述符 （Descriptor）</code></p><p>本篇都将带你全面的学习描述符，一起来感受 Python 语言的优雅。</p><h4 id="1-为什么要使用描述符？"><a href="#1-为什么要使用描述符？" class="headerlink" title="1. 为什么要使用描述符？"></a>1. 为什么要使用描述符？</h4><p>假想你正在给学校写一个成绩管理系统，并没有太多编码经验的你，可能会这样子写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, math, chinese, english</span>):<br>        self.name = name<br>        self.math = math<br>        self.chinese = chinese<br>        self.english = english<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student: &#123;&#125;, math:&#123;&#125;, chinese: &#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                self.name, self.math, self.chinese, self.english<br>            )<br></code></pre></td></tr></table></figure><p>看起来一切都很合理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>std1 = Student(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">76</span>, <span class="hljs-number">87</span>, <span class="hljs-number">68</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>std1<br>&lt;Student: 小明, math:<span class="hljs-number">76</span>, chinese: <span class="hljs-number">87</span>, english:<span class="hljs-number">68</span>&gt;<br></code></pre></td></tr></table></figure><p>但是程序并不像人那么智能，不会自动根据使用场景判断数据的合法性，如果老师在录入成绩的时候，不小心录入了将成绩录成了负数，或者超过100，程序是无法感知的。</p><p>聪明的你，马上在代码中加入了判断逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, math, chinese, english</span>):<br>        self.name = name<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= math &lt;= <span class="hljs-number">100</span>:<br>            self.math = math<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= chinese &lt;= <span class="hljs-number">100</span>:<br>            self.chinese = chinese<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br>      <br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= chinese &lt;= <span class="hljs-number">100</span>:<br>            self.english = english<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student: &#123;&#125;, math:&#123;&#125;, chinese: &#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                self.name, self.math, self.chinese, self.english<br>            )<br></code></pre></td></tr></table></figure><p>这下程序稍微有点人工智能了，能够自己明辨是非了。</p><p><img src="http://image.iswbm.com/20190425221322.png"></p><p>程序是智能了，但在<code>__init__</code>里有太多的判断逻辑，很影响代码的可读性。巧的是，你刚好学过 Property 特性，可以很好的应用在这里。于是你将代码修改成如下，代码的可读性瞬间提升了不少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, math, chinese, english</span>):<br>        self.name = name<br>        self.math = math<br>        self.chinese = chinese<br>        self.english = english<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._math<br><br><span class="hljs-meta">    @math.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._math = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">chinese</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._chinese<br><br><span class="hljs-meta">    @chinese.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">chinese</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._chinese = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">english</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._english<br><br><span class="hljs-meta">    @english.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">english</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._english = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student: &#123;&#125;, math:&#123;&#125;, chinese: &#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                self.name, self.math, self.chinese, self.english<br>            )<br></code></pre></td></tr></table></figure><p>程序还是一样的人工智能，非常好。</p><p><img src="http://image.iswbm.com/20190425221322.png"></p><p>你以为你写的代码，已经非常优秀，无懈可击了。</p><p>没想到，人外有天，你的主管看了你的代码后，深深地叹了口气：类里的三个属性，math、chinese、english，都使用了 Property 对属性的合法性进行了有效控制。功能上，没有问题，但就是太啰嗦了，三个变量的合法性逻辑都是一样的，只要大于0，小于100 就可以，代码重复率太高了，这里三个成绩还好，但假设还有地理、生物、历史、化学等十几门的成绩呢，这代码简直没法忍。去了解一下 Python 的描述符吧。</p><p>经过主管的指点，你知道了「描述符」这个东西。怀着一颗敬畏之心，你去搜索了下关于 描述符的用法。</p><p>其实也很简单，一个实现了 <code>描述符协议</code> 的类就是一个描述符。</p><p>什么描述符协议：在类里实现了 <code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code> 其中至少一个方法。</p><ul><li><code>__get__</code>： 用于访问属性。它返回属性的值，若属性不存在、不合法等都可以抛出对应的异常。</li><li><code>__set__ </code>：将在属性分配操作中调用。不会返回任何内容。</li><li><code>__delete__ </code>：控制删除操作。不会返回内容。</li></ul><p>对描述符有了大概的了解后，你开始重写上面的方法。</p><p>如前所述，Score 类是一个描述符，当从 Student 的实例访问 math、chinese、english这三个属性的时候，都会经过 Score 类里的三个特殊的方法。这里的 Score 避免了 使用Property 出现大量的代码无法复用的尴尬。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, default=<span class="hljs-number">0</span></span>):<br>        self._score = default<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;Score must be integer&#x27;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Valid value must be in [0, 100]&#x27;</span>)<br><br>        self._score = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self._score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">del</span> self._score<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    math = Score(<span class="hljs-number">0</span>)<br>    chinese = Score(<span class="hljs-number">0</span>)<br>    english = Score(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, math, chinese, english</span>):<br>        self.name = name<br>        self.math = math<br>        self.chinese = chinese<br>        self.english = english<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student: &#123;&#125;, math:&#123;&#125;, chinese: &#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                self.name, self.math, self.chinese, self.english<br>            )<br></code></pre></td></tr></table></figure><p>实现的效果和前面的一样，可以对数据的合法性进行有效控制（字段类型、数值区间等）</p><p><img src="http://image.iswbm.com/20190425221233.png"></p><p>以上，我举了下具体的实例，从最原始的编码风格到 Property ，最后引出描述符。由浅入深，一步一步带你感受到描述符的优雅之处。</p><p>到这里，你需要记住的只有一点，就是描述符给我们带来的编码上的便利，它在实现 <code>保护属性不受修改</code>、<code>属性类型检查</code> 的基本功能，同时有大大提高代码的复用率。</p><h4 id="2-描述符的访问规则"><a href="#2-描述符的访问规则" class="headerlink" title="2. 描述符的访问规则"></a>2. 描述符的访问规则</h4><p>描述符分两种：</p><ul><li>数据描述符：实现了<code>__get__</code> 和 <code>__set__</code> 两种方法的描述符</li><li>非数据描述符：只实现了<code>__get__</code> 一种方法的描述符</li></ul><p>你一定会问，他们有什么区别呢？网上的讲解，我看过几个，很多都把一个简单的东西讲得复杂了。</p><p>其实就一句话，<strong>数据描述器和非数据描述器的区别在于：它们相对于实例的字典的优先级不同</strong>。</p><p>如果实例字典中有与描述符同名的属性，如果描述符是数据描述符，优先使用数据描述符，如果是非数据描述符，优先使用字典中的属性。</p><p>这边还是以上节的成绩管理的例子来说明，方便你理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 数据描述符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataDes</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, default=<span class="hljs-number">0</span></span>):<br>        self._score = default<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        self._score = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;访问数据描述符里的 __get__&quot;</span>)<br>        <span class="hljs-keyword">return</span> self._score<br><br><span class="hljs-comment">## 非数据描述符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoDataDes</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, default=<span class="hljs-number">0</span></span>):<br>        self._score = default<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;访问非数据描述符里的 __get__&quot;</span>)<br>        <span class="hljs-keyword">return</span> self._score<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    math = DataDes(<span class="hljs-number">0</span>)<br>    chinese = NoDataDes(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, math, chinese</span>):<br>        self.name = name<br>        self.math = math<br>        self.chinese = chinese<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;调用 __getattribute__&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(Student, self).__getattribute__(item)<br>     <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student: &#123;&#125;, math:&#123;&#125;, chinese: &#123;&#125;,&gt;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                self.name, self.math, self.chinese)<br></code></pre></td></tr></table></figure><p>需要注意的是，math 是数据描述符，而 chinese 是非数据描述符。从下面的验证中，可以看出，当实例属性和数据描述符同名时，会优先访问数据描述符（如下面的math），而当实例属性和非数据描述符同名时，会优先访问实例属性（<code>__getattribute__</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>std = Student(<span class="hljs-string">&#x27;xm&#x27;</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>std.math<br>调用 __getattribute__<br>访问数据描述符里的 __get__<br><span class="hljs-number">88</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>std.chinese<br>调用 __getattribute__<br><span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>讲完了数据描述符和非数据描述符，我们还需要了解的对象属性的查找规律。</p><p>当我们对一个实例属性进行访问时，Python 会按 <code>obj.__dict__</code> → <code>type(obj).__dict__</code> → <code>type(obj)的父类.__dict__</code> 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。</p><h4 id="3-基于描述符如何实现property"><a href="#3-基于描述符如何实现property" class="headerlink" title="3. 基于描述符如何实现property"></a>3. 基于描述符如何实现property</h4><p>经过上面的讲解，我们已经知道如何定义描述符，且明白了描述符是如何工作的。</p><p>正常人所见过的描述符的用法就是上面提到的那些，我想说的是那只是描述符协议最常见的应用之一，或许你还不知道，其实有很多 Python 的特性的底层实现机制都是基于 <code>描述符协议</code> 的，比如我们熟悉的<code>@property</code> 、<code>@classmethod</code> 、<code>@staticmethod</code> 和 <code>super</code> 等。</p><p>先来说说 <code>property</code> 吧。</p><p>有了前面的基础，我们知道了 property 的基本用法。这里我直接切入主题，从第一篇的例子里精简了一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._math<br><br><span class="hljs-meta">    @math.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._math = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br></code></pre></td></tr></table></figure><p>不防再简单回顾一下它的用法，通过property装饰的函数，如例子中的 math 会变成 Student 实例的属性。而对 math 属性赋值会进入 使用 <code>math.setter</code> 装饰函数的逻辑代码块。</p><p>为什么说 property 底层是基于描述符协议的呢？通过 PyCharm 点击进入 property 的源码，很可惜，只是一份类似文档一样的伪源码，并没有其具体的实现逻辑。</p><p>不过，从这份伪源码的魔法函数结构组成，可以大体知道其实现逻辑。</p><p>这里我自己通过模仿其函数结构，结合「描述符协议」来自己实现类 <code>property</code> 特性。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProperty</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fget=<span class="hljs-literal">None</span>, fset=<span class="hljs-literal">None</span>, fdel=<span class="hljs-literal">None</span>, doc=<span class="hljs-literal">None</span></span>):<br>        self.fget = fget<br>        self.fset = fset<br>        self.fdel = fdel<br>        self.__doc__ = doc<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, obj, objtype=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in __get__&quot;</span>)<br>        <span class="hljs-keyword">if</span> obj <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> self<br>        <span class="hljs-keyword">if</span> self.fget <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> AttributeError<br>        <span class="hljs-keyword">return</span> self.fget(obj)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, obj, value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in __set__&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.fset <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> AttributeError<br>        self.fset(obj, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, obj</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in __delete__&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.fdel <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">raise</span> AttributeError<br>        self.fdel(obj)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getter</span>(<span class="hljs-params">self, fget</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in getter&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(self)(fget, self.fset, self.fdel, self.__doc__)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setter</span>(<span class="hljs-params">self, fset</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in setter&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(self)(self.fget, fset, self.fdel, self.__doc__)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deleter</span>(<span class="hljs-params">self, fdel</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in deleter&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">type</span>(self)(self.fget, self.fset, fdel, self.__doc__)<br></code></pre></td></tr></table></figure><p>然后 Student 类，我们也相应改成如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-comment"># 其实只有这里改变</span><br><span class="hljs-meta">    @TestProperty</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._math<br><br><span class="hljs-meta">    @math.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._math = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Valid value must be in [0, 100]&quot;</span>)<br></code></pre></td></tr></table></figure><p>为了尽量让你少产生一点疑惑，我这里做两点说明：</p><ol><li><p>使用<code>TestProperty</code>装饰后，<code>math</code> 不再是一个函数，而是<code>TestProperty</code> 类的一个实例。所以第二个math函数可以使用 <code>math.setter</code> 来装饰，本质是调用<code>TestProperty.setter</code> 来产生一个新的 <code>TestProperty</code> 实例赋值给第二个<code>math</code>。</p></li><li><p>第一个 <code>math</code> 和第二个 <code>math</code> 是两个不同 <code>TestProperty</code> 实例。但他们都属于同一个描述符类（TestProperty），当对 math 对于赋值时，就会进入 <code>TestProperty.__set__</code>，当对math 进行取值里，就会进入 <code>TestProperty.__get__</code>。仔细一看，其实最终访问的还是Student实例的 <code>_math</code> 属性。</p></li></ol><p>说了这么多，还是运行一下，更加直观一点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 运行后，会直接打印这一行，这是在实例化 TestProperty 并赋值给第二个math</span><br><span class="hljs-keyword">in</span> setter<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>s1.math = <span class="hljs-number">90</span><br><span class="hljs-keyword">in</span> __set__<br><span class="hljs-meta">&gt;&gt;&gt; </span>s1.math<br><span class="hljs-keyword">in</span> __get__<br><span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>对于以上理解 <code>property</code> 的运行原理有困难的同学，请务必参照我上面写的两点说明。如有其他疑问，可以加微信与我进行探讨。</p><h4 id="4-基于描述符如何实现staticmethod"><a href="#4-基于描述符如何实现staticmethod" class="headerlink" title="4. 基于描述符如何实现staticmethod"></a>4. 基于描述符如何实现staticmethod</h4><p>说完了 <code>property</code> ，这里再来讲讲  <code>@classmethod</code> 和 <code>@staticmethod</code> 的实现原理。</p><p>我这里定义了一个类，用了两种方式来实现静态方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment">## 上下两种写法等价</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>    <span class="hljs-comment"># 重点：这就是描述符的体现</span><br>    myfunc = <span class="hljs-built_in">staticmethod</span>(myfunc)<br></code></pre></td></tr></table></figure><p>这两种写法是等价的，就好像在 <code>property</code> 一样，其实以下两种写法也是等价的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@TestProperty</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">math</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> self._math<br>  <br>math = TestProperty(fget=math)<br></code></pre></td></tr></table></figure><p>话题还是转回到 <code>staticmethod</code> 这边来吧。</p><p>由上面的注释，可以看出 <code>staticmethod</code> 其实就相当于一个描述符类，而<code>myfunc</code> 在此刻变成了一个描述符。关于 <code>staticmethod</code> 的实现，你可以参照下面这段我自己写的代码，加以理解。</p><p><img src="http://image.iswbm.com/20190519001930.png"></p><p>调用这个方法可以知道，每调用一次，它都会经过描述符类的 <code>__get__</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Test.myfunc()<br><span class="hljs-keyword">in</span> <span class="hljs-built_in">staticmethod</span> __get__<br>hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>Test().myfunc()<br><span class="hljs-keyword">in</span> <span class="hljs-built_in">staticmethod</span> __get__<br>hello<br></code></pre></td></tr></table></figure><h4 id="5-基于描述符如何实现classmethod"><a href="#5-基于描述符如何实现classmethod" class="headerlink" title="5. 基于描述符如何实现classmethod"></a>5. 基于描述符如何实现classmethod</h4><p>同样的 <code> classmethod</code> 也是一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">classmethod</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, f</span>):<br>        self.f = f<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;in classmethod __get__&quot;</span>)<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">*args</span>):<br>            <span class="hljs-keyword">return</span> self.f(owner, *args)<br>        <span class="hljs-keyword">return</span> newfunc<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>        <br>    <span class="hljs-comment"># 重点：这就是描述符的体现</span><br>    myfunc = <span class="hljs-built_in">classmethod</span>(myfunc)<br></code></pre></td></tr></table></figure><p>验证结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Test.myfunc()<br><span class="hljs-keyword">in</span> <span class="hljs-built_in">classmethod</span> __get__<br>hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>Test().myfunc()<br><span class="hljs-keyword">in</span> <span class="hljs-built_in">classmethod</span> __get__<br>hello<br></code></pre></td></tr></table></figure><p>讲完了 <code>property</code>、<code>staticmethod</code>和<code>classmethod</code> 与 描述符的关系。我想你应该对描述符在 Python 中的应用有了更深的理解。对于 super 的实现原理，就交由你来自己完成。</p><h4 id="6-所有实例共享描述符"><a href="#6-所有实例共享描述符" class="headerlink" title="6. 所有实例共享描述符"></a>6. 所有实例共享描述符</h4><p>通过以上内容的学习，你是不是觉得自己已经对描述符足够了解了呢？</p><p>可在这里，我想说以上的描述符代码都有问题。</p><p>问题在哪里呢？请看下面这个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, default=<span class="hljs-number">0</span></span>):<br>        self._value = default<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self._value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            self._value = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    math = Score(<span class="hljs-number">0</span>)<br>    chinese = Score(<span class="hljs-number">0</span>)<br>    english = Score(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student math:&#123;&#125;, chinese:&#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(self.math, self.chinese, self.english)<br></code></pre></td></tr></table></figure><p>Student 里没有像前面那样写了构造函数，但是关键不在这儿，没写只是因为没必要写。</p><p>然后来看一下会出现什么样的问题呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>std1 = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>std1<br>&lt;Student math:<span class="hljs-number">0</span>, chinese:<span class="hljs-number">0</span>, english:<span class="hljs-number">0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>std1.math = <span class="hljs-number">85</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>std1<br>&lt;Student math:<span class="hljs-number">85</span>, chinese:<span class="hljs-number">0</span>, english:<span class="hljs-number">0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>std2 = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>std2 <span class="hljs-comment"># std2 居然共享了std1 的属性值</span><br>&lt;Student math:<span class="hljs-number">85</span>, chinese:<span class="hljs-number">0</span>, english:<span class="hljs-number">0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>std2.math = <span class="hljs-number">100</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>std1 <span class="hljs-comment"># std2 也会改变std1 的属性值</span><br>&lt;Student math:<span class="hljs-number">100</span>, chinese:<span class="hljs-number">0</span>, english:<span class="hljs-number">0</span>&gt;<br></code></pre></td></tr></table></figure><p>从结果上来看，std2 居然共享了 std1 的属性值，只要其中一个实例的变量发生改变，另一个实例的变量也会跟着改变。</p><p>探其根因，是由于此时 math，chinese，english 三个全部是类变量，导致 std2 和 std1 在访问 math，chinese，english 这三个变量时，其实都是访问类变量。</p><p>问题是不是来了？小明和小强的分数怎么可能是绑定的呢？这很明显与实际业务不符。</p><p>使用描述符给我们制造了便利，却无形中给我们带来了麻烦，难道这也是描述符的特性吗？</p><p>描述符是个很好用的特性，会出现这个问题，是由于我们之前写的描述符代码都是错误的。</p><p>描述符的机制，在我看来，只是抢占了访问顺序，而具体的逻辑却要因地制宜，视情况而定。</p><p>如果要把 math，chinese，english  这三个变量变成实例之间相互隔离的属性，应该这么写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, subject</span>):<br>        self.name = subject<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> instance.__dict__[self.name]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= value &lt;= <span class="hljs-number">100</span>:<br>            instance.__dict__[self.name] = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    math = Score(<span class="hljs-string">&quot;math&quot;</span>)<br>    chinese = Score(<span class="hljs-string">&quot;chinese&quot;</span>)<br>    english = Score(<span class="hljs-string">&quot;english&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, math, chinese, english</span>):<br>        self.math = math<br>        self.chinese = chinese<br>        self.english = english<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;Student math:&#123;&#125;, chinese:&#123;&#125;, english:&#123;&#125;&gt;&quot;</span>.<span class="hljs-built_in">format</span>(self.math, self.chinese, self.english)<br></code></pre></td></tr></table></figure><p>引导程序逻辑进入描述符之后，不管你是获取属性，还是设置属性，都是直接作用于 instance 的。</p><p><img src="http://image.iswbm.com/20200812085823.png"></p><p>这段代码，你可以仔细和前面的对比一下。</p><p>不难看出：</p><ul><li>之前的错误代码，更像是把描述符当做了存储节点。</li><li>之后的正确代码，则是把描述符直接当做代理，本身不存储值。</li></ul><p>以上便是我对描述符的全部分享，希望能对你有所帮助。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html#python">Python描述器引导(翻译)</a></li></ul><h1 id="第八章：包与模块"><a href="#第八章：包与模块" class="headerlink" title="第八章：包与模块"></a>第八章：包与模块</h1><h2 id="8-1-【基础】什么是包、模块和库？"><a href="#8-1-【基础】什么是包、模块和库？" class="headerlink" title="8.1 【基础】什么是包、模块和库？"></a>8.1 【基础】什么是包、模块和库？</h2><p>Python 中除了函数库以外，还有非常多且优秀的第三方库、包、模块。</p><p>那么问题就来了，库、模块和包各是什么意思？</p><p>它们之间有什么区别呢？今天就一起来学习下。</p><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1. 模块"></a>1. 模块</h3><p>以 <code>.py</code> 为后缀的文件，我们称之为 模块，英文名 Module。</p><p>模块让你能够有逻辑地组织你的 Python 代码段，把相关的代码分配到一个模块里能让你的代码更好用，更易懂。</p><p>假设现在有一个名为 <code>demo.py</code> 的文件，文件内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name=<span class="hljs-string">&quot;Python编程时光&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;导入成功&quot;</span>)<br></code></pre></td></tr></table></figure><p>直接使用 import 语句就可以导入，导入之后，就可以使用 <code>模块名.变量名</code> 的方式访问这个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo<br>导入成功<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo.name<br><span class="hljs-string">&#x27;Python编程时光&#x27;</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>在导入模块的时候，有一个非常重要的全局变量需要掌握，那就是  <code>__name__</code> 这个变量。</p><p>现在把 <code>demo.py</code> 的内容改成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ cat demo.py<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__name__ 的值为: &quot;</span> + __name__)<br></code></pre></td></tr></table></figure><ul><li>当模块被直接执行时， <code>__name__</code> 的值为 <code>__main__</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python demo.py<br>__name__ 的值为: __main__<br></code></pre></td></tr></table></figure><ul><li>当模块被导入时， <code>__name__</code>  的值为 模块名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo<br>__name__ 的值为: demo<br></code></pre></td></tr></table></figure><p>当该模块被导入后，会在当前目录下产生一个 叫做 <code>__pycache__</code> 的缓存文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── __pycache__<br>│   └── demo.cpython-39.pyc<br>└── demo.py<br></code></pre></td></tr></table></figure><p>这个文件夹有什么用呢？</p><p>简单来说，当你导入模块的时候，Python解释器会把模块的代码编译成字节码，并放入 <code>__pycache__</code>文件夹中。</p><p>这样以后再次运行的话，如果被调用的模块未发生改变，那就直接跳过编译这一步，直接去<code>__pycache__</code>文件夹中去运行相关的 *.pyc 文件，大大缩短了项目运行前的准备时间。</p><h3 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h3><p>在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个 <code>__init__.py</code> 文件，那我们就称之为包，英文名 Package。</p><p>在后来的 Python 版本（Python 3.3 开始）中，就没有这个要求了，只要是文件夹就可以当做包，我们称之为空间命名包，为做区分，我把上面那种包称之为 传统包。</p><p>考虑到很多人其实并不需要接触到空间命名包，所以我将空间命名包的内容单独放在一节里，为选读章节。</p><p>今天这节里主要讲讲传统包的内容。</p><p>传统包里的  <code>__init__.py</code> 可以为空文件，但一定要有该文件，它是包的标志性文件，在需要情况下可以在里面进行一些包的初始化工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>└── demo<br>    ├── __init__.py<br>    ├── bar.py<br>    └── foo.py<br></code></pre></td></tr></table></figure><p>一个包里可以有多个模块，比如上面的 <code>foo.py</code> 和  <code>bar.py</code> 都属于 demo 模块。</p><p>如果要使用这些模块，就需要这样导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.foo<br>成功导入 foo.py<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.bar<br>成功导入 bar.py<br></code></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> demo <span class="hljs-keyword">import</span> foo<br>成功导入 foo.py<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> demo <span class="hljs-keyword">import</span> bar<br>成功导入 bar.py<br></code></pre></td></tr></table></figure><h3 id="3-库"><a href="#3-库" class="headerlink" title="3. 库"></a>3. 库</h3><p>Python 库是指一定功能的代码集合，通常认为他是一个完整的项目打包。</p><p>库-&gt;包-&gt;模块，是从大到小的层级关系！</p><ul><li>库：一个库可能由多个包和模块组成</li><li>包：一个包可能由多个模块组成</li><li>模块：一堆函数、类、变量的集合</li></ul><h2 id="8-2-【基础】安装第三方包的八种方法"><a href="#8-2-【基础】安装第三方包的八种方法" class="headerlink" title="8.2 【基础】安装第三方包的八种方法"></a>8.2 【基础】安装第三方包的八种方法</h2><h3 id="1-使用-easy-install"><a href="#1-使用-easy-install" class="headerlink" title="1. 使用 easy_install"></a>1. 使用 easy_install</h3><p><code>easy_install</code> 这应该是最古老的包安装方式了，目前基本没有人使用了。下面是 <code>easy_install</code> 的一些安装示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 通过包名，从PyPI寻找最新版本，自动下载、编译、安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">easy_install pkg_name</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 通过包名从指定下载页寻找链接来安装或升级包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">easy_install -f http://pythonpaste.org/package_index.html</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定线上的包地址安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">easy_install http://example.com/path/to/MyPackage-1.2.3.tgz</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 从本地的 .egg 文件安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">easy_install xxx.egg</span><br></code></pre></td></tr></table></figure><h3 id="2-使用-pip-install"><a href="#2-使用-pip-install" class="headerlink" title="2. 使用 pip install"></a>2. 使用 pip install</h3><p>pip 是最主流的包管理方案，使用 <code>pip install xxx</code> 就可以从 PYPI 上搜索并安装 <code>xxx</code> （如果该包存在的话）。</p><p>下面仅列出一些常用的 <code>pip install </code>的安装示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install requests</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --no-index --find-links=/local/wheels pkg</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包的版本为 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg==2.1.2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包必须大于等于 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg&gt;=2.1.2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包必须小于等于 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg&lt;=2.1.2</span><br></code></pre></td></tr></table></figure><p>更多 pip 的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：<a href="https://python.iswbm.com/c08/c08_08.html">8.8 pip 的详细使用指南</a></p><h3 id="3-使用-pipx"><a href="#3-使用-pipx" class="headerlink" title="3. 使用 pipx"></a>3. 使用 pipx</h3><p>pipx 是一个专门用于安装和管理 cli 应用程序的工具，使用它安装的 Python 包会单独安装到一个全新的独有虚拟环境。</p><p>由于它是一个第三方工具，因此在使用它之前，需要先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pip install --user pipx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m userpath append ~/.local/bin</span><br>Success!<br></code></pre></td></tr></table></figure><p>安装就可以使用 pipx 安装cli 工具了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 创建虚拟环境并安装包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx install pkg</span><br></code></pre></td></tr></table></figure><p>更多 pipx 的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：<a href="https://python.iswbm.com/c12/c12_04.html">12.4 pipx 安装程序的使用指南</a></p><h3 id="4-使用-setup-py"><a href="#4-使用-setup-py" class="headerlink" title="4. 使用 setup.py"></a>4. 使用 setup.py</h3><p>如果你有编写 setup.py 文件，可以使用如下命令直接安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 使用源码直接安装</span><br>$ python setup.py install<br></code></pre></td></tr></table></figure><h3 id="5-使用-yum"><a href="#5-使用-yum" class="headerlink" title="5. 使用 yum"></a>5. 使用 yum</h3><p>Python 包在使用 <code>setup.py</code> 构建的时候（具体内容可阅读后面的内容：<a href="https://python.iswbm.com/c08/c08_15.html">8.15 超详细讲解 setup.py 的编写</a>），对于包的发布格式有多种选项，其中有一个选项是 <code>bdist_rpm</code>，以这个选项发布出来的包是 <code>rpm</code> 的包格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 发布 rpm 包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py bdist_rpm</span><br></code></pre></td></tr></table></figure><p>对于<code>rpm</code> 这种格式，你需要使用 <code>yum install xxx</code> 或者 <code>rpm install xxx</code> 来安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用 yum 安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install pkg</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 使用 rpm 安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">rpm -ivh pkg</span><br></code></pre></td></tr></table></figure><h3 id="6-使用-pipenv"><a href="#6-使用-pipenv" class="headerlink" title="6. 使用 pipenv"></a>6. 使用 pipenv</h3><p>如果你在使用 pipenv 创建的虚拟环境中，可以使用下面这条命令把包安装到虚拟环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install pkg</span><br></code></pre></td></tr></table></figure><h3 id="7-使用-poetry"><a href="#7-使用-poetry" class="headerlink" title="7. 使用 poetry"></a>7. 使用 poetry</h3><p>如果你有使用 poetry 管理项目依赖，那么可以使用下面这条命令安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 直接安装包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry add pkg</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定为开发依赖</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry add pytest --dev</span><br></code></pre></td></tr></table></figure><h3 id="8-使用-curl-管道"><a href="#8-使用-curl-管道" class="headerlink" title="8. 使用 curl + 管道"></a>8. 使用 curl + 管道</h3><p>有一些第三方工具包提供的安装方法，是直接使用 curl 配置管道来安装，比如上面提到的 poetry 就可以用这种方法安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python</span><br></code></pre></td></tr></table></figure><h2 id="8-3-【基础】导入单元的构成"><a href="#8-3-【基础】导入单元的构成" class="headerlink" title="8.3 【基础】导入单元的构成"></a>8.3 【基础】导入单元的构成</h2><p>导入单元有多种，可以是模块、包及变量等。</p><p>对于这些基础的概念，对于新手还是有必要介绍一下它们的区别。</p><p><strong>模块</strong>：类似 *.py，*.pyc， *.pyd ，*.so，*.dll 这样的文件，是 Python 代码载体的最小单元。</p><p><strong>包</strong> 还可以细分为两种:</p><ul><li>Regular packages：是一个带有 <code>__init__.py</code>  文件的文件夹，此文件夹下可包含其他子包，或者模块</li><li>Namespace packages</li></ul><p>关于 Namespace packages，有的人会比较陌生，我这里摘抄官方文档的一段说明来解释一下。</p><p>Namespace packages 是由多个 部分 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。</p><p>命名空间包的 <code>__path__ </code> 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径 (或者最高层级包的 sys.path) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对包部分的搜索。</p><p>命名空间包没有 <code>parent/__init__.py</code> 文件。 实际上，在导入搜索期间可能找到多个 parent 目录，每个都由不同的部分所提供。 因此 parent&#x2F;one 的物理位置不一定与 parent&#x2F;two 相邻。 在这种情况下，Python 将为顶级的 parent 包创建一个命名空间包，无论是它本身还是它的某个子包被导入。</p><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="8-4-【基础】导入包的标准写法"><a href="#8-4-【基础】导入包的标准写法" class="headerlink" title="8.4 【基础】导入包的标准写法"></a>8.4 【基础】导入包的标准写法</h2><p>当我们 import 导入模块或包时，Python 提供两种导入方式：</p><ul><li>相对导入（relative import ）：from . import B 或 from ..A import B，其中.表示当前模块，..表示上层模块</li><li>绝对导入（absolute import）：import foo.bar 或者 from foo import bar</li></ul><p>你可以根据实际需要进行选择，但有必要说明的是，在早期的版本（ Python2.6 之前），Python 默认使用的相对导入。而后来的版本中（ Python2.6 之后），都以绝对导入为默认使用的导入方式。</p><p>使用绝对路径和相对路径各有利弊：</p><ul><li>当你在开发维护自己的项目时，应当使用相对路径导入，这样可以避免硬编码带来的麻烦。</li><li>而使用绝对路径，会让你模块导入结构更加清晰，而且也避免了重名的包冲突而导入错误。</li></ul><p>在 PEP8 中对模块的导入提出了要求，遵守 PEP8规范能让你的代码更具有可读性，我这边也列一下：</p><ul><li>import 语句应当分行书写</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## bad</span><br><span class="hljs-keyword">import</span> os,sys<br><br><span class="hljs-comment">## good</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br></code></pre></td></tr></table></figure><ul><li>import语句应当使用absolute import</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## bad</span><br><span class="hljs-keyword">from</span> ..bar <span class="hljs-keyword">import</span>  Bar<br><br><span class="hljs-comment">## good</span><br><span class="hljs-keyword">from</span> foo.bar <span class="hljs-keyword">import</span> test<br></code></pre></td></tr></table></figure><ul><li><p>import语句应当放在文件头部，置于模块说明及docstring之后，全局变量之前</p></li><li><p>import语句应该按照顺序排列，每组之间用一个空格分隔，按照内置模块，第三方模块，自己所写的模块调用顺序，同时每组内部按照字母表顺序排列</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 内置模块</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment">## 第三方模块</span><br><span class="hljs-keyword">import</span> flask<br><br><span class="hljs-comment">## 本地模块</span><br><span class="hljs-keyword">from</span> foo <span class="hljs-keyword">import</span> bar<br></code></pre></td></tr></table></figure><h2 id="8-5-【进阶】常规包与空间命名包"><a href="#8-5-【进阶】常规包与空间命名包" class="headerlink" title="8.5 【进阶】常规包与空间命名包"></a>8.5 【进阶】常规包与空间命名包</h2><h3 id="1-常规包"><a href="#1-常规包" class="headerlink" title="1. 常规包"></a>1. 常规包</h3><p>在 Python 3.3 之前或者说 Python 2 中，一个包想要被导入使用，那么该包内必须要有 <code>__init__.py</code> 文件，这个文件是 Python 识别一个文件夹是否是一个 Python 的重要标志。</p><p>举个例子，现在有如下的目录树，demo 及子文件夹 foo 和 bar 下都有  <code>__init__.py</code> 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree demo/</span><br>demo/<br>├── bar<br>│   └── __init__.py<br>├── foo<br>│   └── __init__.py<br>└── __init__.py<br></code></pre></td></tr></table></figure><p>在该目录下进入 Python Console 模式，然后就可以正常导入了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.bar<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.foo<br></code></pre></td></tr></table></figure><p>如果此时我把 demo 目录下的  <code>__init__.py</code> 删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">$ tree demo/<br>demo/<br>├── bar<br>│   └── __init__.py<br>└── foo<br>    └── __init__.py<br></code></pre></td></tr></table></figure><p>再导入就会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>ImportError: No module named demo<br></code></pre></td></tr></table></figure><h3 id="2-命名空间包"><a href="#2-命名空间包" class="headerlink" title="2. 命名空间包"></a>2. 命名空间包</h3><p>在 Python 3.3 之后（<a href="https://www.python.org/dev/peps/pep-0420/">PEP 420</a>），即使一个文件夹中没有定义 <code>__init__.py</code>，也是可以被导入的，只不过它不是以 Python 包的形式导入，而是以命名空间包 (Namespace package) 的形式被导入，而这一特性是在 Python 3.3 被引入的。</p><p>比如还是上面的目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree demo/</span><br>demo/<br>├── bar<br>│   └── __init__.py<br>└── foo<br>    └── __init__.py<br></code></pre></td></tr></table></figure><p>在 Python 3 下进入 Python Console 模式，发现导入是正常的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.foo<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.bar<br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><p>使用 <code>__path__</code> 查看一下，发现 demo 不再是一个常规包了，而是一个 namespace package </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo<br>&lt;module <span class="hljs-string">&#x27;demo&#x27;</span> (namespace)&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo.__path__<br>_NamespacePath([<span class="hljs-string">&#x27;/root/python/demo&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="3-空间命名包的好处"><a href="#3-空间命名包的好处" class="headerlink" title="3. 空间命名包的好处"></a>3. 空间命名包的好处</h3><p>利用命名空间包这个技术，可以用来导入目录分散的代码。</p><p>比如有如下的目录树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree</span><br>.<br>├── xc-pkg<br>│   └── demo<br>│       └── foo<br>│           └── __init__.py<br>└── xm-pkg<br>    └── demo<br>        └── bar<br>            └── __init__.py<br></code></pre></td></tr></table></figure><p>在这 <code>xc-pkg</code> 和 <code>xm-pkg</code> 这两个目录里，都有着共同的命名空间 demo。这时候再导入这两个包的时候，发现这两个包被合并到一起了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.extend([<span class="hljs-string">&#x27;xm-pkg&#x27;</span>, <span class="hljs-string">&#x27;xc-pkg&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.foo<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> demo.bar<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo<br>&lt;module <span class="hljs-string">&#x27;demo&#x27;</span> (namespace)&gt;<br></code></pre></td></tr></table></figure><p>在这里工作的机制被称为<code>命名空间包</code>的一个特征。从本质上讲，<code>命名空间包</code>是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。</p><p><code>命名空间包</code>的关键是确保顶级目录中没有 <code>__init__.py</code> 文件来作为共同的命名空间。缺失 <code>__init__.py</code> 文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其 <code>__path__</code> 变量中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo.__path__<br>_NamespacePath([<span class="hljs-string">&#x27;xm-pkg/demo&#x27;</span>, <span class="hljs-string">&#x27;xc-pkg/demo&#x27;</span>])<br></code></pre></td></tr></table></figure><p>一个包是否被作为一个包命名空间的主要方法是检查其 <code>__file__</code> 属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的 namespace 这个词体现出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>demo<br>&lt;module <span class="hljs-string">&#x27;demo&#x27;</span> (namespace)&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>demo.__file__<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: module <span class="hljs-string">&#x27;demo&#x27;</span> has no attribute <span class="hljs-string">&#x27;__file__&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><h2 id="8-6-【进阶】花式导包的八种方法"><a href="#8-6-【进阶】花式导包的八种方法" class="headerlink" title="8.6 【进阶】花式导包的八种方法"></a>8.6 【进阶】花式导包的八种方法</h2><h3 id="1-直接-import"><a href="#1-直接-import" class="headerlink" title="1. 直接 import"></a>1. 直接 import</h3><p>人尽皆知的方法，直接导入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>与此类似的还有，不再细讲</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ...<br><span class="hljs-keyword">import</span> ... <span class="hljs-keyword">as</span> ...<br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">import</span> ...<br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">import</span> ... <span class="hljs-keyword">as</span> ...<br></code></pre></td></tr></table></figure><p>一般情况下，使用 <code>import</code> 语句导入模块已经够用的。</p><p>但是在一些特殊场景中，可能还需要其他的导入方式。</p><p>下面我会一一地给你介绍。</p><h3 id="2-使用-import"><a href="#2-使用-import" class="headerlink" title="2. 使用 _import_"></a>2. 使用 _<em>import</em>_</h3><p><code>__import__</code> 函数可用于导入模块，import 语句也会调用函数。其定义为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">__import__(<span class="hljs-params">name</span>[, <span class="hljs-params">globals</span>[, <span class="hljs-params">locals</span>[, <span class="hljs-params">fromlist</span>[, <span class="hljs-params">level</span>]]]])</span><br></code></pre></td></tr></table></figure><p>参数介绍：</p><ul><li>name (required): 被加载 module 的名称</li><li>globals (optional): 包含全局变量的字典，该选项很少使用，采用默认值 global()</li><li>locals (optional): 包含局部变量的字典，内部标准实现未用到该变量，采用默认值 - local()</li><li>fromlist (Optional): 被导入的 submodule 名称</li><li>level (Optional): 导入路径选项，Python 2 中默认为 -1，表示同时支持 absolute import 和 relative import。Python 3 中默认为 0，表示仅支持 absolute import。如果大于 0，则表示相对导入的父目录的级数，即 1 类似于 ‘.’，2 类似于 ‘..’。</li></ul><p>使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os = <span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;os&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>如果要实现 <code>import xx as yy</code> 的效果，只要修改左值即可</p><p>如下示例，等价于 <code>import os as myos</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>myos = <span class="hljs-built_in">__import__</span>(<span class="hljs-string">&#x27;os&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>上面说过的 <code>__import__</code> 是一个内建函数，既然是内建函数的话，那么这个内建函数必将存在于 <code>__buildins__</code> 中，因此我们还可以这样导入 os 的模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>__builtins__.__dict__[<span class="hljs-string">&#x27;__import__&#x27;</span>](<span class="hljs-string">&#x27;os&#x27;</span>).getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-使用-importlib-模块"><a href="#3-使用-importlib-模块" class="headerlink" title="3. 使用 importlib 模块"></a>3. 使用 importlib 模块</h3><p>importlib 是 Python 中的一个标准库，importlib 能提供的功能非常全面。</p><p>它的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> importlib<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos=importlib.import_module(<span class="hljs-string">&quot;os&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>如果要实现 <code>import xx as yy</code>效果，可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> importlib<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>myos = importlib.import_module(<span class="hljs-string">&quot;os&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="4-使用-imp-模块"><a href="#4-使用-imp-模块" class="headerlink" title="4. 使用 imp 模块"></a>4. 使用 imp 模块</h3><p><code>imp</code> 模块提供了一些 import 语句内部实现的接口。例如模块查找（find_module）、模块加载（load_module）等等（模块的导入过程会包含模块查找、加载、缓存等步骤）。可以用该模块来简单实现内建的 <code>__import__</code> 函数功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> imp<br><span class="hljs-meta">&gt;&gt;&gt; </span>file, pathname, desc = imp.find_module(<span class="hljs-string">&#x27;os&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos = imp.load_module(<span class="hljs-string">&#x27;sep&#x27;</span>, file, pathname, desc)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos<br>&lt;module <span class="hljs-string">&#x27;sep&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/usr/lib64/python2.7/os.pyc&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>myos.getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>从 python 3 开始，内建的 reload 函数被移到了 imp 模块中。而从 Python 3.4 开始，imp 模块被否决，不再建议使用，其包含的功能被移到了 importlib 模块下。即从 Python 3.4 开始，importlib 模块是之前 imp 模块和 importlib 模块的合集。</p><h3 id="5-使用-execfile"><a href="#5-使用-execfile" class="headerlink" title="5. 使用 execfile"></a>5. 使用 execfile</h3><p>在 Python 2 中有一个 execfile 函数，利用它可以用来执行一个文件。</p><p>语法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execfile</span><span class="hljs-params">(filename[, globals[, locals]])</span></span><br></code></pre></td></tr></table></figure><p>参数有这么几个：</p><ul><li>filename：文件名。</li><li>globals：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>execfile(<span class="hljs-string">&quot;/usr/lib64/python2.7/os.py&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="6-使用-exec-执行"><a href="#6-使用-exec-执行" class="headerlink" title="6. 使用 exec 执行"></a>6. 使用 exec 执行</h3><p><code>execfile</code> 只能在 Python2 中使用，Python 3.x 里已经删除了这个函数。</p><p>但是原理值得借鉴，你可以使用 open … read  读取文件内容，然后再用 exec 去执行模块。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/usr/lib64/python2.7/os.py&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">exec</span>(f.read())<br><span class="hljs-meta">... </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>getcwd()<br><span class="hljs-string">&#x27;/home/wangbm&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="7-import-from-github-com"><a href="#7-import-from-github-com" class="headerlink" title="7. import_from_github_com"></a>7. import_from_github_com</h3><p>有一个包叫做 <strong>import_from_github_com</strong>，从名字上很容易得知，它是一个可以从 github 下载安装并导入的包。为了使用它，你需要做的就是按照如下命令使用pip 先安装它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pip install import_from_github_com</span><br></code></pre></td></tr></table></figure><p>这个包使用了PEP 302中新的引入钩子，允许你可以从github上引入包。这个包实际做的就是安装这个包并将它添加到本地。你需要 Python 3.2 或者更高的版本，并且 git 和 pip 都已经安装才能使用这个包。</p><p>pip 要保证是较新版本，如果不是请执行如下命令进行升级。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pip install --upgrade pip</span><br></code></pre></td></tr></table></figure><p>确保环境 ok 后，你就可以在 Python shell 中使用 import_from_github_com</p><p>示例如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> github_com.zzzeek <span class="hljs-keyword">import</span> sqlalchemy<br>Collecting git+https://github.com/zzzeek/sqlalchemy<br>Cloning https://github.com/zzzeek/sqlalchemy to /tmp/pip-acfv7t06-build<br>Installing collected packages: SQLAlchemy<br>Running setup.py install <span class="hljs-keyword">for</span> SQLAlchemy ... done<br>Successfully installed SQLAlchemy-<span class="hljs-number">1.1</span><span class="hljs-number">.0</span>b1.dev0<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">locals</span>()<br>&#123;<span class="hljs-string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;, <span class="hljs-string">&#x27;__spec__&#x27;</span>: <span class="hljs-literal">None</span>,<br><span class="hljs-string">&#x27;__package__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__name__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>,<br><span class="hljs-string">&#x27;sqlalchemy&#x27;</span>: &lt;module <span class="hljs-string">&#x27;sqlalchemy&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/usr/local/lib/python3.5/site-packages/\</span><br><span class="hljs-string">sqlalchemy/__init__.py&#x27;</span>&gt;,<br><span class="hljs-string">&#x27;__loader__&#x27;</span>: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;&#125;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>看了 import_from_github_com的源码后，你会注意到它并没有使用importlib。实际上，它的原理就是使用 pip 来安装那些没有安装的包，然后使用Python的<code>__import__()</code>函数来引入新安装的模块。</p><h3 id="8-远程导入模块"><a href="#8-远程导入模块" class="headerlink" title="8. 远程导入模块"></a>8. 远程导入模块</h3><p>在后面有一篇文章里，深入剖析了导入模块的内部原理，并在最后手动实现了从远程服务器上读取模块内容，并在本地成功将模块导入的导入器。</p><p>具体内容非常的多，你可以点击这个<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247484838&idx=1&sn=1e6fbf5d7546902c6965c60383f7b639&chksm=e8866544dff1ec52e01b6c9a982dfa150b8e34ad472acca35201373dc51dadb5a8630870982a&scene=21#wechat_redirect">链接</a>进行深入学习。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 新建一个 py 文件（my_importer.py），内容如下</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> urllib2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaFinder</span>(importlib.abc.MetaPathFinder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self._baseurl = baseurl<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            baseurl = self._baseurl<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是原定义的url就直接返回不存在</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path.startswith(self._baseurl):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            baseurl = path<br><br>        <span class="hljs-keyword">try</span>:<br>            loader = UrlMetaLoader(baseurl)<br>            <span class="hljs-keyword">return</span> loader<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaLoader</span>(importlib.abc.SourceLoader):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self.baseurl = baseurl<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_code</span>(<span class="hljs-params">self, fullname</span>):<br>        f = urllib2.urlopen(self.get_filename(fullname))<br>        <span class="hljs-keyword">return</span> f.read()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):<br>        <span class="hljs-keyword">return</span> self.baseurl + fullname + <span class="hljs-string">&#x27;.py&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_meta</span>(<span class="hljs-params">address</span>):<br>    finder = UrlMetaFinder(address)<br>    sys.meta_path.append(finder)<br></code></pre></td></tr></table></figure><p>并且在远程服务器上开启 http 服务（为了方便，我仅在本地进行演示），并且手动编辑一个名为 my_info 的 python 文件，如果后面导入成功会打印 <code>ok</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> httpserver &amp;&amp; <span class="hljs-built_in">cd</span> httpserver</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span>&gt;my_info.py&lt;EOF</span><br>name=&#x27;wangbm&#x27;<br>print(&#x27;ok&#x27;)<br>EOF<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> my_info.py</span><br>name=&#x27;wangbm&#x27;<br>print(&#x27;ok&#x27;)<br><span class="hljs-meta prompt_">$</span><span class="language-bash"></span><br><span class="language-bash">$ python3 -m http.server 12800</span><br>Serving HTTP on 0.0.0.0 port 12800 (http://0.0.0.0:12800/) ...<br>...<br></code></pre></td></tr></table></figure><p>一切准备好，验证开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> my_importer <span class="hljs-keyword">import</span> install_meta<br><span class="hljs-meta">&gt;&gt;&gt; </span>install_meta(<span class="hljs-string">&#x27;http://localhost:12800/&#x27;</span>) <span class="hljs-comment"># 往 sys.meta_path 注册 finder</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> my_info  <span class="hljs-comment"># 打印ok，说明导入成功</span><br>ok<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_info.name  <span class="hljs-comment"># 验证可以取得到变量</span><br><span class="hljs-string">&#x27;wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>好了，8 种方法都给大家介绍完毕，对于普通开发者来说，其实只要掌握 import 这种方法足够了，而对于那些想要自己开发框架的人来说，深入学习<code>__import__</code>以及 importlib 是非常有必要的。##  8.7 【进阶】包导入的三个冷门知识点</p><h3 id="1-使用-all-控制可被导入的变量"><a href="#1-使用-all-控制可被导入的变量" class="headerlink" title="1. 使用 _all_  控制可被导入的变量"></a>1. 使用 _<em>all</em>_  控制可被导入的变量</h3><p>使用 <code>from module import *</code>  默认情况下会导入 module 里的所有变量，若你只想从模块中导入其中几个变量，可以在 module 中使用 <code>__all__</code> 来控制想要被其他模块导入的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## profile.py</span><br>name=<span class="hljs-string">&#x27;小明&#x27;</span><br>age=<span class="hljs-number">18</span><br><br>__all__=[<span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>打开 python console 验证一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> profile <span class="hljs-keyword">import</span> *<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(name)<br>小明<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(age)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>NameError: name <span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure><p><code>__all__</code> 仅对于使用<code>from module import *</code>  这种情况适用。</p><p>它经常在一个包的 <code>__init__.py</code> 中出现。</p><h3 id="2-命名空间包的神奇之处"><a href="#2-命名空间包的神奇之处" class="headerlink" title="2. 命名空间包的神奇之处"></a>2. 命名空间包的神奇之处</h3><p>命名空间包，一个陌生的名字。</p><p>与我们熟悉的常规包不同的是，它没有 <code>__init__.py</code> 文件。</p><p>更为特殊的是，它可以跨空间地将两个不相邻的子包，合并成一个虚拟机的包，我们将其称之为 <code>命名空间包</code>。</p><p>例如，一个项目的部分代码布局如下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">foo-<span class="hljs-keyword">package</span>/<br>    spam/<br>        blah.py<br><br>bar-<span class="hljs-keyword">package</span>/<br>    spam/<br>        grok.py<br></code></pre></td></tr></table></figure><p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有_<em>init</em>_.py文件。</p><p>让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.extend([<span class="hljs-string">&#x27;foo-package&#x27;</span>, <span class="hljs-string">&#x27;bar-package&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.blah<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.grok<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>当一个包为命名空间包时，他就不再和常规包一样具有 <code>__file_</code> 属性，取而代之的是 <code>__path__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.path.extend([<span class="hljs-string">&#x27;foo-package&#x27;</span>, <span class="hljs-string">&#x27;bar-package&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.blah<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> spam.grok<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam.__path__<br>_NamespacePath([<span class="hljs-string">&#x27;foo-package/spam&#x27;</span>, <span class="hljs-string">&#x27;bar-package/spam&#x27;</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam.__file__<br>Traceback (most recent call last):<br>    File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__file__&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-模块重载中的一个坑"><a href="#3-模块重载中的一个坑" class="headerlink" title="3. 模块重载中的一个坑"></a>3. 模块重载中的一个坑</h3><p>由于有 sys.modules 的存在，当你导入一个已导入的模块时，实际上是没有效果的。</p><p>为了达到模块的重载，有的人会将已导入的包从 sys.modules 中移除后再导入</p><p>就像下面这样子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> foo.bar<br>successful to be imported<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> foo.bar<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.modules[<span class="hljs-string">&#x27;foo.bar&#x27;</span>]<br>&lt;module <span class="hljs-string">&#x27;foo.bar&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/Users/MING/Code/Python/foo/bar.py&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> sys.modules[<span class="hljs-string">&#x27;foo.bar&#x27;</span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> foo.bar<br>successful to be imported<br></code></pre></td></tr></table></figure><p>上面的例子里我使用的是<code>import foo.bar</code> ，如果你使用的是  <code>from foo import bar</code> 这种导入形式，会发现重载是同样是无效的。</p><p>这应该算是一个小坑，不知道的人，会掉入坑中爬不出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> foo.bar<br>successful to be imported<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> foo.bar<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> sys.modules[<span class="hljs-string">&#x27;foo.bar&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> foo <span class="hljs-keyword">import</span> bar<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><p>因此，在生产环境中可能需要避免重新加载模块。而在调试模式中，它会提供一定的便利，但你要知道这个重载的弊端，以免掉入坑里。</p><h2 id="8-8-【基础】pip-的超全使用指南"><a href="#8-8-【基础】pip-的超全使用指南" class="headerlink" title="8.8 【基础】pip 的超全使用指南"></a>8.8 【基础】pip 的超全使用指南</h2><p>所有的 Python 开发者都清楚，Python 之所以如此受欢迎，能够在众多高级语言中，脱颖而出，除了语法简单，上手容易之外，更多还要归功于 Python 生态的完备，有数以万计的 Python 爱好者愿意以 Python 为基础封装出各种有利于开发的第三方工具包。</p><p>这才使用我们能够以最快的速度开发出一个满足基本需要的项目，而不是每次都重复造轮子。</p><p>Python 从1991年诞生到现在，已经过去28个年头了，这其间产生了数以万计的第三方包，且每个包都会不断更新，会有越来越多的版本。</p><p>当你在一个复杂的项目环境中，如果没有一个有效的依赖包管理方案，项目的维护将会是一个大问题。</p><p>pip 是官方推荐的包管理工具，在大多数开发者眼里，pip 几乎是 Python 的标配。</p><p>当然也有其他的包管理工具</p><ul><li><p><strong>distutils</strong>：仅用于打包和安装，严格来讲不算是包管理工具</p></li><li><p><strong>setuptools</strong>：distutils的增强版，扩展了distutils，提供更多的功能，引入包依赖的管理，easy_install就是它的一个命令行工具，引入了 egg 的文件格式。</p></li><li><p><strong>Pipenv</strong>：一个集依赖包管理（pip）及虚拟环境管理（virtualenv）的工具</p></li><li><p>还有其他的，这里不一一列出。</p></li></ul><p>今天的主角是 pip ，大家肯定不会陌生。但我相信不少人，只是熟悉几个常用的用法，而对于其他几个低频且实用的用法，却知之甚少，这两天，我查阅官方文档，把这些用法整理了一下，应该是网络上比较全的介绍。</p><h3 id="1-查询软件包"><a href="#1-查询软件包" class="headerlink" title="1. 查询软件包"></a>1. 查询软件包</h3><p>查询当前环境安装的所有软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip list</span><br></code></pre></td></tr></table></figure><p>查询 pypi 上含有某名字的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip search pkg</span><br></code></pre></td></tr></table></figure><p>查询当前环境中可升级的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip list --outdated</span><br></code></pre></td></tr></table></figure><p>查询一个包的详细内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip show pkg</span><br></code></pre></td></tr></table></figure><h3 id="2-下载软件包"><a href="#2-下载软件包" class="headerlink" title="2. 下载软件包"></a>2. 下载软件包</h3><p>在不安装软件包的情况下下载软件包到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip download --destination-directory /local/wheels -r requirements.txt</span><br></code></pre></td></tr></table></figure><p>下载完，总归是要安装的，可以指定这个目录中安装软件包，而不从 pypi 上安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --no-index --find-links=/local/wheels -r requirements.txt</span><br></code></pre></td></tr></table></figure><p>当然你也从你下载的包中，自己构建生成 wheel 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install wheel</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip wheel --wheel-dir=/local/wheels -r requirements.txt</span><br></code></pre></td></tr></table></figure><h3 id="3-安装软件包"><a href="#3-安装软件包" class="headerlink" title="3. 安装软件包"></a>3. 安装软件包</h3><p>使用 <code>pip install &lt;pkg&gt;</code> 可以很方便地从 pypi 上搜索下载并安装 python 包。</p><p>如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install requests</span><br></code></pre></td></tr></table></figure><p>这是安装包的基本格式，我们也可以为其添加更多参数来实现不同的效果。</p><h4 id="3-1-只从本地安装，而不从-pypi-安装"><a href="#3-1-只从本地安装，而不从-pypi-安装" class="headerlink" title="3.1 只从本地安装，而不从 pypi 安装"></a>3.1 只从本地安装，而不从 pypi 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --no-index --find-links=/local/wheels pkg</span><br></code></pre></td></tr></table></figure><h4 id="3-2-限定版本进行软件包安装"><a href="#3-2-限定版本进行软件包安装" class="headerlink" title="3.2 限定版本进行软件包安装"></a>3.2 限定版本进行软件包安装</h4><p>以下三种，对单个 python 包的版本进行了约束</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包的版本为 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg==2.1.2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包必须大于等于 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg&gt;=2.1.2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 所安装的包必须小于等于 2.1.2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg&lt;=2.1.2</span><br></code></pre></td></tr></table></figure><p>以下命令用于管理&#x2F;控制整个 python 环境的包版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 导出依赖包列表</span></span><br>pip freeze &gt;requirements.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 从依赖包列表中安装</span></span><br>pip install -r requirements.txt<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 确保当前环境软件包的版本(并不确保安装)</span></span><br>pip install -c constraints.txt<br></code></pre></td></tr></table></figure><h4 id="3-3-限制不使用二进制包安装"><a href="#3-3-限制不使用二进制包安装" class="headerlink" title="3.3 限制不使用二进制包安装"></a>3.3 限制不使用二进制包安装</h4><p>由于默认情况下，wheel 包的平台是运行 pip download 命令 的平台，所以可能出现平台不适配的情况。</p><p>比如在 MacOS 系统下得到的 pymongo-2.8-cp27-none-macosx_10_10_intel.whl 就不能在 linux_x86_64 安装。</p><p>使用下面这条命令下载的是 tar.gz 的包，可以直接使用 pip install 安装。</p><p>比 wheel 包，这种包在安装时会进行编译，所以花费的时间会长一些。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 下载非二进制的包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip download --no-binary=:all: pkg</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">　安装非二进制的包</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install pkg --no-binary</span><br></code></pre></td></tr></table></figure><h4 id="3-4-指定代理服务器安装"><a href="#3-4-指定代理服务器安装" class="headerlink" title="3.4 指定代理服务器安装"></a>3.4 指定代理服务器安装</h4><p>当你身处在一个内网环境中时，无法直接连接公网。这时候你使用<code>pip install</code> 安装包，就会失败。</p><p>面对这种情况，可以有两种方法：</p><ol><li>下载离线包拷贝到内网机器中安装</li><li>使用代理服务器转发请求</li></ol><p>第一种方法，虽说可行，但有相当多的弊端</p><ul><li>步骤繁杂，耗时耗力</li><li>无法处理包的依赖问题</li></ul><p>这里重点来介绍，第二种方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --proxy [user:passwd@]http_server_ip:port pkg</span><br></code></pre></td></tr></table></figure><p>每次安装包就发输入长长的参数，未免有些麻烦，为此你可以将其写入配置文件中：<code>$HOME/.config/pip/pip.conf</code></p><p>对于这个路径，说明几点</p><ul><li>不同的操作系统，路径各不相同</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Linux/Unix:</span></span><br>/etc/pip.conf<br>~/.pip/pip.conf<br>~/.config/pip/pip.conf<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Mac OSX:</span></span><br>~/Library/Application Support/pip/pip.conf<br>~/.pip/pip.conf<br>/Library/Application Support/pip/pip.conf<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Windows:</span></span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">APPDATA%\pip\pip.ini</span><br><span class="hljs-meta prompt_">%</span><span class="language-bash">HOME%\pip\pip.ini</span><br>C:\Documents and Settings\All Users\Application Data\PyPA\pip\pip.conf (Windows XP)<br>C:\ProgramData\PyPA\pip\pip.conf (Windows 7及以后) <br></code></pre></td></tr></table></figure><ul><li>若在你的机子上没有此文件，则自行创建即可</li></ul><p>如何配置，这边给个样例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[global]</span><br><span class="hljs-attr">index-url</span> = http://mirrors.aliyun.com/pypi/simple/ <br><br><span class="hljs-comment">## 替换出自己的代理地址，格式为[user:passwd@]proxy.server:port</span><br><span class="hljs-attr">proxy</span>=http://xxx.xxx.xxx.xxx:<span class="hljs-number">8080</span> <br><br><span class="hljs-section">[install]</span><br><span class="hljs-comment">## 信任阿里云的镜像源，否则会有警告</span><br><span class="hljs-attr">trusted-host</span>=mirrors.aliyun.com <br></code></pre></td></tr></table></figure><h4 id="3-5-安装用户私有软件包"><a href="#3-5-安装用户私有软件包" class="headerlink" title="3.5 安装用户私有软件包"></a>3.5 安装用户私有软件包</h4><p>很多人可能还不清楚，python 的安装包是可以用户隔离的。</p><p>如果你拥有管理员权限，你可以将包安装在全局环境中。在全局环境中的这个包可被该机器上的所有拥有管理员权限的用户使用。</p><p>如果一台机器上的使用者不只一样，自私地将在全局环境中安装或者升级某个包，是不负责任且危险的做法。</p><p>面对这种情况，我们就想能否安装单独为我所用的包呢？</p><p>庆幸的是，还真有。</p><p>我能想到的有两种方法：</p><ol><li>使用虚拟环境</li><li>将包安装在用户的环境中</li></ol><p>虚拟环境，之前写过几篇文章，这里不再展开讲。</p><p>今天的重点是第二种方法，教你如何安装用户私有的包？</p><p>命令也很简单，只要加上 <code>--user</code> 参数，pip 就会将其安装在当前用户的 <code>~/.local/lib/python3.x/site-packages</code> 下，而其他用户的 python 则不会受影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install --user pkg<br></code></pre></td></tr></table></figure><p>来举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在全局环境中未安装 requests</span></span><br>[root@localhost ~]# pip list | grep requests   <br>[root@localhost ~]# su - wangbm<br>[root@localhost ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 由于用户环境继承自全局环境，这里也未安装</span></span><br>[wangbm@localhost ~]# pip list | grep requests <br>[wangbm@localhost ~]# pip install --user requests  <br>[wangbm@localhost ~]# pip list | grep requests <br>requests (2.22.0)<br>[wangbm@localhost ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 从 Location 属性可发现 requests 只安装在当前用户环境中</span></span><br>[wangbm@ws_compute01 ~]$ pip show requests<br>---<br>Metadata-Version: 2.1<br>Name: requests<br>Version: 2.22.0<br>Summary: Python HTTP for Humans.<br>Home-page: http://python-requests.org<br>Author: Kenneth Reitz<br>Author-email: me@kennethreitz.org<br>Installer: pip<br>License: Apache 2.0<br>Location: /home/wangbm/.local/lib/python2.7/site-packages<br>[wangbm@localhost ~]$ exit<br>logout<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 退出 wangbm 用户，在 root 用户环境中发现 requests 未安装</span></span><br>[root@localhost ~]$ pip list | grep requests<br>[root@localhost ~]$ <br></code></pre></td></tr></table></figure><p>当你身处个人用户环境中，python 导包时会先检索当前用户环境中是否已安装这个包，已安装则优先使用，未安装则使用全局环境中的包。</p><p>验证如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint <br><span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.path)<br>[<span class="hljs-string">&#x27;&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python27.zip&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/plat-linux2&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/lib-tk&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/lib-old&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/lib-dynload&#x27;</span>,<br> <span class="hljs-string">&#x27;/home/wangbm/.local/lib/python2.7/site-packages&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/site-packages&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib64/python2.7/site-packages/gtk-2.0&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib/python2.7/site-packages&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib/python2.7/site-packages/pip-18.1-py2.7.egg&#x27;</span>,<br> <span class="hljs-string">&#x27;/usr/lib/python2.7/site-packages/lockfile-0.12.2-py2.7.egg&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><br><br></code></pre></td></tr></table></figure><h4 id="3-6-延长超时时间"><a href="#3-6-延长超时时间" class="headerlink" title="3.6 延长超时时间"></a>3.6 延长超时时间</h4><p>若网络情况不是很好，在安装某些包时经常会因为 ReadTimeout 而失败。</p><p>对于这种情况，一般重试几次就好了。</p><p>但是这样难免有些麻烦，有没有更好的解决方法呢？</p><p>有的，可以通过延长超时时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --default-timeout=100 &lt;packages&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-卸载软件包"><a href="#4-卸载软件包" class="headerlink" title="4. 卸载软件包"></a>4. 卸载软件包</h3><p>就一条命令，不再赘述</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip uninstall pkg</span><br></code></pre></td></tr></table></figure><h3 id="5-升级软件包"><a href="#5-升级软件包" class="headerlink" title="5. 升级软件包"></a>5. 升级软件包</h3><p>想要对现有的 python 进行升级，其本质上也是先从 pypi 上下载最新版本的包，再对其进行安装。所以升级也是使用 <code>pip install</code>，只不过要加一个参数 <code>--upgrade</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --upgrade pkg</span><br></code></pre></td></tr></table></figure><p>在升级的时候，其实还有一个不怎么用到的选项 <code>--upgrade-strategy</code>，它是用来指定升级策略。</p><p>它的可选项只有两个：</p><ul><li><code>eager</code> ：升级全部依赖包</li><li><code>only-if-need</code>：只有当旧版本不能适配新的父依赖包时，才会升级。</li></ul><p>在 pip 10.0 版本之后，这个选项的默认值是 <code>only-if-need</code>，因此如下两种写法是一互致的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --upgrade pkg1</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --upgrade pkg1 --upgrade-strategy only-if-need</span><br></code></pre></td></tr></table></figure><h3 id="6-配置文件"><a href="#6-配置文件" class="headerlink" title="6. 配置文件"></a>6. 配置文件</h3><p>由于在使用 pip 安装一些包时，默认会使用 pip 的官方源，所以经常会报网络超时失败。</p><p>常用的解决办法是，在安装包时，使用 <code>-i</code> 参数指定一个国内的镜像源。但是每次指定就很麻烦呀，还要打超长的一串字母。</p><p>这时候，其实可以将这个源写进 pip 的配置文件里。以后安装的时候，就默认从你配置的这个 源里安装了。</p><p>那怎么配置呢？文件文件在哪？</p><p>使用<code> win+r</code> 输入 <code>%APPDATA%</code> 进入用户资料文件夹，查看有没有一个 pip 的文件夹，若没有则创建之。</p><p>然后进入这个 文件夹，新建一个 <code>pip.ini</code> 的文件，内容如下</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[global]</span><br><span class="hljs-attr">time-out</span>=<span class="hljs-number">60</span><br><span class="hljs-attr">index-url</span>=https://pypi.tuna.tsinghua.edu.cn/simple/<br><span class="hljs-section">[install]</span><br><span class="hljs-attr">trusted-host</span>=tsinghua.edu.cn<br></code></pre></td></tr></table></figure><p>以上几乎包含了 pip 的所有常用使用场景，为了方便，我将其整理成一张表格。</p><p><img src="http://image.iswbm.com/20191105200041.png"></p><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="8-9-【进阶】理解模块的缓存"><a href="#8-9-【进阶】理解模块的缓存" class="headerlink" title="8.9 【进阶】理解模块的缓存"></a>8.9 【进阶】理解模块的缓存</h2><p>在一个模块内部重复引用另一个相同模块，实际并不会导入两次，原因是在使用关键字 <code>import</code> 导入模块时，它会先检索 <code>sys.modules</code> 里是否已经载入这个模块了，如果已经载入，则不会再次导入，如果不存在，才会去检索导入这个模块。</p><p>来实验一下，在 <code>my_mod02</code> 这个模块里，我 import 两次 <code>my_mod01</code> 这个模块，按逻辑每一次 import 会一次 <code>my_mod01</code> 里的代码（即打印 <code>in mod01</code>），但是验证结果是，只打印了一次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> my_mod01.py</span>                 <br>print(&#x27;in mod01&#x27;)                    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> my_mod02.py</span>                 <br>import my_mod01                                        <br>import my_mod01     <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python my_mod02.py</span>              <br>in mod01                          <br></code></pre></td></tr></table></figure><p>该现象的解释是：因为有 <code>sys.modules</code> 的存在。</p><p><code>sys.modules</code> 是一个字典（key：模块名，value：模块对象），它存放着在当前 namespace 所有已经导入的模块对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## test_module.py</span><br><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.modules.get(<span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-string">&#x27;NotFound&#x27;</span>))<br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-built_in">print</span>(sys.modules.get(<span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-string">&#x27;NotFound&#x27;</span>))<br></code></pre></td></tr></table></figure><p>运行结果如下，可见在 导入后 json 模块后，<code>sys.modules</code> 才有了 json 模块的对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python test_module.py</span><br>NotFound<br>&lt;module &#x27;json&#x27; from &#x27;C:\Python27\lib\json\__init__.pyc&#x27;&gt;<br></code></pre></td></tr></table></figure><p> 由于有缓存的存在，使得我们无法重新载入一个模块。</p><p>但若你想反其道行之，可以借助 importlib 这个神奇的库来实现。事实也确实有此场景，比如在代码调试中，在发现代码有异常并修改后，我们通常要重启服务再次载入程序。这时候，若有了模块重载，就无比方便了，修改完代码后也无需服务的重启，就能继续调试。</p><p>还是以上面的例子来理解，<code>my_mod02.py</code> 改写成如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## my_mod02.py</span><br><br><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> my_mod01<br>importlib.reload(my_mod01)<br></code></pre></td></tr></table></figure><p>使用 python3 来执行这个模块，与上面不同的是，这边执行了两次 <code>my_mod01.py</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 my_mod02.py</span><br>in mod01<br>in mod01<br></code></pre></td></tr></table></figure><h2 id="8-10-【进阶】理解查找器与加载器"><a href="#8-10-【进阶】理解查找器与加载器" class="headerlink" title="8.10 【进阶】理解查找器与加载器"></a>8.10 【进阶】理解查找器与加载器</h2><p>如果指定名称的模块在 <code>sys.modules</code> 找不到，则将发起调用 Python 的导入协议以查找和加载该模块。 </p><p>此协议由两个概念性模块构成，即 <code>查找器</code> 和 <code>加载器</code>。 </p><p>一个 Python 的模块的导入，其实可以再细分为两个过程：</p><ol><li>由查找器实现的模块查找</li><li>由加载器实现的模块加载</li></ol><h3 id="1-查找器是什么？"><a href="#1-查找器是什么？" class="headerlink" title="1. 查找器是什么？"></a>1. 查找器是什么？</h3><p>查找器（finder），简单点说，查找器定义了一个模块查找机制，让程序知道该如何找到对应的模块。</p><p>其实 Python 内置了多个默认查找器，其存在于 sys.meta_path 中。</p><p>但这些查找器对应使用者来说，并不是那么重要，因此在 Python 3.3 之前， Python 解释将其隐藏了，我们称之为隐式查找器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Python 2.7</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.meta_path<br>[]<br><span class="hljs-meta">&gt;&gt;&gt; </span><br></code></pre></td></tr></table></figure><p>由于这点不利于开发者深入理解 import 机制，在 Python 3.3 后，所有的模块导入机制都会通过 sys.meta_path 暴露，不会在有任何隐式导入机制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Python 3.6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-meta">&gt;&gt;&gt; </span>pprint(sys.meta_path)<br>[&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_frozen_importlib.BuiltinImporter&#x27;</span>&gt;,<br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_frozen_importlib.FrozenImporter&#x27;</span>&gt;,<br> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_frozen_importlib_external.PathFinder&#x27;</span>&gt;]<br></code></pre></td></tr></table></figure><p>观察一下 Python 默认的这几种查找器 （finder），可以分为三种：</p><ul><li>一种知道如何导入内置模块</li><li>一种知道如何导入冻结模块</li><li>一种知道如何导入来自 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-import-path">import path</a> 的模块 (即 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder">path based finder</a>)。</li></ul><p>那我们能不能自已定义一个查找器呢？当然可以，你只要</p><ul><li>定义一个实现了 find_module 方法的类（py2和py3均可），或者实现 find_loader 类方法（仅 py3 有效），如果找到模块需要返回一个 loader 对象或者 ModuleSpec 对象（后面会讲），没找到需要返回 None</li><li>定义完后，要使用这个查找器，必须注册它，将其插入在 sys.meta_path 的首位，这样就能优先使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFinder</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">cls, name, path, target=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Importing&quot;</span>, name, path, target)<br>        <span class="hljs-comment"># 将在后面定义</span><br>        <span class="hljs-keyword">return</span> MyLoader()<br><br><span class="hljs-comment">## 由于 finder 是按顺序读取的，所以必须插入在首位</span><br>sys.meta_path.insert(<span class="hljs-number">0</span>, MyFinder)<br></code></pre></td></tr></table></figure><p>查找器可以分为两种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">object<br> +-- Finder (deprecated)<br>      +-- MetaPathFinder<br>      +-- PathEntryFinder<br></code></pre></td></tr></table></figure><p>这里需要注意的是，在 3.4 版前，查找器会直接返回 加载器（Loader）对象，而在 3.4 版后，查找器则会返回模块规格说明（ModuleSpec），其中 包含加载器。 </p><p>而关于什么是 加载器 和 模块规格说明， 请继续往后看。</p><h3 id="2-加载器是什么？"><a href="#2-加载器是什么？" class="headerlink" title="2. 加载器是什么？"></a>2. 加载器是什么？</h3><p>查找器只负责查找定位找模，而真正负责加载模块的，是加载器（loader）。</p><p>一般的 loader 必须定义名为 <code>load_module()</code> 的方法。</p><p>为什么这里说一般，因为 loader 还分多种：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">object<br> +-- Finder (deprecated)<br> |    +-- MetaPathFinder<br> |    +-- PathEntryFinder<br> +-- Loader<br>      +-- ResourceLoader --------+<br>      +-- InspectLoader          |<br>           +-- ExecutionLoader --+<br>                                 +-- FileLoader<br>                                 +-- SourceLoader<br></code></pre></td></tr></table></figure><p>通过查看源码可知，不同的加载器的抽象方法各有不同。</p><p>加载器通常由一个 finder 返回。详情参见 PEP 302，对于 abstract base class 可参见 importlib.abc.Loader。</p><p>那如何自定义我们自己的加载器呢？</p><p>你只要</p><ul><li>定义一个实现了 load_module 方法的类</li><li>对与导入有关的属性（<a href="https://docs.python.org/zh-cn/3/reference/import.html#import-related-module-attributes">点击查看详情</a>）进行校验</li><li>创建模块对象并绑定所有与导入相关的属性变量到该模块上</li><li>将此模块保存到 sys.modules 中（顺序很重要，避免递归导入）</li><li>然后加载模块（这是核心）</li><li>若加载出错，需要能够处理抛出异常（ ImportError）</li><li>若加载成功，则返回 module 对象</li></ul><p>若你想看具体的例子，可以接着往后看。</p><h3 id="3-模块规格说明"><a href="#3-模块规格说明" class="headerlink" title="3. 模块规格说明"></a>3. 模块规格说明</h3><p>导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。</p><p>模块的规格说明会作为模块对象的 <code>__spec__</code> 属性对外公开。 有关模块规格的详细内容请参阅 <a href="https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec"><code>ModuleSpec</code></a>。</p><p>在 Python 3.4 后，查找器不再返回加载器，而是返回 ModuleSpec 对象，它储存着更多的信息</p><ul><li>模块名</li><li>加载器</li><li>模块绝对路径</li></ul><p>那如何查看一个模块的 ModuleSpec ？</p><p>这边举个例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> my_mod02.py</span><br>import my_mod01<br>print(my_mod01.__spec__)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 my_mod02.py</span><br>in mod01<br>ModuleSpec(name=&#x27;my_mod01&#x27;, loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000000000392DBE0&gt;, origin=&#x27;/home/MING/my_mod01.py&#x27;)<br></code></pre></td></tr></table></figure><p>从 ModuleSpec 中可以看到，加载器是包含在内的，那我们如果要重新加载一个模块，是不是又有了另一种思路了？</p><p>来一起验证一下。</p><p>现在有两个文件：</p><p>一个是 my_info.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## my_info.py</span><br>name=<span class="hljs-string">&#x27;wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p> 另一个是：main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## main.py</span><br><span class="hljs-keyword">import</span> my_info<br><br><span class="hljs-built_in">print</span>(my_info.name)<br><br><span class="hljs-comment">## 加一个断点</span><br><span class="hljs-keyword">import</span> pdb;pdb.set_trace()<br><br><span class="hljs-comment">## 再加载一次</span><br>my_info.__spec__.loader.load_module()<br><br><span class="hljs-built_in">print</span>(my_info.name)<br></code></pre></td></tr></table></figure><p>在 <code>main.py</code> 处，我加了一个断点，目的是当运行到断点处时，我修改 my_info.py 里的 name 为 <code>ming</code> ，以便验证重载是否有效？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 main.py</span><br>wangbm<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/home/MING/main.py(9)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">my_info.__spec__.loader.load_module()</span><br>(Pdb) c<br>ming<br></code></pre></td></tr></table></figure><p>从结果来看，重载是有效的。</p><h3 id="4-导入器是什么？"><a href="#4-导入器是什么？" class="headerlink" title="4. 导入器是什么？"></a>4. 导入器是什么？</h3><p>导入器（importer），也许你在其他文章里会见到它，但其实它并不是个新鲜的东西。</p><p>它只是同时实现了查找器和加载器两种接口的对象，所以你可以说导入器（importer）是查找器（finder），也可以说它是加载器（loader）。</p><h2 id="8-11-【进阶】实现远程导入模块"><a href="#8-11-【进阶】实现远程导入模块" class="headerlink" title="8.11 【进阶】实现远程导入模块"></a>8.11 【进阶】实现远程导入模块</h2><p>由于 Python 默认的 查找器和加载器 仅支持本地的模块的导入，并不支持实现远程模块的导入。</p><p>为了让你更好的理解 Python Import Hook 机制，我下面会通过实例演示，如何自己实现远程导入模块的导入器。</p><h3 id="1-动手实现导入器"><a href="#1-动手实现导入器" class="headerlink" title="1. 动手实现导入器"></a>1. 动手实现导入器</h3><p>当导入一个包的时候，Python 解释器首先会从 sys.meta_path 中拿到查找器列表。</p><p>默认顺序是：内建模块查找器 -&gt; 冻结模块查找器 -&gt; 第三方模块路径（本地的 sys.path）查找器</p><p>若经过这三个查找器，仍然无法查找到所需的模块，则会抛出ImportError异常。</p><p>因此要实现远程导入模块，有两种思路。</p><ul><li>一种是实现自己的元路径导入器；</li><li>另一种是编写一个钩子，添加到sys.path_hooks里，识别特定的目录命名模式。</li></ul><p>我这里选择第一种方法来做为示例。</p><p>实现导入器，我们需要分别查找器和加载器。</p><p><strong>首先是查找器</strong></p><p>由源码得知，路径查找器分为两种</p><ul><li>MetaPathFinder</li><li>PathEntryFinder</li></ul><p>这里使用 MetaPathFinder 来进行查找器的编写。</p><p>在 Python 3.4 版本之前，查找器必须实现 <code>find_module()</code> 方法，而  Python 3.4+ 版，则推荐使用 <code>find_spec()</code>  方法，但这并不意味着你不能使用 <code>find_module()</code>，但是在没有 <code>find_spec()</code> 方法时，导入协议还是会尝试 <code>find_module()</code> 方法。</p><p>我先举例下使用 <code>find_module()</code> 该如何写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> abc<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaFinder</span>(abc.MetaPathFinder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self._baseurl = baseurl<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            baseurl = self._baseurl<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是原定义的url就直接返回不存在</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path.startswith(self._baseurl):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            baseurl = path<br><br>        <span class="hljs-keyword">try</span>:<br>            loader = UrlMetaLoader(baseurl)<br>            loader.load_module(fullname)<br>            <span class="hljs-keyword">return</span> loader<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>若使用 <code>find_spec()</code> ，要注意此方法的调用需要带有两到三个参数。 </p><p>第一个是被导入模块的完整限定名称，例如 <code>foo.bar.baz</code>。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 <code>None</code>，但对于子模块或子包，第二个参数为父包 <code>__path__</code> 属性的值。 如果相应的 <code>__path__</code> 属性无法访问，将引发 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError"><code>ModuleNotFoundError</code></a>。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> abc<br><span class="hljs-keyword">from</span> importlib.machinery <span class="hljs-keyword">import</span> ModuleSpec<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaFinder</span>(abc.MetaPathFinder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self._baseurl = baseurl<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_spec</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span>, target=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            baseurl = self._baseurl<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是原定义的url就直接返回不存在</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path.startswith(self._baseurl):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            baseurl = path<br><br>        <span class="hljs-keyword">try</span>:<br>            loader = UrlMetaLoader(baseurl)<br>            <span class="hljs-keyword">return</span> ModuleSpec(fullname, loader, is_package=loader.is_package(fullname))<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>接下来是加载器</strong></p><p>由源码得知，路径查找器分为三种</p><ul><li>FileLoader</li><li>SourceLoader</li></ul><p>按理说，两种加载器都可以实现我们想要的功能，我这里选用 SourceLoader 来示范。</p><p>在 SourceLoader 这个抽象类里，有几个很重要的方法，在你写实现加载器的时候需要注意</p><ul><li>get_code：获取源代码，可以根据自己场景实现实现。</li><li>exec_module：执行源代码，并将变量赋值给 <code>module.__dict__</code> </li><li>get_data：抽象方法，必须实现，返回指定路径的字节码。</li><li>get_filename：抽象方法，必须实现，返回文件名</li></ul><p>在一些老的博客文章中，你会经常看到 加载器 要实现 <code>load_module()</code> ，而这个方法早已在 Python 3.4 的时候就被废弃了，当然为了兼容考虑，你若使用 <code>load_module()</code> 也是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> abc<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaLoader</span>(abc.SourceLoader):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self.baseurl = baseurl<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_code</span>(<span class="hljs-params">self, fullname</span>):<br>        f = urllib2.urlopen(self.get_filename(fullname))<br>        <span class="hljs-keyword">return</span> f.read()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_module</span>(<span class="hljs-params">self, fullname</span>):<br>        code = self.get_code(fullname)<br>        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))<br>        mod.__file__ = self.get_filename(fullname)<br>        mod.__loader__ = self<br>        mod.__package__ = fullname<br>        <span class="hljs-built_in">exec</span>(code, mod.__dict__)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_module</span>(<span class="hljs-params">self, module</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):<br>        <span class="hljs-keyword">return</span> self.baseurl + fullname + <span class="hljs-string">&#x27;.py&#x27;</span><br></code></pre></td></tr></table></figure><p>当你使用这种旧模式实现自己的加载时，你需要注意两点，很重要：</p><ul><li>execute_module 必须重载，而且不应该有任何逻辑，即使它并不是抽象方法。</li><li>load_module，需要你在查找器里手动执行，才能实现模块的加载。。</li></ul><p>做为替换，你应该使用 <code>execute_module()</code> 和 <code>create_module()</code> 。由于基类里已经实现了 <code>execute_module</code> 和 <code>create_module()</code>，并且满足我们的使用场景。我这边可以不用重复实现。和旧模式相比，这里也不需要在设查找器里手动执行 <code>execute_module()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> urllib2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaLoader</span>(importlib.abc.SourceLoader):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self.baseurl = baseurl<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_code</span>(<span class="hljs-params">self, fullname</span>):<br>        f = urllib2.urlopen(self.get_filename(fullname))<br>        <span class="hljs-keyword">return</span> f.read()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):<br>        <span class="hljs-keyword">return</span> self.baseurl + fullname + <span class="hljs-string">&#x27;.py&#x27;</span><br></code></pre></td></tr></table></figure><p>查找器和加载器都有了，别忘了往sys.meta_path 注册我们自定义的查找器（UrlMetaFinder）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_meta</span>(<span class="hljs-params">address</span>):<br>    finder = UrlMetaFinder(address)<br>    sys.meta_path.append(finder)<br></code></pre></td></tr></table></figure><p>所有的代码都解析完毕后，我们将其整理在一个模块（my_importer.py）中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## my_importer.py</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> importlib<br><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> urllib2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaFinder</span>(importlib.abc.MetaPathFinder):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self._baseurl = baseurl<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_module</span>(<span class="hljs-params">self, fullname, path=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> path <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            baseurl = self._baseurl<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 不是原定义的url就直接返回不存在</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> path.startswith(self._baseurl):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            baseurl = path<br><br>        <span class="hljs-keyword">try</span>:<br>            loader = UrlMetaLoader(baseurl)<br>            <span class="hljs-keyword">return</span> loader<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlMetaLoader</span>(importlib.abc.SourceLoader):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, baseurl</span>):<br>        self.baseurl = baseurl<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_code</span>(<span class="hljs-params">self, fullname</span>):<br>        f = urllib2.urlopen(self.get_filename(fullname))<br>        <span class="hljs-keyword">return</span> f.read()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_filename</span>(<span class="hljs-params">self, fullname</span>):<br>        <span class="hljs-keyword">return</span> self.baseurl + fullname + <span class="hljs-string">&#x27;.py&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">install_meta</span>(<span class="hljs-params">address</span>):<br>    finder = UrlMetaFinder(address)<br>    sys.meta_path.append(finder)<br></code></pre></td></tr></table></figure><h3 id="2-搭建远程服务端"><a href="#2-搭建远程服务端" class="headerlink" title="2. 搭建远程服务端"></a>2. 搭建远程服务端</h3><p>最开始我说了，要实现一个远程导入模块的方法。</p><p>我还缺一个在远端的服务器，来存放我的模块，为了方便，我使用python自带的 <code>http.server</code> 模块用一条命令即可实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> httpserver &amp;&amp; <span class="hljs-built_in">cd</span> httpserver</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span>&gt;my_info.py&lt;EOF</span><br>name=&#x27;wangbm&#x27;<br>print(&#x27;ok&#x27;)<br>EOF<br>5sM!ebM5sM!ebMt0fNkt0fNk<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> my_info.py</span><br>name=&#x27;wangbm&#x27;<br>print(&#x27;ok&#x27;)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"></span><br><span class="language-bash">$ python3 -m http.server 12800</span><br>Serving HTTP on 0.0.0.0 port 12800 (http://0.0.0.0:12800/) ...<br>...<br></code></pre></td></tr></table></figure><p>一切准备好，我们就可以验证了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> my_importer <span class="hljs-keyword">import</span> install_meta<br><span class="hljs-meta">&gt;&gt;&gt; </span>install_meta(<span class="hljs-string">&#x27;http://localhost:12800/&#x27;</span>) <span class="hljs-comment"># 往 sys.meta_path 注册 finder </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> my_info  <span class="hljs-comment"># 打印ok，说明导入成功</span><br>ok<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_info.name  <span class="hljs-comment"># 验证可以取得到变量</span><br><span class="hljs-string">&#x27;wangbm&#x27;</span><br></code></pre></td></tr></table></figure><p>至此，我实现了一个简易的可以导入远程服务器上的模块的导入器。</p><h2 id="8-12-【基础】分发工具：distutils和setuptools"><a href="#8-12-【基础】分发工具：distutils和setuptools" class="headerlink" title="8.12 【基础】分发工具：distutils和setuptools"></a>8.12 【基础】分发工具：distutils和setuptools</h2><h3 id="1-包分发的始祖：distutils"><a href="#1-包分发的始祖：distutils" class="headerlink" title="1. 包分发的始祖：distutils"></a>1. 包分发的始祖：distutils</h3><p><code>distutils</code> 是 Python 的一个标准库，从命名上很容易看出它是一个分发（distribute）工具（utlis），它是 Python 官方开发的一个分发打包工具，所有后续的打包工具，全部都是基于它进行开发的。</p><p><code>distutils</code> 的精髓在于编写 setup.py，它是模块分发与安装的指导文件。</p><p>那么如何编写 setup.py 呢？这里面的内容非常多，我会在后面进行详细的解析，请你耐心往下看。</p><p>你有可能没写过 setup.py ，但你绝对使用过 setup.py 来做一些事情，比如下面这条命令，我们经常用它来进行模块的安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py install</span><br></code></pre></td></tr></table></figure><p>这样的安装方法是通过源码安装，与之对应的是通过二进制软件包的安装，同样我也会在后面进行介绍。</p><h3 id="2-分发工具升级：setuptools"><a href="#2-分发工具升级：setuptools" class="headerlink" title="2. 分发工具升级：setuptools"></a>2. 分发工具升级：setuptools</h3><p><code>setuptools</code> 是 distutils 增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发 Python 包。大部分 Python 用户都会使用更先进的 setuptools 模块。</p><p> <strong>distribute</strong>，或许你在其他地方也见过它，这里也提一下。</p><p>distribute 是 setuptools 有一个分支版本，分支的原因可能是有一部分开发者认为 setuptools 开发太慢了。但现在，distribute 又合并回了 setuptools 中。因此，我们可以认为它们是同一个东西。</p><p>还有一个大包分发工具是 <strong>distutils2</strong>，其试图尝试充分利用distutils，detuptools 和 distribute 并成为 Python 标准库中的标准工具。但该计划并没有达到预期的目的，且已经是一个废弃的项目。</p><p>因此，setuptools 是一个优秀的，可靠的 Python 包安装与分发工具。</p><p>那么如何在一个干净的环境中安装 setuptools 呢？</p><p>主要有两种方法：</p><ul><li>源码安装：在 <a href="https://pypi.org/project/setuptools/#files">https://pypi.org/project/setuptools/#files</a> 中下载 zip 包 解压执行 <code>python setup.py install</code> 安装</li><li>通过引导程序安装：下载引导程序，它可以用来下载或者更新最新版本的 setuptools</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">wget http://peak.telecommunity.com/dist/ez_setup.py</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 安装</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python ez_setup.py</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 更新，以下两种任选</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python ez_setup.py –U setuptools</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install -U setuptools</span><br></code></pre></td></tr></table></figure><h2 id="8-13-【基础】源码包与二进制包有什么区别？"><a href="#8-13-【基础】源码包与二进制包有什么区别？" class="headerlink" title="8.13 【基础】源码包与二进制包有什么区别？"></a>8.13 【基础】源码包与二进制包有什么区别？</h2><p>Python 包的分发可以分为两种：</p><ol><li>以源码包的方式发布</li></ol><p>源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。</p><p>源码包的本质是一个压缩包，其常见的格式有：</p><p><img src="http://image.iswbm.com/20191218202833.png"></p><ol start="2"><li>以二进制包形式发布</li></ol><p>二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。</p><p>由于不同平台的编译出来的包无法通用，所以在发布时，需事先编译好多个平台的包。</p><p>二进制包的常见格式有：</p><p><img src="http://image.iswbm.com/20191218203005.png"></p><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="8-14-【基础】eggs与wheels-有什么区别？"><a href="#8-14-【基础】eggs与wheels-有什么区别？" class="headerlink" title="8.14 【基础】eggs与wheels 有什么区别？"></a>8.14 【基础】eggs与wheels 有什么区别？</h2><p>Egg 格式是由 setuptools 在 2004 年引入，而 Wheel 格式是由 PEP427 在 2012 年定义。Wheel 的出现是为了替代 Egg，它的本质是一个zip包，其现在被认为是 Python 的二进制包的标准格式。</p><p>以下是 Wheel 和 Egg 的主要区别：</p><ul><li>Wheel 有一个官方的 PEP427 来定义，而 Egg 没有 PEP 定义</li><li>Wheel 是一种分发格式，即打包格式。而 Egg 既是一种分发格式，也是一种运行时安装的格式，并且是可以被直接 import</li><li>Wheel 文件不会包含 .pyc 文件</li><li>Wheel 使用和 PEP376 兼容的 .dist-info 目录，而 Egg 使用 .egg-info 目录</li><li>Wheel 有着更丰富的命名规则。</li><li>Wheel 是有版本的。每个 Wheel 文件都包含 wheel 规范的版本和打包的实现</li><li>Wheel 在内部被 sysconfig path type 管理，因此转向其他格式也更容易</li></ul><p>wheel 包可以通过 pip 来安装，只不过需要先安装 wheel 模块，然后再使用 pip 的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install wheel</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip wheel --wheel-dir=/local/wheels pkg</span><br></code></pre></td></tr></table></figure><h2 id="8-15-【进阶】超详细讲解-setup-py-的编写"><a href="#8-15-【进阶】超详细讲解-setup-py-的编写" class="headerlink" title="8.15 【进阶】超详细讲解 setup.py 的编写"></a>8.15 【进阶】超详细讲解 setup.py 的编写</h2><h3 id="1-setup-py-的编写"><a href="#1-setup-py-的编写" class="headerlink" title="1. setup.py 的编写"></a>1. setup.py 的编写</h3><p>1、构建源码发布包。</p><p>用于发布一个 Python 模块或项目，将源码打包成 tar.gz （用于 Linux 环境中）或者 zip 压缩包（用于 Windows 环境中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py sdist</span><br></code></pre></td></tr></table></figure><p>那这种包如何安装呢？</p><p>答案是，使用 <code>setuptools</code> 中提供的 <code>easy_install</code> 工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">easy_install xxx.tar.gz</span><br></code></pre></td></tr></table></figure><p>使用 sdist 将根据当前平台创建默认格式的存档。在类 Unix 平台上，将创建后缀后为 <code>.tar.gz</code>  的 gzip 压缩的tar文件分发包，而在Windows上为 ZIP 文件。</p><p>当然，你也可以通过指定你要的发布包格式来打破这个默认行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py sdist --formats=gztar,zip</span><br></code></pre></td></tr></table></figure><p>你可以指定的格式有哪些呢？</p><p>创建一个压缩的tarball和一个zip文件。可用格式为：</p><p><img src="http://image.iswbm.com/20191218203517.png"></p><p>对以上的格式，有几点需要注意一下：</p><ul><li>在版本3.5中才添加了对  <code>xztar</code> 格式的支持</li><li>zip 格式需要你事先已安装相应的模块：zip程序或zipfile模块（已成为Python的标准库）</li><li>ztar 格式正在弃用，请尽量不要使用</li></ul><p>另外，如果您希望归档文件的所有文件归root拥有，可以这样指定</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py sdist --owner=root --group=root</span><br></code></pre></td></tr></table></figure><p>2、构建二进制分发包。</p><p>在windows中我们习惯了双击 exe 进行软件的安装，Python 模块的安装也同样支持 打包成 exe 这样的二进制软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py bdist_wininst</span><br></code></pre></td></tr></table></figure><p>而在 Linux 中，大家也习惯了使用 rpm 来安装包，对此你可以使用这条命令实现 rpm 包的构建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py bdist_rpm</span><br></code></pre></td></tr></table></figure><p>若你喜欢使用 easy_install 或者 pip 来安装离线包。你可以将其打包成 egg 包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py bdist_egg</span><br></code></pre></td></tr></table></figure><p>若你的项目，需要安装多个平台下，既有 Windows 也有 Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py bdist</span><br></code></pre></td></tr></table></figure><h3 id="2-使用-setup-py-安装包"><a href="#2-使用-setup-py-安装包" class="headerlink" title="2. 使用 setup.py 安装包"></a>2. 使用 setup.py 安装包</h3><p>正常情况下，我们都是通过以上构建的源码包或者二进制包进行模块的安装。</p><p>但在编写 setup.py 的过程中，可能不能一步到位，需要多次调试，这时候如何测试自己写的 setup.py 文件是可用的呢？</p><p>这时候你可以使用这条命令，它会将你的模块安装至系统全局环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py install</span><br></code></pre></td></tr></table></figure><p>如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。</p><p>这时候你可以使用这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py develop</span><br></code></pre></td></tr></table></figure><h2 id="8-16-【进阶】打包辅助神器-PBR-是什么？"><a href="#8-16-【进阶】打包辅助神器-PBR-是什么？" class="headerlink" title="8.16 【进阶】打包辅助神器 PBR 是什么？"></a>8.16 【进阶】打包辅助神器 PBR 是什么？</h2><p><code>pbr</code> 是 setuptools 的辅助工具，最初是为 OpenStack 开发(<a href="https://launchpad.net/pbr)%EF%BC%8C%E5%9F%BA%E4%BA%8E%60d2to1%60%E3%80%82">https://launchpad.net/pbr)，基于`d2to1`。</a></p><p><code>pbr</code> 会读取和过滤setup.cfg中的数据，然后将解析后的数据提供给 <code>setup.py</code> 作为参数。包含如下功能：</p><ol><li>从git中获取Version、AUTHORS and ChangeLog信息</li><li>Sphinx Autodoc。pbr 会扫描project，找到所有模块，生成stub files</li><li>Requirements。pbr会读取requirements.txt，生成setup函数需要的<code>install_requires/tests_require/dependency_links</code></li></ol><p>这里需要注意，在 <code>requirements.txt</code> 文件的头部可以使用：<code>--index https://pypi.python.org/simple/</code>，这一行把一个抽象的依赖声明如 requests&#x3D;&#x3D;1.2.0 转变为一个具体的依赖声明 requests 1.2.0 from pypi.python.org&#x2F;simple&#x2F;</p><ol start="4"><li>long_description。从README.rst, README.txt or README file中生成<code>long_description</code>参数</li></ol><p>使用pbr很简单：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> setuptools import setup<br><br>setup(<br>    setup_requires=[<span class="hljs-string">&#x27;pbr&#x27;</span>],<br>    <span class="hljs-attribute">pbr</span>=<span class="hljs-literal">True</span>,<br>)<br><br></code></pre></td></tr></table></figure><p>使用pbr时，setup.cfg中有一些配置。在[files]中，有三个key：<br><code>packages</code>:指定需要包含的包，行为类似于setuptools.find_packages<br><code>namespace_packages</code>:指定namespace packages<br><code>data_files</code>: 指定目的目录和源文件路径，一个示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[files]<br>data_files =<br>    etc/pbr = etc/pbr/*<br>    etc/neutron =<br>        etc/api-paste.ini<br>        etc/dhcp-agent.ini<br>    etc/init.d = neutron.init<br><br></code></pre></td></tr></table></figure><p><code>[entry_points]</code> 段跟 setuptools 的方式相同。</p><p>到此，我讲了三种编写使用 setup.py 的方法</p><ul><li>使用命令行参数指定，一个一个将参数传递进去（极不推荐）</li><li>在 setup.py 中的setup函数中指定（推荐使用）</li><li>使用 pbr ，在 setup.cfg 中指定（易于管理，更推荐）## 8.17 【进阶】开源自己的包到 PYPI 上</li></ul><p>通过前面的学习，你一定已经学会了如何打包自己的项目，若你觉得自己开发的模块非常不错，想要 share 给其他人使用，你可以将其上传到 PyPi （Python Package Index）上，它是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包。</p><p>如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 <code>~/.pypirc</code> 文件，此文件中配置 PyPI 访问地址和账号。如的.pypirc文件内容请根据自己的账号来修改。</p><p>典型的 .pypirc 文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[distutils]</span><br><span class="hljs-attr">index-servers</span> = pypi<br><br><span class="hljs-section">[pypi]</span><br>username:xxx<br>password:xxx<br></code></pre></td></tr></table></figure><p>然后使用这条命令进行信息注册，完成后，你可以在 PyPi 上看到项目信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py register</span><br></code></pre></td></tr></table></figure><p>注册完了后，你还要上传源码包，别人才使用下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python setup.py upload</span><br></code></pre></td></tr></table></figure><p>或者也可以使用 <code>twine</code> 工具注册上传，它是一个专门用于与 pypi 进行交互的工具，详情可以参考官网：<a href="https://www.ctolib.com/twine.html%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%BA%86%E3%80%82">https://www.ctolib.com/twine.html，这里不详细讲了。</a></p><h1 id="第九章：调试技巧"><a href="#第九章：调试技巧" class="headerlink" title="第九章：调试技巧"></a>第九章：调试技巧</h1><h2 id="9-1-【调试技巧】超详细图文教你调试代码"><a href="#9-1-【调试技巧】超详细图文教你调试代码" class="headerlink" title="9.1 【调试技巧】超详细图文教你调试代码"></a>9.1 【调试技巧】超详细图文教你调试代码</h2><h3 id="1-调试的过程"><a href="#1-调试的过程" class="headerlink" title="1. 调试的过程"></a>1. 调试的过程</h3><p>调试可以说是每个开发人员都必备一项技能，在日常开发和排查 bug 都非常有用。</p><p>调试的过程分为三步：</p><ol><li><p>第一步：在你想要调试的地方，打上断点</p></li><li><p>第二步：使用调试模式来运行这个 python 程序</p></li><li><p>第三步：使用各种手段开始代码调试</p></li></ol><p>首先第一步和第二步，我用下面这张图表示</p><p><img src="http://image.iswbm.com/20200823134911.png"></p><p>点击上图中的小蜘蛛，开启调试模式后，在 PyCharm 下方会弹出一个选项卡。</p><p>这个选项卡的按键非常多，包括</p><ol><li>变量查看窗口</li><li>调试控制窗口</li><li>线程控制窗口</li><li>程序控制窗口</li></ol><p><img src="http://image.iswbm.com/20200823140008.png"></p><p>在变量查看窗口，你可以查看当前程序进行到该断点处，所有的普通变量和特殊变量，你每往下执行一行代码，这些变量都有可能跟着改变。</p><p>如果你的程序是多线程的，你可以通过线程控制窗口的下拉框来切换线程。</p><p>以上两个窗口，都相对比较简单，我一笔带过，下面主要重点讲下调试控制按钮和程序控制按钮。</p><p>在调试控制窗口，共有 8 个按钮，他们的作用分别是什么呢？</p><ol><li>Show Execution Point：无论你的代码编辑 窗口的光标在何处，只要点下该按钮，都会自动跳转到程序运行的地方。</li><li>Step Over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，程序代码越过子函数，但子函数会执行，且不进入。</li><li>Step Into：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。</li><li>Step Into My Code：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。</li><li>Step Out：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</li><li>Run To Cursor：运行到光标处，省得每次都要打一个断点。</li><li>Evaluate Expression：计算表达式，在里面可以自己执行一些代码。</li></ol><p>以上七个功能，就是最常用的功能，一般操作步骤就是，设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。</p><p>看这张图就行了（下面第6点有误，应该是运行到光标处，而不是下一断点处）</p><p><img src="http://image.iswbm.com/20200823143211.png"></p><p>在程序控制窗口，共有 6 个按钮，他们的作用分别又是什么呢？同时看下面这张图就行了。</p><p><img src="http://image.iswbm.com/20200823143535.png"></p><h3 id="2-调试相关的快捷键"><a href="#2-调试相关的快捷键" class="headerlink" title="2. 调试相关的快捷键"></a>2. 调试相关的快捷键</h3><ul><li><p>⇧ + F9：调试当前文件</p></li><li><p>⌥ + ⇧ + F9：弹出菜单，让你选择调试哪一个文件</p></li><li><p>F8：单步执行，不进入函数</p></li><li><p>F7：单步执行，进入函数</p></li><li><p>⌥ + ⇧ +F7：单步执行，只进入自己写的函数</p></li><li><p>⇧ + F8：跳出函数体</p></li><li><p>F9：运行到下一断点</p></li><li><p>⌥ + F9：运行到光标处</p></li><li><p>⇧ + ⌘ + F8：查看所有设置的断点</p></li><li><p>⌘ + F8：切换断点（有断点则取消断点，没有则加上断点）</p></li><li><p>⌥ + F5：重新以调试模式运行</p></li><li><p>⌥ + F8 计算表达式（可以更改变量值使其生效）</p></li></ul><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="9-2-【调试技巧】PyCharm-中指定参数调试程序"><a href="#9-2-【调试技巧】PyCharm-中指定参数调试程序" class="headerlink" title="9.2 【调试技巧】PyCharm 中指定参数调试程序"></a>9.2 【调试技巧】PyCharm 中指定参数调试程序</h2><p>你在 Pycharm 运行你的项目，通常是怎么执行的？我的做法是，右键，然后点击 <code>Run</code>，或者使用快捷键 <code>Shift + F10</code> 。</p><p>有时候，在运行&#x2F;调试脚本的时候，我们需要指定一些参数，这在命令行中，直接指定即可。</p><p>假设在命令行中，运行脚本的命令是这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python main.py init --local<br></code></pre></td></tr></table></figure><p>对于刚使用 Pycharm 的同学，可能并不知道 Pycharm 也是可以指定参数的。点击下图位置</p><p><img src="http://image.iswbm.com/FmfL3r0iWx_srT_xMASBEp1ZaaId"></p><p>进入设置面板，在 <code>Script parameters</code> 中填入参数即可。</p><p><img src="http://image.iswbm.com/FujczKwTUPa8l5EEmS0eoh-zL1Nk"></p><p>同时在上图的底部，你可以看到，这里可以很方便的切换 解释器，比你跑到这边来要容易得多吧</p><p><img src="http://image.iswbm.com/Fq60WOdcRJopqV6MVoRcIuZclYKx"></p><h2 id="9-3-【调试技巧】PyCharm跑完后立即进入调试模式"><a href="#9-3-【调试技巧】PyCharm跑完后立即进入调试模式" class="headerlink" title="9.3 【调试技巧】PyCharm跑完后立即进入调试模式"></a>9.3 【调试技巧】PyCharm跑完后立即进入调试模式</h2><p>假如我们在一个爬虫的项目中，会使用到 正则表达式 来匹配我们想要抓取的内容。正则这种东西，有几个人能够一步到位的呢，通常都需要经过很多次的调试才能按预期匹配。在我们改了一次正则后，运行了下，需要重新向网站抓取请求，才能发现没有匹配上，然后又改了一版，再次运行同样需要发起请求，结果还是发现还是没有匹配上，往往复复，正则不好的同学可能要进行几十次的尝试。</p><p>（上面这个例子可能不太贴切，毕竟是有很多种方法实现不用重新发请求，只是列举了一种很笨拙且低效的调试过程，你看看就好了）</p><p>而我们在这几十次的调试中，向同一网站发起请求都是没有意义的重复工作。如果在 Pycharm 中可以像  IPython Shell  和 Jupyter Notebook 那样，可以记住运行后所有的变量信息，可以在不需要重新运行项目或脚本，就可以通过执行命令表达式，来调整我们的代码，进行我们的正则调试。</p><p>答案当然是有。</p><p>假如我在调试如下几行简单的代码。在第 3 行处打了个断点。然后点击图示位置 <code>Show Python Prompt</code> 按钮。</p><p><img src="http://image.iswbm.com/Fi3N02x9OeOPatGdaReam_icn9G_"></p><p>就进入了 <code>Python Shell</code> 的界面，这个Shell 环境和我们当前运行的程序环境是打通的，变量之间可以互相访问，这下你可以轻松地进行调试了。</p><p><img src="http://image.iswbm.com/Fj1W53Txj0iFs5eYhFYh_dHlPtIL"></p><p>上面我们打了个断点，是为了方便说明这个效果。并不是说一定要打断点。如果不打断点，在脚本执行完成后，也仍然可以在这个界面查看并操作所有变量。</p><p><img src="http://image.iswbm.com/FlMsB7B1x6ET9mLOgydTWuTEXuOe"></p><p>现在我们已经可以满足我们的调试的需求，但是每次运行脚本，都要手动点击 <code>Show Python Prompt</code> ，有点麻烦。嗯？其实这个有地方可以设置默认打开的。这个开关还比较隐秘，一般人还真发现不了。</p><p>你需要点击图示位置 <code>Edit Configurations</code> 处。</p><p><img src="http://image.iswbm.com/FmfL3r0iWx_srT_xMASBEp1ZaaId"></p><p>然后在这里打勾选中。</p><p><img src="http://image.iswbm.com/FiNCYpVlI93gk1zhOdQn4c0A8FMX"></p><p>设置上之后，之后你每次运行后脚本后，都会默认为你存储所有变量的值，并为你打开 console 命令行调试界面。</p><p>除了上面这种方法，其实还有一种方法可以在调试过程中，执行命令表达式，而这种大家可能比较熟悉了，这边也提一下，就当是汇总一下。但是从功能上来说，是没有上面这种方法来得方便易用的。因为这种方法，必须要求你使用 debug 模式运行项目，并打断点。</p><p>使用方法就是，在你打了断点后，在图示位置处，点击右键使用 <code>Evaluate Expression</code></p><p><img src="http://image.iswbm.com/FrAq1tVRM7Bz948wRqZFzU2PQnI0"></p><p>就弹出了一个 <code>Evaluate Expression</code> 窗口，这里 可以运行命令表达式，直接操作变量。</p><p><img src="http://image.iswbm.com/Fo2aEraqbj_2KqDt44EzJTVe8pEf"></p><h2 id="9-4-【调试技巧】脚本报错后立即进入调试模式"><a href="#9-4-【调试技巧】脚本报错后立即进入调试模式" class="headerlink" title="9.4 【调试技巧】脚本报错后立即进入调试模式"></a>9.4 【调试技巧】脚本报错后立即进入调试模式</h2><p>当你在使用 <code>python xxx.py</code> 这样的方法，执行 Python 脚本时，若因为代码 bug 导致异常未捕获，那整个程序便会终止退出。</p><p>这个时候，我们通常会去排查是什么原因导致的程序崩溃。</p><p>大家都知道，排查问题的思路，第一步肯定是去查看日志，若这个 bug 隐藏的比较深，只有在特定场景下才会现身，那么还需要开发者，复现这个 bug，方能优化代码。</p><p>复现有时候很难，有时候虽然简单，但是要伪造各种数据，相当麻烦。</p><p>如果有一种方法能在程序崩溃后，立马进入调试模式该有多好啊？</p><p>明哥都这么问了，那肯定是带着解决方案来的。</p><p>只要你在执行脚本行，加上 <code>-i</code> 参数，即可在脚本执行完毕后进入 Python Shell 模式，方便你进行调试。</p><p>具体演示如下：</p><p><img src="http://image.iswbm.com/20200801195950.png"></p><p>需要注意的是：脚本执行完毕，有两种情况：</p><ol><li>正常退出</li><li>异常退出</li></ol><p>这两种都会进入 Python Shell，如果脚本并无异常，最终也会进入 Python Shell 模式，需要你手动退出</p><p><img src="http://image.iswbm.com/20200801201110.png"></p><h2 id="9-5-【调试技巧】使用-PDB-进行无界面调试"><a href="#9-5-【调试技巧】使用-PDB-进行无界面调试" class="headerlink" title="9.5 【调试技巧】使用 PDB 进行无界面调试"></a>9.5 【调试技巧】使用 PDB 进行无界面调试</h2><p>Pycharm 的图形化界面虽然好用，但是在某些场景中，是无法使用的。而 Python 本身已经给我们提供了一个调试神器 – pdb，可能你还不知道它，为了讲解这个神器，我写了这篇文章来帮助你轻松的理解它。</p><h3 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1. 准备文件"></a>1. 准备文件</h3><p>在调试之前先将这两个文件准备好（做为演示用），并放在同级目录中。</p><p><code>utils.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">mylist</span>):<br>    result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> mylist:<br>        result += item<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p><code>pdb_demo.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> utils<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>(<span class="hljs-params">mylist</span>):<br>    result = utils.<span class="hljs-built_in">sum</span>(mylist)<br>    <span class="hljs-built_in">print</span>(result)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----start----&quot;</span>)<br>    myfunc([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----end-----&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-进入调试模式"><a href="#2-进入调试模式" class="headerlink" title="2. 进入调试模式"></a>2. 进入调试模式</h3><p>主要有两种方法</p><p>做为脚本调用，方法很简单，就像正常执行python脚本一样，只是多加了<code>-m pdb</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> -<span class="hljs-keyword">m</span> pdb pdb_demo.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>使用这个方式进入调试模式，会在脚本的第一行开始单步调试。</p><p><img src="http://image.iswbm.com/20190118000111.png"></p><p>对于单文件的脚本并没有什么问题，如果是一个大型的项目，项目里有很多的文件，使用这种方式只能大大降低我们的效率。</p><p>一般情况下，都会直接在你需要的地方打一个断点，那如何打呢？</p><p>只需在你想要打断点的地方加上这两行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br>pdb.set_trace()<br></code></pre></td></tr></table></figure><p>然后执行时，也不需要再指定<code>-m pdb</code>了，直接<code>python pdb_demo.py </code> ，就会直接在这个地方暂停。</p><p><img src="http://image.iswbm.com/20190118000234.png"></p><p><img src="http://image.iswbm.com/20190118000557.png"></p><h3 id="3-调试指令"><a href="#3-调试指令" class="headerlink" title="3. 调试指令"></a>3. 调试指令</h3><p>熟悉 Pycharm 的人都知道，我们执行下一步，执行到下一个断点是</p><p>同样的，pdb 也需要你更多记这样的命令。</p><p>当你看到pdb模式的标识符 <code>(Pdb)</code>时，就可以输入这样的命令。</p><p>我在这里将这些指令按使用频度分为三个等级。</p><p><strong>最常用</strong></p><table><thead><tr><th align="center">指令</th><th align="center">英文</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">Next</td><td align="center">下一步</td></tr><tr><td align="center">l</td><td align="center">list</td><td align="center">列出当前断点处源码</td></tr><tr><td align="center">p</td><td align="center">print</td><td align="center">打印变量</td></tr><tr><td align="center">s</td><td align="center">step into</td><td align="center">执行当前行，可以进入函数</td></tr><tr><td align="center">r</td><td align="center">return</td><td align="center">运行完当前函数，返回结果</td></tr><tr><td align="center">c</td><td align="center">continue</td><td align="center">执行到下一断点或者结束</td></tr><tr><td align="center">b</td><td align="center">break</td><td align="center">设置断点</td></tr><tr><td align="center">q</td><td align="center">quit</td><td align="center">退出程序</td></tr></tbody></table><p><strong>有时使用</strong></p><table><thead><tr><th align="center">指令</th><th align="center">英文</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">args</td><td align="center">列出当前函数的参数</td></tr><tr><td align="center">pp</td><td align="center">pprint</td><td align="center">一种可视化更好的打印</td></tr><tr><td align="center">j</td><td align="center">jump</td><td align="center">跳到指定行</td></tr><tr><td align="center">cl</td><td align="center">clear</td><td align="center">清除断点</td></tr><tr><td align="center">w</td><td align="center">where</td><td align="center">打印当前堆栈</td></tr><tr><td align="center">u</td><td align="center">up</td><td align="center">执行跳转到当前堆栈的上一层</td></tr><tr><td align="center">unt</td><td align="center">until</td><td align="center">行数递增执行(忽略循环和函数)</td></tr><tr><td align="center">ll</td><td align="center">longlist</td><td align="center">列出更多的源码</td></tr><tr><td align="center">run&#x2F;restart</td><td align="center">run</td><td align="center">重新启动 debug(-m pdb)</td></tr></tbody></table><p><strong>几乎不用</strong></p><table><thead><tr><th align="center">指令</th><th align="center">英文</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">tbreak</td><td align="center">temporary break</td><td align="center">临时断点</td></tr><tr><td align="center">disable</td><td align="center"></td><td align="center">停用断点</td></tr><tr><td align="center">enable</td><td align="center"></td><td align="center">启用断点</td></tr><tr><td align="center">alias</td><td align="center"></td><td align="center">设置别名</td></tr><tr><td align="center">unalias</td><td align="center"></td><td align="center">删除别名</td></tr><tr><td align="center">whatis</td><td align="center"></td><td align="center">打印对象类型</td></tr><tr><td align="center">ignore</td><td align="center"></td><td align="center">设置忽略的断点</td></tr><tr><td align="center">source</td><td align="center"></td><td align="center">列出给定对象的源码</td></tr></tbody></table><p>其上全部是我翻译自官方文档，原文在这里：<a href="https://docs.python.org/3/library/pdb.html">https://docs.python.org/3/library/pdb.html</a></p><p>其实你大可不必死记这些命令，忘记的时候，只要敲入<code>help</code>并回车，就可以看所有的指令了。</p><p><img src="http://image.iswbm.com/20190118083809.png"></p><h3 id="4-开始调试"><a href="#4-开始调试" class="headerlink" title="4. 开始调试"></a>4. 开始调试</h3><p>这里就几个最常用的指定，来演示一遍。</p><p><img src="http://image.iswbm.com/20190118005507.png"></p><p>这个调试过程，我加了些注释，你应该能够很轻易地理解这种调试方式。</p><h2 id="9-6-【调试技巧】如何调试已经运行的程序？"><a href="#9-6-【调试技巧】如何调试已经运行的程序？" class="headerlink" title="9.6 【调试技巧】如何调试已经运行的程序？"></a>9.6 【调试技巧】如何调试已经运行的程序？</h2><p>官方原始wiki：<a href="https://wiki.python.org/moin/DebuggingWithGdb">https://wiki.python.org/moin/DebuggingWithGdb</a></p><p>在CentOS 下，安装包过程，官方给的不够详细。这里记录一下</p><p>先安装  yum-utils，装完后就能使用 debuginfo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install yum-utils<br></code></pre></td></tr></table></figure><p>然后使用debuginfo 安装 glibc，不过在安装之前，有可能 你需要先配置debuginfo的仓库，编辑<code>/etc/yum.repos.d/CentOS-Debuginfo.repo</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#Debug Info</span><br><span class="hljs-section">[debuginfo]</span><br><span class="hljs-attr">name</span>=CentOS-<span class="hljs-variable">$releasever</span> - DebugInfo<br><span class="hljs-comment">## CentOS-4</span><br><span class="hljs-comment">#baseurl=http://debuginfo.centos.org/$releasever/</span><br><span class="hljs-comment">## CentOS-5</span><br><span class="hljs-attr">baseurl</span>=http://debuginfo.centos.org/<span class="hljs-variable">$releasever</span>/<span class="hljs-variable">$basearch</span>/<br><span class="hljs-attr">gpgcheck</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">enabled</span>=<span class="hljs-number">1</span><br><span class="hljs-comment">## CentOS-4</span><br><span class="hljs-comment">#gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-$releasever</span><br><span class="hljs-comment">## CentOS-5</span><br><span class="hljs-attr">gpgkey</span>=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-<span class="hljs-number">5</span><br><span class="hljs-attr">protect</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>然后就可以安装 <code>glibc</code> 了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum --nogpgcheck --enablerepo=debuginfo install glibc-debuginfo<br>sudo debuginfo-install glibc<br></code></pre></td></tr></table></figure><p>最后安装 <code>python-debuginfo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install gdb python-debuginfo<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="9-7-【调试技巧】使用-PySnopper-调试疑难杂症"><a href="#9-7-【调试技巧】使用-PySnopper-调试疑难杂症" class="headerlink" title="9.7 【调试技巧】使用 PySnopper 调试疑难杂症"></a>9.7 【调试技巧】使用 PySnopper 调试疑难杂症</h2><p>对于每个程序开发者来说，调试几乎是必备技能。</p><p>代码写到一半卡住了，不知道这个函数执行完的返回结果是怎样的？调试一下看看</p><p>代码运行到一半报错了，什么情况？怎么跟预期的不一样？调试一下看看</p><p>调试的方法多种多样，不同的调试方法适合不同的场景和人群。</p><ul><li>如果你是刚接触编程的小萌新，对很多工具的使用还不是很熟练，那么 print 和 log 大法好</li><li>如果你在本地（Win或者Mac）电脑上开发，那么 IDE 的图形化界面调试无疑是最适合的；</li><li>如果你在服务器上排查BUG，那么使用 PDB 进行无图形界面的调试应该是首选；</li><li>如果你要在本地进行开发，但是项目的进行需要依赖复杂的服务器环境，那么可以了解下 PyCharm 的远程调试</li></ul><p>除了以上，今天明哥再给你介绍一款非常好用的调试工具，它能在一些场景下，大幅度提高调试的效率， 那就是 <code>PySnooper</code>，它在 Github 上已经收到了 13k 的 star，获得大家的一致好评。</p><p><strong>有了这个工具后，就算是小萌新也可以直接无门槛上手，从此与 print 说再见~</strong></p><h3 id="1-快速安装"><a href="#1-快速安装" class="headerlink" title="1. 快速安装"></a>1. 快速安装</h3><p>执行下面这些命令进行安装 PySnooper</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pip install pysnooper</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 或者</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">conda install -c conda-forge pysnooper</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 或者</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yay -S python-pysnooper</span><br></code></pre></td></tr></table></figure><h3 id="2-简单案例"><a href="#2-简单案例" class="headerlink" title="2. 简单案例"></a>2. 简单案例</h3><p>下面这段代码，定义了一个 demo_func 的函数，在里面生成一个 profile 的字典变量，然后去更新它，最后返回。</p><p>代码本身没有什么实际意义，但是用来演示 PySnooper 已经足够。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pysnooper<br><br><span class="hljs-meta">@pysnooper.snoop()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    profile = &#123;&#125;<br>    profile[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;写代码的明哥&quot;</span><br>    profile[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">27</span><br>    profile[<span class="hljs-string">&quot;gender&quot;</span>] = <span class="hljs-string">&quot;male&quot;</span><br><br>    <span class="hljs-keyword">return</span> profile<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    profile = demo_func()<br><br>main()<br></code></pre></td></tr></table></figure><p>现在我使用终端命令行的方式来运行它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@iswbm ~]# python3 demo.py <br>Source path:... demo.py<br>17:52:49.624943 call         4 def demo_func():<br>17:52:49.625124 line         5     profile = &#123;&#125;<br>New var:....... profile = &#123;&#125;<br>17:52:49.625156 line         6     profile[&quot;name&quot;] = &quot;写代码的明哥&quot;<br>Modified var:.. profile = &#123;&#x27;name&#x27;: &#x27;写代码的明哥&#x27;&#125;<br>17:52:49.625207 line         7     profile[&quot;age&quot;] = 27<br>Modified var:.. profile = &#123;&#x27;name&#x27;: &#x27;写代码的明哥&#x27;, &#x27;age&#x27;: 27&#125;<br>17:52:49.625254 line         8     profile[&quot;gender&quot;] = &quot;male&quot;<br>Modified var:.. profile = &#123;&#x27;name&#x27;: &#x27;写代码的明哥&#x27;, &#x27;age&#x27;: 27, &#x27;gender&#x27;: &#x27;male&#x27;&#125;<br>17:52:49.625306 line        10     return profile<br>17:52:49.625344 return      10     return profile<br>Return value:.. &#123;&#x27;name&#x27;: &#x27;写代码的明哥&#x27;, &#x27;age&#x27;: 27, &#x27;gender&#x27;: &#x27;male&#x27;&#125;<br>Elapsed time: 00:00:00.000486<br></code></pre></td></tr></table></figure><p>可以看到 PySnooper 把函数运行的过程全部记录了下来，包括：</p><ul><li>代码的片段、行号等信息，以及每一行代码是何时调用的？</li><li>函数内局部变量的值如何变化的？何时新增了变量，何时修改了变量。</li><li>函数的返回值是什么？</li><li>运行函数消耗了多少时间？</li></ul><p>而作为开发者，要得到这些如此详细的调试信息，你需要做的非常简单，只要给你想要调试的函数上带上一顶帽子（装饰器） – <code>@pysnooper.snoop()</code> 即可。</p><h3 id="3-详细使用"><a href="#3-详细使用" class="headerlink" title="3. 详细使用"></a>3. 详细使用</h3><h4 id="2-1-重定向到日志文件"><a href="#2-1-重定向到日志文件" class="headerlink" title="2.1 重定向到日志文件"></a>2.1 重定向到日志文件</h4><p><code>@pysnooper.snoop()</code> 不加任何参数时，会默认将调试的信息输出到标准输出。</p><p>对于单次调试就能解决的 BUG ，这样没有什么问题，但是有一些 BUG 只有在特定的场景下才会出现，需要你把程序放在后面跑个一段时间才能复现。</p><p>这种情况下，你可以将调试信息重定向输出到某一日志文件中，方便追溯排查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">output=<span class="hljs-string">&#x27;/var/log/debug.log&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><h4 id="2-2-跟踪非局部变量值"><a href="#2-2-跟踪非局部变量值" class="headerlink" title="2.2 跟踪非局部变量值"></a>2.2 跟踪非局部变量值</h4><p>PySnooper 是以函数为单位进行调试的，它默认只会跟踪函数体内的局部变量，若想跟踪全局变量，可以给 <code>@pysnooper.snoop()</code> 加上 <code>watch</code> 参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">out = &#123;<span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;bar&quot;</span>&#125;<br><br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">watch=(<span class="hljs-params"><span class="hljs-string">&#x27;out[&quot;foo&quot;]&#x27;</span></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>如此一来，PySnooper 会在 <code>out[&quot;foo&quot;]</code> 值有变化时，也将其打印出来</p><p><img src="http://image.iswbm.com/20201114183018.png"></p><p>watch 参数，接收一个可迭代对象（可以是list 或者 tuple），里面的元素为字符串表达式，什么意思呢？看下面例子就知道了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">watch=(<span class="hljs-params"><span class="hljs-string">&#x27;out[&quot;foo&quot;]&#x27;</span>, <span class="hljs-string">&#x27;foo.bar&#x27;</span>, <span class="hljs-string">&#x27;self.foo[&quot;bar&quot;]&#x27;</span></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>...<br></code></pre></td></tr></table></figure><p>和 <code>watch</code> 相对的，<code>pysnooper.snoop()</code> 还可以接收一个函数 <code>watch_explode</code>，表示除了这几个参数外的其他所有全局变量都监控。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">watch_explode=(<span class="hljs-params"><span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>...<br></code></pre></td></tr></table></figure><h4 id="2-3-设置跟踪函数的深度"><a href="#2-3-设置跟踪函数的深度" class="headerlink" title="2.3 设置跟踪函数的深度"></a>2.3 设置跟踪函数的深度</h4><p>当你使用 PySnooper 调试某个函数时，若该函数中还调用了其他函数，PySnooper 是不会傻傻的跟踪进去的。</p><p>如果你想继续跟踪该函数中调用的其他函数，可以通过指定 <code>depth</code> 参数来设置跟踪深度（不指定的话默认为 1）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">depth=<span class="hljs-number">2</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>...<br></code></pre></td></tr></table></figure><h4 id="2-4-设置调试日志的前缀"><a href="#2-4-设置调试日志的前缀" class="headerlink" title="2.4 设置调试日志的前缀"></a>2.4 设置调试日志的前缀</h4><p>当你在使用 PySnooper 跟踪多个函数时，调试的日志会显得杂乱无章，不方便查看。</p><p>在这种情况下，PySnooper 提供了一个参数，方便你为不同的函数设置不同的标志，方便你在查看日志时进行区分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">output=<span class="hljs-string">&quot;/var/log/debug.log&quot;</span>, prefix=<span class="hljs-string">&quot;demo_func: &quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://image.iswbm.com/20201114193131.png"></p><h4 id="2-5-设置最大的输出长度"><a href="#2-5-设置最大的输出长度" class="headerlink" title="2.5 设置最大的输出长度"></a>2.5 设置最大的输出长度</h4><p>默认情况下，PySnooper 输出的变量和异常信息，如果超过 100 个字符，被会截断为 100 个字符。</p><p>当然你也可以通过指定参数 进行修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">max_variable_length=<span class="hljs-number">200</span>）</span></span><br><span class="hljs-params"><span class="hljs-meta"><span class="hljs-keyword">def</span> demo_func(<span class="hljs-params"></span>):</span></span><br><span class="hljs-params"><span class="hljs-meta">    ...</span></span><br></code></pre></td></tr></table></figure><p>您也可以使用max_variable_length&#x3D;None它从不截断它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">max_variable_length=<span class="hljs-literal">None</span>）</span></span><br><span class="hljs-params"><span class="hljs-meta"><span class="hljs-keyword">def</span> demo_func(<span class="hljs-params"></span>):</span></span><br><span class="hljs-params"><span class="hljs-meta">    ...</span></span><br></code></pre></td></tr></table></figure><h4 id="2-6-支持多线程调试模式"><a href="#2-6-支持多线程调试模式" class="headerlink" title="2.6 支持多线程调试模式"></a>2.6 支持多线程调试模式</h4><p>PySnooper 同样支持多线程的调试，通过设置参数 <code>thread_info=True</code>，它就会在日志中打印出是在哪个线程对变量进行的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">thread_info=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://image.iswbm.com/20201114194449.png"></p><h4 id="2-7-自定义对象的格式输出"><a href="#2-7-自定义对象的格式输出" class="headerlink" title="2.7 自定义对象的格式输出"></a>2.7 自定义对象的格式输出</h4><p><code>pysnooper.snoop()</code> 函数有一个参数是 <code>custom_repr</code>，它接收一个元组对象。</p><p>在这个元组里，你可以指定特定类型的对象以特定格式进行输出。</p><p>这边我举个例子。</p><p>假如我要跟踪 person 这个 Person 类型的对象，由于它不是常规的 Python 基础类型，PySnooper 是无法正常输出它的信息的。</p><p>因此我在 <code>pysnooper.snoop()</code> 函数中设置了 <code>custom_repr</code> 参数，该参数的第一个元素为 Person，第二个元素为 <code>print_persion_obj</code> 函数。</p><p>PySnooper 在打印对象的调试信息时，会逐个判断它是否是 Person 类型的对象，若是，就将该对象传入 <code>print_persion_obj</code> 函数中，由该函数来决定如何显示这个对象的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_person_obj</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&lt;Person <span class="hljs-subst">&#123;obj.name&#125;</span> <span class="hljs-subst">&#123;obj.age&#125;</span> <span class="hljs-subst">&#123;obj.gender&#125;</span>&gt;&quot;</span><br>  <br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params">Person, print_person_obj</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pysnooper<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_person_obj</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&lt;Person <span class="hljs-subst">&#123;obj.name&#125;</span> <span class="hljs-subst">&#123;obj.age&#125;</span> <span class="hljs-subst">&#123;obj.gender&#125;</span>&gt;&quot;</span><br><br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params">Person, print_person_obj</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    person = Person()<br>    person.name = <span class="hljs-string">&quot;写代码的明哥&quot;</span><br>    person.age = <span class="hljs-number">27</span><br>    person.gender = <span class="hljs-string">&quot;male&quot;</span><br><br>    <span class="hljs-keyword">return</span> person<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    profile = demo_func()<br><br>main()<br></code></pre></td></tr></table></figure><p>运行一下，观察一下效果。</p><p><img src="http://image.iswbm.com/20201114201042.png"></p><p>如果你要自定义格式输出的有很多个类型，那么 <code>custom_repr</code> 参数的值可以这么写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params">(<span class="hljs-params">Person, print_person_obj</span>), (<span class="hljs-params">numpy.ndarray, print_ndarray</span>)</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>还有一点我提醒一下，元组的第一个元素可以是类型（如类名Person 或者其他基础类型 list等），也可以是一个判断对象类型的函数。</p><p>也就是说，下面三种写法是等价的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 【第一种写法】</span><br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params">Person, print_persion_obj</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br><br><br><span class="hljs-comment">## 【第二种写法】</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_persion_obj</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isinstance</span>(obj, Person)<br><br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params">is_persion_obj, print_persion_obj</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br><br><br><span class="hljs-comment">## 【第三种写法】</span><br><span class="hljs-meta">@pysnooper.snoop(<span class="hljs-params">custom_repr=(<span class="hljs-params"><span class="hljs-keyword">lambda</span> obj: <span class="hljs-built_in">isinstance</span>(<span class="hljs-params">obj, Person</span>), print_persion_obj</span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo_func</span>():<br>    ...<br></code></pre></td></tr></table></figure><p>以上就是明哥今天给大家介绍的一款调试神器（<code>PySnooper</code>） 的详细使用手册，是不是觉得还不错？## 9.8 【调试技巧】使用 PyCharm 进行远程调试</p><p>一般情况下，我们开发调试都是在个人PC上完成，遇到问题，开一下 <code>Pycharm</code> 的调试器，很快就能找到问题所在。</p><p>可有些时候，项目代码的运行会对运行环境有依赖，必须在部署了相关依赖组件的服务器上才可以运行，这就直接导致了我们不能在本地进行调试。</p><p>对于这种特殊的场景，就我所知，有如下两种解决方案：</p><ul><li>pdb</li><li>Remote Debug</li></ul><p>本篇文章会先讲第二种方案，它是 <code>专业版Pycharm</code> 才开放的功能，需要你安装专业版的Pycharm，具体升级破解步骤，请自行 Google，这里不涉及。</p><p>远程调试的意思，是让我们可以在我们在 PC 上用 Pycharm 的图形化界面来进行调试代码，它和本地调试没有太大的区别，原来怎么调试的现在还是怎么调试。</p><p>区别就在于，本地调试不需要事前配置，只要你的代码准备好了，随时可以开始 Debug 。而远程调试需要不少前置步骤，这些设置过程，也是本文的主要内容。</p><h4 id="1-新建一个项目"><a href="#1-新建一个项目" class="headerlink" title="1. 新建一个项目"></a>1. 新建一个项目</h4><p>首先，要在Pycharm中新建一个空的项目，后面我们拉服务器上的项目代码就会放置在这个项目目录下。我这边的名字是 NOVA，你可以自己定义。</p><p><img src="http://image.iswbm.com/20190113104817.png"></p><h4 id="2-配置连接服务器"><a href="#2-配置连接服务器" class="headerlink" title="2. 配置连接服务器"></a>2. 配置连接服务器</h4><p>Tools -&gt; Deployment -&gt; configuration</p><p><img src="http://image.iswbm.com/20190113105512.png"></p><p>添加一个<code>Server</code></p><ul><li><p>Name：填你的服务器的IP</p></li><li><p>Type：设定为SFTP</p></li></ul><p><img src="http://image.iswbm.com/20190113105858.png"></p><p>点击<code>OK</code>后，进入如下界面，你可以按我的备注，填写信息：</p><ul><li>SFTP host：公网ip</li><li>Port：服务器开放的ssh端口</li><li>Root path：你要调试的项目代码目录</li><li>Username：你登陆服务器所用的用户</li><li>Auth type：登陆类型，若用密码登陆的就是Password</li><li>Password：选密码登陆后，这边输入你的登陆密码，可以选择保存密码。</li></ul><p>这里请注意，要确保你的电脑可以ssh连接到你的服务器，不管是密钥登陆还是密码登陆，如果开启了白名单限制要先解除。</p><p><img src="http://image.iswbm.com/20190113105931.png"></p><p>填写完成后，切换到<code>Mappings</code>选项卡，在箭头位置，填写<code>\</code></p><p><img src="http://image.iswbm.com/20190113110928.png"></p><p>以上服务器信息配置，全部正确填写完成后，点击<code>OK</code></p><p>接下来，我们要连接远程服务器了。<br>Tools -&gt; Deployment -&gt; Browse Remote Host</p><p><img src="http://image.iswbm.com/20190113111042.png"></p><h4 id="3-下载项目代码"><a href="#3-下载项目代码" class="headerlink" title="3. 下载项目代码"></a>3. 下载项目代码</h4><p>如果之前填写的服务器登陆信息准确无误的话，现在就可以看到远程的项目代码。</p><p><img src="http://image.iswbm.com/20190113111151.png"></p><p>选择下载远程代码要本地。</p><p><img src="http://image.iswbm.com/20190113111217.png"></p><p>下载完成提示。</p><p><img src="http://image.iswbm.com/20190113111248.png"></p><p>现在的IDE界面应该是这样子的。</p><p><img src="http://image.iswbm.com/20190113111307.png"></p><h4 id="4-下载远程解释器"><a href="#4-下载远程解释器" class="headerlink" title="4. 下载远程解释器"></a>4. 下载远程解释器</h4><p>为什么需要这步呢？</p><p>远程调试是在远端的服务器上运行的，它除了依赖其他组件之外，还会有一些很多Python依赖包我们本地并没有。</p><p>进入 File -&gt; Settings<br>按图示，添加远程解释器。</p><p><img src="http://image.iswbm.com/20190113111747.png"></p><p>填写远程服务器信息，跟之前的一样，不再赘述。</p><p><img src="http://image.iswbm.com/20190113111828.png"></p><p>点击<code>OK</code>后，会自动下载远程解释器。如果你的项目比较大，这个时间可能会比较久，请耐心等待。</p><h4 id="5-添加程序入口"><a href="#5-添加程序入口" class="headerlink" title="5. 添加程序入口"></a>5. 添加程序入口</h4><p>因为我们要在本地DEBUG，所以你一定要知道你的项目的入口程序。如果这个入口程序已经包含在你的项目代码中，那么请略过这一步。</p><p>如果没有，就请自己生成入口程序。</p><p>比如，我这边的项目，在服务器上是以一个服务运行的。而我们都知道服务的入口是<code>Service文件</code>。<br><code>cat /usr/lib/systemd/system/openstack-nova-compute.service</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=OpenStack Nova Compute Server<br><span class="hljs-attr">After</span>=syslog.target network.target libvirtd.service<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=LIBGUESTFS_ATTACH_METHOD=appliance<br><span class="hljs-attr">Type</span>=notify<br><span class="hljs-attr">NotifyAccess</span>=all<br><span class="hljs-attr">TimeoutStartSec</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Restart</span>=always<br><span class="hljs-attr">User</span>=nova<br><span class="hljs-attr">ExecStart</span>=/usr/bin/nova-compute<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p>看到那个<code>ExecStart</code>没有？那个就是我们程序的入口。<br>我们只要将其拷贝至我们的Pycharm中，并向远程同步该文件。</p><p><img src="http://image.iswbm.com/20190113112004.png"></p><h4 id="6-调试前设置"><a href="#6-调试前设置" class="headerlink" title="6. 调试前设置"></a>6. 调试前设置</h4><p>开启代码自动同步，这样，我们对代码的修改Pycharm都能识别，并且为我们提交到远程服务器。</p><p><img src="http://image.iswbm.com/20190113112055.png"></p><p>开启 <code>Gevent compatible</code>，如果不开启，在调试过程中，很可能出现无法调试，或者无法追踪&#x2F;查看变量等问题。</p><p><img src="http://image.iswbm.com/20190113113211.png"></p><h4 id="7-开始调试代码"><a href="#7-开始调试代码" class="headerlink" title="7. 开始调试代码"></a>7. 开始调试代码</h4><p>在你的程序入口文件处，点击右键，选择Debug即可。</p><p>如果你的程序入口，需要引入参数，这是经常有的事，可以的这里配置。</p><p><img src="http://image.iswbm.com/20190113112456.png"></p><p>配置完点击保存即可。</p><p><img src="http://image.iswbm.com/20190113112649.png"></p><h4 id="8-友情提醒"><a href="#8-友情提醒" class="headerlink" title="8. 友情提醒"></a>8. 友情提醒</h4><p>按照文章的试调试代码，会自动同步代码至远端，千万不要在生产环境使用，一定要在开发环境中使用，否则后果自负。</p><p>调试工具给了程序员提供了很大的便利，但还是希望你不要过度依赖。尽量在每次写代码的时候，都追求一次成型，提高自己的编码能力。</p><h2 id="9-10-【调试技巧】报错后直接切换pdb调试"><a href="#9-10-【调试技巧】报错后直接切换pdb调试" class="headerlink" title="9.10 【调试技巧】报错后直接切换pdb调试"></a>9.10 【调试技巧】报错后直接切换pdb调试</h2><p>前面的文章里介绍了两种 pdb 的调试入口，也是大部分所熟知的。</p><p>这里再带大家回顾一下</p><p><strong>第一种</strong>：指定 <code>-m pdb</code> 来开启</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">$ python -m pdb pdb_demo.py<br></code></pre></td></tr></table></figure><p><strong>第二种</strong>：使用 <code>pdb.set_trace()</code> 在代码中设置断点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br><br>pdb.set_trace()<br></code></pre></td></tr></table></figure><p>但其实，pdb 还另外两种调试方法，第一种方法，可能有 99% 的开发者都没用过，甚至连见过都没有。</p><p>这两种方法，是配合 Python Console 的交互界面来实现的。</p><p>首先我准备好一个名为 <code>utils.py</code> 的 Python文件，里面定义了一个 sum 的工具函数（仅作演示用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">*args</span>):<br>    result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args:<br>        result += arg<br><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><p>然后在终端敲入 Python 进入 Console 的模式，导入这个模块，并调用 sum 函数，在正常情况下，函数可以正常工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> utils<br><span class="hljs-meta">&gt;&gt;&gt; </span>utils.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>但如果你的参数类型传成了 str，函数就会报错啦~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>utils.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>  File <span class="hljs-string">&quot;/Users/MING/utils.py&quot;</span>, line <span class="hljs-number">4</span>, <span class="hljs-keyword">in</span> <span class="hljs-built_in">sum</span><br>    result += arg<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> +=: <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>由于这里的报错是我刻意触发的，从报错来看，是很容易定位的。</p><p>但是在实际应用中，难免会遇到一些无法从报错信息直接判断 bug 所在的情况。</p><p>这个时候，如果可以在报错后，切换到 pdb 的调试模式就好了~</p><p><strong>事实上，pdb 是支持这种用法的。</strong></p><p>只要你在当前的会话中，导入 pdb，再执行 <code>pdb.pn()</code>，就可以切换到熟悉的 pdb 调试界面，并在抛错的地方打上断点，然后你就可以任意的查看运行时的变量信息。</p><p><img src="http://image.iswbm.com/20210314164424.png"></p><p>如果你不是想等报错了再调试，而是一开始就想进入调试模式，可以使用 <code>pdb.runcall()</code> 函数</p><p><img src="http://image.iswbm.com/20210314170221.png"></p><p>有的同学可能还会想到 <code>pdb.run()</code>  和 <code>pdb.runeval()</code> 这两个函数，但这两种方法，是需要提前在函数调试断点的，这就比较麻烦了，一般情况下不推荐使用。</p><p>综上所述，今天 给大家介绍了两种新的 pdb 调试入口：</p><ol><li><code>pdb.pm()</code>：在出错后直接切换到调试模式，并定位到报错位置。 – <strong>今天的重点</strong></li><li><code>pdb.runcall()</code>：可以在不设置断点的情况下，直接调试代码片段。</li></ol><h1 id="第十章：并发编程"><a href="#第十章：并发编程" class="headerlink" title="第十章：并发编程"></a>第十章：并发编程</h1><h2 id="10-1-【并发编程】从性能角度初探并发编程"><a href="#10-1-【并发编程】从性能角度初探并发编程" class="headerlink" title="10.1 【并发编程】从性能角度初探并发编程"></a>10.1 【并发编程】从性能角度初探并发编程</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>在开始讲解理论知识之前，先过一下几个基本概念。虽然咱是进阶教程，但我也希望写得更小白，更通俗易懂。</p><p><code>串行</code>：一个人在同一时间段只能干一件事，譬如吃完饭才能看电视；<br><code>并行</code>：一个人在同一时间段可以干多件事，譬如可以边吃饭边看电视；</p><p>在Python中，<code>多线程</code> 和 <code>协程</code> 虽然是严格上来说是串行，但却比一般的串行程序执行效率高得很。<br>一般的串行程序，在程序阻塞的时候，只能干等着，不能去做其他事。就好像，电视上播完正剧，进入广告时间，我们却不能去趁广告时间是吃个饭。对于程序来说，这样做显然是效率极低的，是不合理的。</p><p>当然，学完这个课程后，我们就懂得，利用广告时间去做其他事，灵活安排时间。这也是我们<code>多线程</code>和<code>协程</code> 要帮我们要完成的事情，内部合理调度任务，使得程序效率最大化。</p><p>虽然 <code>多线程</code> 和 <code>协程</code> 已经相当智能了。但还是不够高效，最高效的应该是一心多用，边看电视边吃饭边聊天。这就是我们的 <code>多进程</code> 才能做的事了。</p><p>为了更帮助大家更加直观的理解，在网上找到两张图，来生动形象的解释了多线程和多进程的区别。（侵删）</p><ul><li><p><code>多线程</code>，交替执行，另一种意义上的串行。</p></li><li><p><code>多进程</code>，并行执行，真正意义上的并发。</p></li></ul><p><img src="http://image.iswbm.com/20201219162110.png"></p><h3 id="2-单线程VS多线程VS多进程"><a href="#2-单线程VS多线程VS多进程" class="headerlink" title="2. 单线程VS多线程VS多进程"></a>2. 单线程VS多线程VS多进程</h3><p>文字总是苍白无力的，不如用代码直接来测试一下。</p><p>在开始之前呢，我要声明一下，本文作为并发章节的第一篇文章，只为了让你对单线程、多线程、多进程有个直观的了解。因此下面的代码中，会有多线程和多进程的的知识点，这些知识点在后面几节才会讲到，如果你看不明白也没有关系。</p><p>我的实验环境配置如下</p><p><img src="http://image.iswbm.com/20190112205155.png"></p><p>开始对比之前，首先定义四种类型的场景</p><ul><li>CPU计算密集型</li><li>磁盘IO密集型</li><li>网络IO密集型</li><li>【模拟】IO密集型</li></ul><p>为什么是这几种场景，这和<code>多线程</code> <code>多进程</code>的适用场景有关。结论里，我再说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## CPU计算密集型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">x=<span class="hljs-number">1</span>, y=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-comment"># 使程序完成150万计算</span><br>    c = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> c &lt; <span class="hljs-number">500000</span>:<br>        c += <span class="hljs-number">1</span><br>        x += x<br>        y += y<br><br><br><span class="hljs-comment">## 磁盘读写IO密集型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">io_disk</span>():<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000000</span>):<br>            f.write(<span class="hljs-string">&quot;python-learning\n&quot;</span>)<br><br><br><span class="hljs-comment">## 网络IO密集型</span><br>header = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&#x27;</span>&#125;<br>url = <span class="hljs-string">&quot;https://www.tieba.com/&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">io_request</span>():<br>    <span class="hljs-keyword">try</span>:<br>        webPage = requests.get(url, headers=header)<br>        html = webPage.text<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;error&quot;</span>: e&#125;<br><br>        <br><span class="hljs-comment">## 【模拟】IO密集型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">io_simulation</span>():<br>    time.sleep(<span class="hljs-number">2</span>)<br>        <br></code></pre></td></tr></table></figure><p>比拼的指标，我们用时间来考量。时间耗费得越少，说明效率越高。</p><p>为了方便，使得代码看起来，更加简洁，我这里先定义是一个简单的 <code>时间计时器</code> 的装饰器。<br>如果你对装饰器还不是很了解，也没关系，你只要知道它是用于 计算函数运行时间的东西就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">mode</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params">*args, **kw</span>):<br>            <span class="hljs-built_in">type</span> = kw.setdefault(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-literal">None</span>)<br>            t1=time.time()<br>            func(*args, **kw)<br>            t2=time.time()<br>            cost_time = t2-t1<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;-&#123;&#125;花费时间：&#123;&#125;秒&quot;</span>.<span class="hljs-built_in">format</span>(mode, <span class="hljs-built_in">type</span>,cost_time))<br>        <span class="hljs-keyword">return</span> deco<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>第一步，先来看看单线程的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@timer(<span class="hljs-params"><span class="hljs-string">&quot;【单线程】&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">single_thread</span>(<span class="hljs-params">func, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;&quot;</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>              func()<br><br><span class="hljs-comment">## 单线程</span><br>single_thread(count, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;CPU计算密集型&quot;</span>)<br>single_thread(io_disk, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;磁盘IO密集型&quot;</span>)<br>single_thread(io_request,<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;网络IO密集型&quot;</span>)<br>single_thread(io_simulation,<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;模拟IO密集型&quot;</span>)<br></code></pre></td></tr></table></figure><p>看看结果</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">【单线程】-<span class="hljs-meta">CPU</span>计算密集型花费时间：<span class="hljs-number">83.42633867263794</span>秒<br>【单线程】-磁盘IO密集型花费时间：<span class="hljs-number">15.641993284225464</span>秒<br>【单线程】-网络IO密集型花费时间：<span class="hljs-number">1.1397218704223633</span>秒<br>【单线程】-模拟IO密集型花费时间：<span class="hljs-number">20.020972728729248</span>秒<br></code></pre></td></tr></table></figure><p>第二步，再来看看多线程的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@timer(<span class="hljs-params"><span class="hljs-string">&quot;【多线程】&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_thread</span>(<span class="hljs-params">func, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;&quot;</span></span>):<br>    thread_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        t=Thread(target=func, args=())<br>        thread_list.append(t)<br>        t.start()<br>    e = <span class="hljs-built_in">len</span>(thread_list)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> th <span class="hljs-keyword">in</span> thread_list:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> th.is_alive():<br>                e -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> e &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-comment">## 多线程</span><br>multi_thread(count, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;CPU计算密集型&quot;</span>)<br>multi_thread(io_disk, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;磁盘IO密集型&quot;</span>)<br>multi_thread(io_request, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;网络IO密集型&quot;</span>)<br>multi_thread(io_simulation, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;模拟IO密集型&quot;</span>)<br></code></pre></td></tr></table></figure><p>看看结果</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">【多线程】-<span class="hljs-meta">CPU</span>计算密集型花费时间：<span class="hljs-number">93.82986998558044</span>秒<br>【多线程】-磁盘IO密集型花费时间：<span class="hljs-number">13.270896911621094</span>秒<br>【多线程】-网络IO密集型花费时间：<span class="hljs-number">0.1828296184539795</span>秒<br>【多线程】-模拟IO密集型花费时间：<span class="hljs-number">2.0288875102996826</span>秒<br></code></pre></td></tr></table></figure><p>第三步，最后来看看多进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@timer(<span class="hljs-params"><span class="hljs-string">&quot;【多进程】&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_process</span>(<span class="hljs-params">func, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;&quot;</span></span>):<br>    process_list = []<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        p = Process(target=func, args=())<br>        process_list.append(p)<br>        p.start()<br>    e = process_list.__len__()<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> pr <span class="hljs-keyword">in</span> process_list:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pr.is_alive():<br>                e -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> e &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-comment">## 多进程</span><br>multi_process(count, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;CPU计算密集型&quot;</span>)<br>multi_process(io_disk, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;磁盘IO密集型&quot;</span>)<br>multi_process(io_request, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;网络IO密集型&quot;</span>)<br>multi_process(io_simulation, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;模拟IO密集型&quot;</span>)<br></code></pre></td></tr></table></figure><p>看看结果</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">【多进程】-<span class="hljs-meta">CPU</span>计算密集型花费时间：<span class="hljs-number">9.082211017608643</span>秒<br>【多进程】-磁盘IO密集型花费时间：<span class="hljs-number">1.287339448928833</span>秒<br>【多进程】-网络IO密集型花费时间：<span class="hljs-number">0.13074755668640137</span>秒<br>【多进程】-模拟IO密集型花费时间：<span class="hljs-number">2.0076842308044434</span>秒<br></code></pre></td></tr></table></figure><h3 id="3-性能对比成果总结"><a href="#3-性能对比成果总结" class="headerlink" title="3. 性能对比成果总结"></a>3. 性能对比成果总结</h3><p>将结果汇总一下，制成表格。</p><p><img src="http://image.iswbm.com/20190112204930.png"></p><p>我们来分析下这个表格。</p><p>首先是<code>CPU密集型</code>，多线程以对比单线程，不仅没有优势，显然还由于要不断的加锁释放GIL全局锁，切换线程而耗费大量时间，效率低下，而多进程，由于是多个CPU同时进行计算工作，相当于十个人做一个人的作业，显然效率是成倍增长的。</p><p>然后是IO密集型，<code>IO密集型</code>可以是<code>磁盘IO</code>，<code>网络IO</code>，<code>数据库IO</code>等，都属于同一类，计算量很小，主要是IO等待时间的浪费。通过观察，可以发现，我们磁盘IO，网络IO的数据，多线程对比单线程也没体现出很大的优势来。这是由于我们程序的的IO任务不够繁重，所以优势不够明显。</p><p>所以我还加了一个「<code>模拟IO密集型</code>」，用<code>sleep</code>来模拟IO等待时间，就是为了体现出多线程的优势，也能让大家更加直观的理解多线程的工作过程。单线程需要每个线程都要<code>sleep(2)</code>，10个线程就是<code>20s</code>，而多线程，在<code>sleep(2)</code>的时候，会切换到其他线程，使得10个线程同时<code>sleep(2)</code>，最终10个线程也就只有<code>2s</code>.</p><p>可以得出以下几点结论</p><ul><li>单线程总是最慢的，多进程总是最快的。</li><li>多线程适合在IO密集场景下使用，譬如爬虫，网站开发等</li><li>多进程适合在对CPU计算运算要求较高的场景下使用，譬如大数据分析，机器学习等</li><li>多进程虽然总是最快的，但是不一定是最优的选择，因为它需要CPU资源支持下才能体现优势</li></ul><h2 id="10-2-【并发编程】创建多线程的几种方法"><a href="#10-2-【并发编程】创建多线程的几种方法" class="headerlink" title="10.2 【并发编程】创建多线程的几种方法"></a>10.2 【并发编程】创建多线程的几种方法</h2><p>今天的内容会比较基础，主要是为了让新手也能无障碍地阅读，所以还是要再巩固下基础。学完了基础，你们也就能很顺畅地跟着我的思路理解以后的文章。</p><p>经过总结，Python创建多线程主要有如下两种方法：</p><ul><li>函数</li><li>类</li></ul><p>接下来，我们就来揭开多线程的神秘面纱。</p><h3 id="1-用函数创建多线程"><a href="#1-用函数创建多线程" class="headerlink" title="1. 用函数创建多线程"></a>1. 用函数创建多线程</h3><p>在Python3中，Python提供了一个内置模块 <code>threading.Thread</code>，可以很方便地让我们创建多线程。</p><p><code>threading.Thread()</code> 一般接收两个参数：</p><ul><li>线程函数名：要放置线程让其后台执行的函数，由我们自已定义，注意不要加<code>()</code>；</li><li>线程函数的参数：线程函数名所需的参数，以元组的形式传入。若不需要参数，可以不指定。</li></ul><p><strong>举个例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-comment">## 自定义线程函数。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;Python&quot;</span></span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>, name)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">## 创建线程01，不指定参数</span><br>thread_01 = Thread(target=target)<br><span class="hljs-comment">## 启动线程01</span><br>thread_01.start()<br><br><br><span class="hljs-comment">## 创建线程02，指定参数，注意逗号</span><br>thread_02 = Thread(target=target, args=(<span class="hljs-string">&quot;MING&quot;</span>,))<br><span class="hljs-comment">## 启动线程02</span><br>thread_02.start()<br></code></pre></td></tr></table></figure><p>可以看到输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">hello Python<br>hello MING<br>hello Python<br>hello MING<br></code></pre></td></tr></table></figure><h3 id="2-用类创建多线程"><a href="#2-用类创建多线程" class="headerlink" title="2. 用类创建多线程"></a>2. 用类创建多线程</h3><p>相比较函数而言，使用类创建线程，会比较麻烦一点。</p><p>首先，我们要自定义一个类，对于这个类有两点要求，</p><ul><li>必须继承 <code>threading.Thread</code> 这个父类；</li><li>必须复写 <code>run</code> 方法。</li></ul><p>这里的 <code>run</code> 方法，和我们上面<code>线程函数</code>的性质是一样的，可以写我们的业务逻辑程序。在 <code>start()</code> 后将会调用。</p><p>来看一下例子<br>为了方便对比，<code>run</code>函数我复用上面的<code>main</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;Python&quot;</span></span>):<br>        <span class="hljs-comment"># 注意：super().__init__() 必须写</span><br>        <span class="hljs-comment"># 且最好写在第一行</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.<span class="hljs-built_in">type</span>=<span class="hljs-built_in">type</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>, self.<span class="hljs-built_in">type</span>)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建线程01，不指定参数</span><br>    thread_01 = MyThread()<br>    <span class="hljs-comment"># 创建线程02，指定参数</span><br>    thread_02 = MyThread(<span class="hljs-string">&quot;MING&quot;</span>)<br><br>    thread_01.start()<br>    thread_02.start()<br></code></pre></td></tr></table></figure><p>当然结果也是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">hello Python<br>hello MING<br>hello Python<br>hello MING<br></code></pre></td></tr></table></figure><h3 id="3-线程对象的方法"><a href="#3-线程对象的方法" class="headerlink" title="3. 线程对象的方法"></a>3. 线程对象的方法</h3><p>上面介绍了当前 Python 中创建线程两种主要方法。</p><p>创建线程是件很容易的事，但要想用好线程，还需要学习线程对象的几个函数。</p><p>经过我的总结，大约常用的方法有如下这些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 如上所述，创建一个线程</span><br>t=Thread(target=func)<br><br><span class="hljs-comment">## 启动子线程</span><br>t.start()<br><br><span class="hljs-comment">## 阻塞子线程，待子线程结束后，再往下执行</span><br>t.join()<br><br><span class="hljs-comment">## 判断线程是否在执行状态，在执行返回True，否则返回False</span><br>t.is_alive()<br>t.isAlive()<br><br><span class="hljs-comment">## 设置线程是否随主线程退出而退出，默认为False</span><br>t.daemon = <span class="hljs-literal">True</span><br>t.daemon = <span class="hljs-literal">False</span><br><br><span class="hljs-comment">## 设置线程名</span><br>t.name = <span class="hljs-string">&quot;My-Thread&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="10-3-【并发编程】谈谈线程中的“锁机制”"><a href="#10-3-【并发编程】谈谈线程中的“锁机制”" class="headerlink" title="10.3 【并发编程】谈谈线程中的“锁机制”"></a>10.3 【并发编程】谈谈线程中的“锁机制”</h2><h3 id="1-什么是锁？"><a href="#1-什么是锁？" class="headerlink" title="1. 什么是锁？"></a>1. 什么是锁？</h3><p>在开发中，<strong>锁</strong> 可以理解为通行证。</p><p>当你对一段逻辑代码加锁时，意味着在同一时间有且仅能有一个线程在执行这段代码。</p><p>在 Python 中的锁可以分为两种：</p><ol><li>互斥锁</li><li>可重入锁</li></ol><h3 id="2-互斥锁的使用"><a href="#2-互斥锁的使用" class="headerlink" title="2. 互斥锁的使用"></a>2. 互斥锁的使用</h3><p>来简单看下代码，学习如何加锁，获取钥匙，释放锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-comment">## 生成锁对象，全局唯一</span><br>lock = threading.Lock()<br><br><span class="hljs-comment">## 获取锁。未获取到会阻塞程序，直到获取到锁才会往下执行</span><br>lock.acquire()<br><br><span class="hljs-comment">## 释放锁，归还锁，其他人可以拿去用了</span><br>lock.release()<br></code></pre></td></tr></table></figure><p>需要注意的是，lock.acquire() 和 lock.release()必须成对出现。否则就有可能造成死锁。</p><p>很多时候，我们虽然知道，他们必须成对出现，但是还是难免会有忘记的时候。<br>为了，规避这个问题。我推荐使用使用上下文管理器来加锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br>lock = threading.Lock()<br><span class="hljs-keyword">with</span> lock:<br>    <span class="hljs-comment"># 这里写自己的代码</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>with</code> 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p><h3 id="3-为何要使用锁？"><a href="#3-为何要使用锁？" class="headerlink" title="3. 为何要使用锁？"></a>3. 为何要使用锁？</h3><p>你现在肯定还是一脸懵逼，这么麻烦，我不用锁不行吗？有的时候还真不行。</p><p>那么为了说明锁存在的意义。我们分别来看下，不用锁的情形有怎样的问题。</p><p>定义两个函数，分别在两个线程中执行。这两个函数 <code>共用</code> 一个变量 <code>n</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">job1</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        n+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;job1&#x27;</span>,n)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">job2</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        n+=<span class="hljs-number">10</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;job2&#x27;</span>,n)<br><br>n=<span class="hljs-number">0</span><br>t1=threading.Thread(target=job1)<br>t2=threading.Thread(target=job2)<br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>看代码貌似没什么问题，执行下看看输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">job1 <span class="hljs-number">1</span><br>job1 <span class="hljs-number">2</span><br>job1 job2 <span class="hljs-number">13</span><br>job2 <span class="hljs-number">23</span><br>job2 <span class="hljs-number">333</span><br>job1 <span class="hljs-number">34</span><br>job1 <span class="hljs-number">35</span><br>job2<br>job1 <span class="hljs-number">45</span> <span class="hljs-number">46</span><br>job2 <span class="hljs-number">56</span><br>job1 <span class="hljs-number">57</span><br>job2<br>job1 <span class="hljs-number">67</span><br>job2 <span class="hljs-number">68</span> <span class="hljs-number">78</span><br>job1 <span class="hljs-number">79</span><br>job2<br>job1 <span class="hljs-number">89</span><br>job2 <span class="hljs-number">90</span> <span class="hljs-number">100</span><br>job2 <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>是不是很乱？完全不是我们预想的那样。</p><p>解释下这是为什么？因为两个线程共用一个全局变量，又由于两线程是交替执行的，当<code>job1</code> 执行三次 <code>+1</code> 操作时，<code>job2</code>就不管三七二十一 给n做了<code>+10</code>操作。两个线程之间，执行完全没有规矩，没有约束。所以会看到输出当然也很乱。</p><p>加了锁后，这个问题也就解决，来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">job1</span>():<br>    <span class="hljs-keyword">global</span> n, lock<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        n += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;job1&#x27;</span>, n)<br>    lock.release()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">job2</span>():<br>    <span class="hljs-keyword">global</span> n, lock<br>    <span class="hljs-comment"># 获取锁</span><br>    lock.acquire()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        n += <span class="hljs-number">10</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;job2&#x27;</span>, n)<br>    lock.release()<br><br>n = <span class="hljs-number">0</span><br><span class="hljs-comment">## 生成锁对象</span><br>lock = threading.Lock()<br><br>t1 = threading.Thread(target=job1)<br>t2 = threading.Thread(target=job2)<br>t1.start()<br>t2.start()<br></code></pre></td></tr></table></figure><p>由于<code>job1</code>的线程，率先拿到了锁，所以在for循环中，没有人有权限对n进行操作。当<code>job1</code>执行完毕释放锁后，<code>job2</code>这才拿到了锁，开始自己的for循环。</p><p>看看执行结果，真如我们预想的那样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">job1 <span class="hljs-number">1</span><br>job1 <span class="hljs-number">2</span><br>job1 <span class="hljs-number">3</span><br>job1 <span class="hljs-number">4</span><br>job1 <span class="hljs-number">5</span><br>job1 <span class="hljs-number">6</span><br>job1 <span class="hljs-number">7</span><br>job1 <span class="hljs-number">8</span><br>job1 <span class="hljs-number">9</span><br>job1 <span class="hljs-number">10</span><br>job2 <span class="hljs-number">20</span><br>job2 <span class="hljs-number">30</span><br>job2 <span class="hljs-number">40</span><br>job2 <span class="hljs-number">50</span><br>job2 <span class="hljs-number">60</span><br>job2 <span class="hljs-number">70</span><br>job2 <span class="hljs-number">80</span><br>job2 <span class="hljs-number">90</span><br>job2 <span class="hljs-number">100</span><br>job2 <span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>这里，你应该也知道了，加锁是为了对锁内资源（变量）进行锁定，避免其他线程篡改已被锁定的资源，以达到我们预期的效果。</p><p>为了避免大家忘记释放锁，后面的例子，我将都使用with上下文管理器来加锁。大家注意一下。</p><h3 id="4-可重入锁（RLock）"><a href="#4-可重入锁（RLock）" class="headerlink" title="4. 可重入锁（RLock）"></a>4. 可重入锁（RLock）</h3><p>有时候在同一个线程中，我们可能会多次请求同一资源，俗称锁嵌套。</p><p>如果还是按照常规的做法，会造成死锁的。比如，下面这段代码，你可以试着运行一下。会发现并没有输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = <span class="hljs-number">0</span><br>    lock = threading.Lock()<br>    <span class="hljs-keyword">with</span> lock:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            n += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">with</span> lock:<br>                <span class="hljs-built_in">print</span>(n)<br><br>t1 = threading.Thread(target=main)<br>t1.start()<br></code></pre></td></tr></table></figure><p>是因为第二次获取锁(通行证)时，发现锁(通行证)已经被同一线程的人拿走了，拿东西总有个先来后到，别人拿走了，你要想用，你就得干等着，直到有人归还锁（通行证），假如别人一直不归还，那程序就会在这里一直阻塞。</p><p>上面的代码中，使用了嵌套锁，在锁还没有释放的时候，又再一次请求锁，这就当然会造成死锁了。</p><p>那么如何解决这个问题呢？</p><p><code>threading</code>模块除了提供<code>Lock</code>锁之外，还提供了一种可重入锁<code>RLock</code>，专门来处理这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 生成可重入锁对象</span><br>    lock = threading.RLock()<br>    <span class="hljs-keyword">with</span> lock:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            n += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">with</span> lock:<br>                <span class="hljs-built_in">print</span>(n)<br><br>t1 = threading.Thread(target=main)<br>t1.start()<br></code></pre></td></tr></table></figure><p>执行一下，发现已经有输出了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br><span class="hljs-number">8</span><br><span class="hljs-number">9</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>需要注意的是，可重入锁（RLock），只在同一线程里放松对锁(通行证)的获取，意思是，只要在同一线程里，程序就当你是同一个人，这个锁就可以复用，其他的话与<code>Lock</code>并无区别。</p><h3 id="5-防止死锁的加锁机制"><a href="#5-防止死锁的加锁机制" class="headerlink" title="5. 防止死锁的加锁机制"></a>5. 防止死锁的加锁机制</h3><p>在编写多线程程序时，可能无意中就会写了一个死锁。可以说，死锁的形式有多种多样，但是本质都是相同的，都是对资源不合理竞争的结果。</p><p>以本人的经验总结，死锁通常以下几种</p><ul><li>同一线程，嵌套获取同把互斥锁，造成死锁。 </li><li>多个线程，不按顺序同时获取多个锁。造成死锁</li></ul><p>对于第一种，上面已经说过了，使用可重入锁。</p><p>主要是第二种。可能你还没明白，是如何死锁的。</p><p>举个例子。</p><blockquote><p>线程1，嵌套获取A,B两个锁，线程2，嵌套获取B,A两个锁。<br>由于两个线程是交替执行的，是有机会遇到线程1获取到锁A，而未获取到锁B，在同一时刻，线程2获取到锁B，而未获取到锁A。由于锁B已经被线程2获取了，所以线程1就卡在了获取锁B处，由于是嵌套锁，线程1未获取并释放B，是不能释放锁A的，这是导致线程2也获取不到锁A，也卡住了。两个线程，各执一锁，各不让步。造成死锁。</p></blockquote><p>经过数学证明，只要两个（或多个）线程获取嵌套锁时，按照固定顺序就能保证程序不会进入死锁状态。</p><p>那么问题就转化成如何保证这些锁是按顺序的？</p><p>有两个办法</p><ul><li>人工自觉，人工识别。</li><li>写一个辅助函数来对锁进行排序。</li></ul><p>第一种，就不说了。</p><p>第二种，可以参考如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<br><br><span class="hljs-comment">## Thread-local state to stored information on locks already acquired</span><br>_local = threading.local()<br><br><span class="hljs-meta">@contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">acquire</span>(<span class="hljs-params">*locks</span>):<br>    <span class="hljs-comment"># Sort locks by object identifier</span><br>    locks = <span class="hljs-built_in">sorted</span>(locks, key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">id</span>(x))<br><br>    <span class="hljs-comment"># Make sure lock order of previously acquired locks is not violated</span><br>    acquired = <span class="hljs-built_in">getattr</span>(_local,<span class="hljs-string">&#x27;acquired&#x27;</span>,[])<br>    <span class="hljs-keyword">if</span> acquired <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">id</span>(lock) <span class="hljs-keyword">for</span> lock <span class="hljs-keyword">in</span> acquired) &gt;= <span class="hljs-built_in">id</span>(locks[<span class="hljs-number">0</span>]):<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Lock Order Violation&#x27;</span>)<br><br>    <span class="hljs-comment"># Acquire all of the locks</span><br>    acquired.extend(locks)<br>    _local.acquired = acquired<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> lock <span class="hljs-keyword">in</span> locks:<br>            lock.acquire()<br>        <span class="hljs-keyword">yield</span><br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-comment"># Release locks in reverse order of acquisition</span><br>        <span class="hljs-keyword">for</span> lock <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(locks):<br>            lock.release()<br>        <span class="hljs-keyword">del</span> acquired[-<span class="hljs-built_in">len</span>(locks):]<br></code></pre></td></tr></table></figure><p>如何使用呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br>x_lock = threading.Lock()<br>y_lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">thread_1</span>():<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">with</span> acquire(x_lock):<br>            <span class="hljs-keyword">with</span> acquire(y_lock):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Thread-1&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">thread_2</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">with</span> acquire(y_lock):<br>            <span class="hljs-keyword">with</span> acquire(x_lock):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Thread-2&#x27;</span>)<br><br>t1 = threading.Thread(target=thread_1)<br>t1.daemon = <span class="hljs-literal">True</span><br>t1.start()<br><br>t2 = threading.Thread(target=thread_2)<br>t2.daemon = <span class="hljs-literal">True</span><br>t2.start()<br></code></pre></td></tr></table></figure><p>看到没有，表面上<code>thread_1</code>的先获取锁x，再获取锁<code>y</code>，而<code>thread_2</code>是先获取锁<code>y</code>，再获取<code>x</code>。<br>但是实际上，<code>acquire</code>函数，已经对<code>x</code>，<code>y</code>两个锁进行了排序。所以<code>thread_1</code>，<code>hread_2</code>都是以同一顺序来获取锁的，是不是造成死锁的。</p><h3 id="6-饱受争议的GIL（全局锁）"><a href="#6-饱受争议的GIL（全局锁）" class="headerlink" title="6. 饱受争议的GIL（全局锁）"></a>6. 饱受争议的GIL（全局锁）</h3><p>在第一节的时候，我就和大家介绍到，多线程和多进程是不一样的。</p><p>多进程是真正的并行，而多线程是伪并行，实际上他只是交替执行。</p><p>是什么导致多线程，只能交替执行呢？是一个叫<code>GIL</code>（<code>Global Interpreter Lock</code>，全局解释器锁）的东西。</p><p>什么是GIL呢？</p><blockquote><p>任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p></blockquote><p>需要注意的是，GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。而Python解释器，并不是只有CPython，除它之外，还有<code>PyPy</code>，<code>Psyco</code>，<code>JPython</code>，<code>IronPython</code>等。</p><p>在绝大多数情况下，我们通常都认为 Python <code>==</code> CPython，所以也就默许了Python具有GIL锁这个事。</p><p>都知道GIL影响性能，那么如何避免受到GIL的影响？</p><ul><li>使用多进程代替多线程。</li><li>更换Python解释器，不使用CPython</li></ul><h2 id="10-4-【并发编程】线程消息通信机制"><a href="#10-4-【并发编程】线程消息通信机制" class="headerlink" title="10.4 【并发编程】线程消息通信机制"></a>10.4 【并发编程】线程消息通信机制</h2><p>前面我已经向大家介绍了，如何使用创建线程，启动线程。相信大家都会有这样一个想法，线程无非就是创建一下，然后再<code>start()</code>下，实在是太简单了。</p><p>可是要知道，在真实的项目中，实际场景可要我们举的例子要复杂的多得多，不同线程的执行可能是有顺序的，或者说他们的执行是有条件的，是要受控制的。如果仅仅依靠前面学的那点浅薄的知识，是远远不够的。</p><p>那今天，我们就来探讨一下如何控制线程的触发执行。</p><p>要实现对多个线程进行控制，其实本质上就是消息通信机制在起作用，利用这个机制发送指令，告诉线程，什么时候可以执行，什么时候不可以执行，执行什么内容。</p><p>经过我的总结，线程中通信方法大致有如下三种：</p><ul><li>threading.Event</li><li>threading.Condition</li><li>queue.Queue</li></ul><p>接下来我们来一一探讨下。</p><hr><h3 id="1-Event事件"><a href="#1-Event事件" class="headerlink" title="1. Event事件"></a>1. Event事件</h3><p>Python提供了非常简单的通信机制 <code>Threading.Event</code>，通用的条件变量。多个线程可以<code>等待某个事件的发生</code>，在事件发生后，<code>所有的线程</code>都会被<code>激活</code>。</p><p>关于Event的使用也超级简单，就三个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">event = threading.Event()<br><br><span class="hljs-comment">## 重置event，使得所有该event事件都处于待命状态</span><br>event.clear()<br><br><span class="hljs-comment">## 等待接收event的指令，决定是否阻塞程序执行</span><br>event.wait()<br><br><span class="hljs-comment">## 发送event指令，使所有设置该event事件的线程执行</span><br>event.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>举个例子来看下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, event</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.name = name<br>        self.event = event<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Thread: &#123;&#125; start at &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, time.ctime(time.time())))<br>        <span class="hljs-comment"># 等待event.set()后，才能往下执行</span><br>        self.event.wait()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Thread: &#123;&#125; finish at &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.name, time.ctime(time.time())))<br><br><br>threads = []<br>event = threading.Event()<br><br><span class="hljs-comment">## 定义五个线程</span><br>[threads.append(MyThread(<span class="hljs-built_in">str</span>(i), event)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)]<br><br><span class="hljs-comment">## 重置event，使得event.wait()起到阻塞作用</span><br>event.clear()<br><br><span class="hljs-comment">## 启动所有线程</span><br>[t.start() <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;等待5s...&#x27;</span>)<br>time.sleep(<span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;唤醒所有线程...&#x27;</span>)<br>event.<span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>执行一下，看看结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Thread: <span class="hljs-number">1</span> start at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:08 <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">2</span> start at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:08 <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">3</span> start at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:08 <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">4</span> start at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:08 <span class="hljs-number">2018</span><br><br>等待5s...<br><br>唤醒所有线程...<br>Thread: <span class="hljs-number">1</span> finish at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:<span class="hljs-number">13</span> <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">4</span> finish at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:<span class="hljs-number">13</span> <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">2</span> finish at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:<span class="hljs-number">13</span> <span class="hljs-number">2018</span><br>Thread: <span class="hljs-number">3</span> finish at Sun May <span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">38</span>:<span class="hljs-number">13</span> <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><p>可见在所有线程都启动（<code>start()</code>）后，并不会执行完，而是都在<code>self.event.wait()</code>止住了，需要我们通过<code>event.set()</code>来给所有线程发送执行指令才能往下执行。</p><h3 id="2-Condition"><a href="#2-Condition" class="headerlink" title="2. Condition"></a>2. Condition</h3><p>Condition和Event 是类似的，并没有多大区别。</p><p>同样，Condition也只需要掌握几个函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">cond = threading.Condition()<br><br><span class="hljs-comment">## 类似lock.acquire()</span><br>cond.acquire()<br><br><span class="hljs-comment">## 类似lock.release()</span><br>cond.release()<br><br><span class="hljs-comment">## 等待指定触发，同时会释放对锁的获取,直到被notify才重新占有琐。</span><br>cond.wait()<br><br><span class="hljs-comment">## 发送指定，触发执行</span><br>cond.notify()<br></code></pre></td></tr></table></figure><p>举个网上一个比较趣的捉迷藏的例子来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hider</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, cond, name</span>):<br>        <span class="hljs-built_in">super</span>(Hider, self).__init__()<br>        self.cond = cond<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment">#确保先运行Seeker中的方法</span><br>        self.cond.acquire()<br><br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&#x27;: 我已经把眼睛蒙上了&#x27;</span>)<br>        self.cond.notify()<br>        self.cond.wait()<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&#x27;: 我找到你了哦 ~_~&#x27;</span>)<br>        self.cond.notify() <br><br>        self.cond.release()<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&#x27;: 我赢了&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seeker</span>(threading.Thread):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, cond, name</span>):<br>        <span class="hljs-built_in">super</span>(Seeker, self).__init__()<br>        self.cond = cond<br>        self.name = name<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        self.cond.acquire()<br>        self.cond.wait()<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&#x27;: 我已经藏好了，你快来找我吧&#x27;</span>)<br>        self.cond.notify()<br>        self.cond.wait()<br>        self.cond.release()<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&#x27;: 被你找到了，哎~~~&#x27;</span>)<br>        <br>cond = threading.Condition()<br>seeker = Seeker(cond, <span class="hljs-string">&#x27;seeker&#x27;</span>)<br>hider = Hider(cond, <span class="hljs-string">&#x27;hider&#x27;</span>)<br>seeker.start()<br>hider.start()<br></code></pre></td></tr></table></figure><p>通过cond来通信，阻塞自己，并使对方执行。从而，达到有顺序的执行。<br>看下结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">hider:   我已经把眼睛蒙上了<br>seeker:  我已经藏好了，你快来找我吧<br>hider:   我找到你了 ~_~<br>hider:   我赢了<br>seeker:  被你找到了，哎~~~<br></code></pre></td></tr></table></figure><h3 id="3-Queue队列"><a href="#3-Queue队列" class="headerlink" title="3. Queue队列"></a>3. Queue队列</h3><p>最后一个，队列，它是本节的重点，因为它是我们日常开发中最使用频率最高的。</p><p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 queue 库中的队列了。创建一个被多个线程共享的 Queue 对象，这些线程通过使用<code>put()</code> 和 <code>get()</code> 操作来向队列中发送和获取元素。 </p><p>同样，对于Queue，我们也只需要掌握几个函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-comment">## maxsize默认为0，不受限</span><br><span class="hljs-comment">## 一旦&gt;0，而消息数又达到限制，q.put()也将阻塞</span><br>q = Queue(maxsize=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">## 默认阻塞程序，等待队列消息，可设置超时时间</span><br>q.get(block=<span class="hljs-literal">True</span>, timeout=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment">## 发送消息：默认会阻塞程序至队列中有空闲位置放入数据</span><br>q.put(item, block=<span class="hljs-literal">True</span>, timeout=<span class="hljs-literal">None</span>)<br><br><span class="hljs-comment">## 等待所有的消息都被消费完</span><br>q.join()<br><br><br><span class="hljs-comment">## 通知队列任务处理已经完成，当所有任务都处理完成时，join() 阻塞将会解除</span><br>q.task_done()<br><br></code></pre></td></tr></table></figure><p>以下三个方法，知道就好，一般不需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 查询当前队列的消息个数</span><br>q.qsize()<br><br><span class="hljs-comment">## 队列消息是否都被消费完，返回 True/False</span><br>q.empty()<br><br><span class="hljs-comment">## 检测队列里消息是否已满</span><br>q.full()<br></code></pre></td></tr></table></figure><p>函数会比之前的多一些，同时也从另一方面说明了其功能更加丰富。</p><p>我来举个老师点名的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## coding=utf-8</span><br><span class="hljs-comment">## /usr/bin/env python</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Author: wangbm</span><br><span class="hljs-string">Email: wongbingming@163.com</span><br><span class="hljs-string">Wechat: mrbensonwon</span><br><span class="hljs-string">Blog: python-online.cn</span><br><span class="hljs-string">公众号：Python编程时光</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">date: 2020/9/20 下午7:30</span><br><span class="hljs-string">desc: </span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>__author__ = <span class="hljs-string">&#x27;wangbm&#x27;</span><br><br><br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;：到！&quot;</span>.<span class="hljs-built_in">format</span>(self.name))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, queue</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.queue=queue<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, student_name</span>):<br>        <span class="hljs-keyword">if</span> student_name == <span class="hljs-string">&quot;exit&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;点名结束，开始上课..&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;老师：&#123;&#125;来了没？&quot;</span>.<span class="hljs-built_in">format</span>(student_name))<br>            <span class="hljs-comment"># 发送消息，要点谁的名</span><br>        self.queue.put(student_name)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallManager</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, queue</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.students = &#123;&#125;<br>        self.queue = queue<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, student</span>):<br>        self.students.setdefault(student.name, student)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 阻塞程序，时刻监听老师，接收消息</span><br>            student_name = queue.get()<br>            <span class="hljs-keyword">if</span> student_name == <span class="hljs-string">&quot;exit&quot;</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> student_name <span class="hljs-keyword">in</span> self.students:<br>                self.students[student_name].speak()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;老师，咱班，没有 &#123;&#125; 这个人&quot;</span>.<span class="hljs-built_in">format</span>(student_name))<br><br>queue = Queue()<br>teacher = Teacher(queue=queue)<br><br>s1 = Student(name=<span class="hljs-string">&quot;小明&quot;</span>)<br>s2 = Student(name=<span class="hljs-string">&quot;小亮&quot;</span>)<br><br>cm = CallManager(queue)<br>cm.put(s1)<br>cm.put(s2)<br>cm.start()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;开始点名~&#x27;</span>)<br>teacher.call(<span class="hljs-string">&#x27;小明&#x27;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br>teacher.call(<span class="hljs-string">&#x27;小亮&#x27;</span>)<br>time.sleep(<span class="hljs-number">1</span>)<br>teacher.call(<span class="hljs-string">&quot;exit&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">开始点名~<br>老师：小明来了没？<br>小明：到！<br>老师：小亮来了没？<br>小亮：到！<br>点名结束，开始上课..<br></code></pre></td></tr></table></figure><p>其实 queue 还有一个很重要的方法，Queue.task_done()</p><p>如果不明白它的原理，我们在写程序，就很有可能卡死。</p><p>当我们使用 Queue.get() 从队列取出数据后，这个数据有没有被正常消费，是很重要的。</p><p>如果数据没有被正常消费，那么Queue会认为这个任务还在执行中，此时你使用 Queue.join() 会一直阻塞，即使此时你的队列里已经没有消息了。</p><p>那么如何解决这种一直阻塞的问题呢？</p><p>就是在我们正常消费完数据后，记得调用一下 Queue.task_done()，说明队列这个任务已经结束了。</p><p>当队列内部的任务计数器归于零时，调用 Queue.join() 就不会再阻塞了。</p><p>要理解这个过程，请参考 <a href="https://python.iswbm.com/c02/c02_06.html">https://python.iswbm.com/c02/c02_06.html</a> 里自定义线程池的的例子。</p><h3 id="4-消息队列的先进先出"><a href="#4-消息队列的先进先出" class="headerlink" title="4. 消息队列的先进先出"></a>4. 消息队列的先进先出</h3><p>消息队列可不是只有<code>queue.Queue</code>这一个类，除它之外，还有<code>queue.LifoQueue</code>和<code>queue.PriorityQueue</code>这两个类。</p><p>从名字上，对于他们之间的区别，你大概也能猜到一二吧。</p><blockquote><p><code>queue.Queue</code>：先进先出队列<br><code>queue.LifoQueue</code>：后进先出队列<br><code>queue.PriorityQueue</code>：优先级队列</p></blockquote><p>先来看看，我们的老朋友，<code>queue.Queue</code>。<br>所谓的<code>先进先出</code>（FIFO，First in First Out），就是先进入队列的消息，将优先被消费。<br>这和我们日常排队买菜是一样的，先排队的人肯定是先买到菜。</p><p>用代码来说明一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> queue<br><br>q = queue.Queue()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    q.put(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>    <span class="hljs-built_in">print</span> q.get()<br></code></pre></td></tr></table></figure><p>看看输出，符合我们先进先出的预期。存入队列的顺序是<code>01234</code>，被消费的顺序也是<code>01234</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><p>再来看看<code>Queue.LifoQueue</code>，后进先出，就是后进入消息队列的，将优先被消费。</p><p>这和我们羽毛球筒是一样的，最后放进羽毛球筒的球，会被第一个取出使用。</p><p>用代码来看下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> queue<br><br>q = queue.LifoQueue()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    q.put(i)<br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>    <span class="hljs-built_in">print</span> q.get()<br></code></pre></td></tr></table></figure><p>来看看输出，符合我们后进后出的预期。存入队列的顺序是<code>01234</code>，被消费的顺序也是<code>43210</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>3<br>2<br>1<br>0<br></code></pre></td></tr></table></figure><p>最后来看看<code>Queue.PriorityQueue</code>，优先级队列。<br>这和我们日常生活中的会员机制有些类似，办了金卡的人比银卡的服务优先，办了银卡的人比不办卡的人服务优先。</p><p>来用代码看一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> PriorityQueue<br><br><span class="hljs-comment">## 重新定义一个类，继承自PriorityQueue</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPriorityQueue</span>(<span class="hljs-title class_ inherited__">PriorityQueue</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        PriorityQueue.__init__(self)<br>        self.counter = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, item, priority</span>):<br>        PriorityQueue.put(self, (priority, self.counter, item))<br>        self.counter += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        _, _, item = PriorityQueue.get(self, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> item<br><br><br>queue = MyPriorityQueue()<br>queue.put(<span class="hljs-string">&#x27;item2&#x27;</span>, <span class="hljs-number">2</span>)<br>queue.put(<span class="hljs-string">&#x27;item5&#x27;</span>, <span class="hljs-number">5</span>)<br>queue.put(<span class="hljs-string">&#x27;item3&#x27;</span>, <span class="hljs-number">3</span>)<br>queue.put(<span class="hljs-string">&#x27;item4&#x27;</span>, <span class="hljs-number">4</span>)<br>queue.put(<span class="hljs-string">&#x27;item1&#x27;</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(queue.get())<br></code></pre></td></tr></table></figure><p>来看看输出，符合我们的预期。我们存入入队列的顺序是<code>25341</code>，对应的优先级也是<code>25341</code>，可是被消费的顺序丝毫不受传入顺序的影响，而是根据指定的优先级来消费。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">item1<br>item2<br>item3<br>item4<br>item5<br></code></pre></td></tr></table></figure><h3 id="5-总结一下"><a href="#5-总结一下" class="headerlink" title="5. 总结一下"></a>5. 总结一下</h3><p>学习了以上三种通信方法，我们很容易就能发现<code>Event</code> 和 <code>Condition</code> 是threading模块原生提供的模块，原理简单，功能单一，它能发送 <code>True</code> 和 <code>False</code> 的指令，所以只能适用于某些简单的场景中。</p><p>而<code>Queue</code>则是比较高级的模块，它可能发送任何类型的消息，包括字符串、字典等。其内部实现其实也引用了<code>Condition</code>模块（譬如<code>put</code>和<code>get</code>函数的阻塞），正是其对<code>Condition</code>进行了功能扩展，所以功能更加丰富，更能满足实际应用。</p><h2 id="10-5-【并发编程】线程中的信息隔离"><a href="#10-5-【并发编程】线程中的信息隔离" class="headerlink" title="10.5 【并发编程】线程中的信息隔离"></a>10.5 【并发编程】线程中的信息隔离</h2><p>上一篇我们说，线程与线程之间要通过消息通信来控制程序的执行。</p><p>讲完了消息通信，今天就来探讨下线程里的<code>信息隔离</code>是如何做到的。</p><h3 id="1-初步认识信息隔离"><a href="#1-初步认识信息隔离" class="headerlink" title="1. 初步认识信息隔离"></a>1. 初步认识信息隔离</h3><p>什么是<code>信息隔离</code>？</p><p>比如说，咱有两个线程，线程A里的变量，和线程B里的变量值不能共享。这就是<code>信息隔离</code>。</p><p>你可能要说，那变量名取不一样不就好啦？</p><p>是的，如果所有的线程都不是由一个class实例化出来的同一个对象，确实是可以。这个问题我们暂且挂着，后面我再说明。</p><p>那么，如何实现<code>信息隔离</code>呢？</p><p>在Python中，其提供了<code>threading.local</code>这个类，可以很方便的控制变量的隔离，即使是同一个变量，在不同的线程中，其值也是不能共享的。</p><p>用代码来看下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> local, Thread, currentThread<br><br><span class="hljs-comment">## 定义一个local实例</span><br>local_data = local()<br><span class="hljs-comment">## 在主线中，存入name这个变量</span><br>local_data.name = <span class="hljs-string">&#x27;local_data&#x27;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;赋值前-子线程：&quot;</span>, currentThread(),local_data.__dict__)<br>        <span class="hljs-comment"># 在子线程中存入name这个变量</span><br>        local_data.name = self.getName()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;赋值后-子线程：&quot;</span>,currentThread(), local_data.__dict__)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始前-主线程：&quot;</span>,local_data.__dict__)<br><br>    t1 = MyThread()<br>    t1.start()<br>    t1.join()<br><br>    t2 = MyThread()<br>    t2.start()<br>    t2.join()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束后-主线程：&quot;</span>,local_data.__dict__)<br></code></pre></td></tr></table></figure><p>来看看输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">开始前-主线程： &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;local_data&#x27;</span>&#125;<br><br>赋值前-子线程： &lt;MyThread(Thread-<span class="hljs-number">1</span>, started <span class="hljs-number">4832</span>)&gt; &#123;&#125;<br>赋值后-子线程： &lt;MyThread(Thread-<span class="hljs-number">1</span>, started <span class="hljs-number">4832</span>)&gt; &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Thread-1&#x27;</span>&#125;<br><br>赋值前-子线程： &lt;MyThread(Thread-<span class="hljs-number">2</span>, started <span class="hljs-number">5616</span>)&gt; &#123;&#125;<br>赋值后-子线程： &lt;MyThread(Thread-<span class="hljs-number">2</span>, started <span class="hljs-number">5616</span>)&gt; &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Thread-2&#x27;</span>&#125;<br><br>结束后-主线程： &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;local_data&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>从输出来看，我们可以知道，<code>local</code>实际是一个<code>字典型</code>的对象，其内部可以以<code>key-value</code>的形式存入你要做信息隔离的变量。local实例可以是<code>全局唯一</code>的，只有一个。因为你在给local存入或访问变量时，它会根据当前的线程的不同从不同的<code>存储空间</code>存入或获取。</p><p>基于此，我们可以得出以下三点结论：</p><blockquote><ol><li>主线程中的变量，不会因为其是全局变量，而被子线程获取到；</li><li>主线程也不能获取到子线程中的变量；</li><li>子线程与子线程之间的变量也不能互相访问。</li></ol></blockquote><p>所以如果想在当前线程保存一个全局值，并且各自线程（包括主线程）互不干扰，使用local类吧。</p><h3 id="2-信息隔离的意义何在"><a href="#2-信息隔离的意义何在" class="headerlink" title="2. 信息隔离的意义何在"></a>2. 信息隔离的意义何在</h3><p>细心的你，一定已经发现了，上面那个例子，即使我们不用<code>threading.local</code>来做信息隔离，两个线程<code>self.getName()</code>本身就是隔离的，没有任何关系的。因为这两个线程是由一个class实例出的两个不同的实例对象。自然是可以不用做隔离，因为其本身就是隔离的。</p><p>但是，现实开发中。不可排除有多个线程，是由一个class实例出的同一个实例对象而实现的。</p><p>譬如，现在新手特别喜欢的爬虫项目。通常都是先给爬虫一个主页，然后获取主页下的所有链接，对这个链接再进行遍历，一直往下，直到把所有的链接都爬完，获取到我们所需的内容。</p><p>由于单线程的爬取效率实在是太低了，我们考虑使用多线程来工作。先使用<code>socket</code>和<code>www.sina.con.cn</code>建立一个TCP连接。然后在这个连接的基础上，对主页上的每个链接（我们这里只举<code>news.sina.com.cn</code>和<code>blog.sina.com.cn</code>这两个子链接做例子）创建一个线程，这样效率就高多了。</p><blockquote><p><strong>友情提醒</strong>：<br>以下代码，若要理解，可能需要你了解下socket的网络编程相关内容。我在前几天的文章中有发布一篇相关的文章，没有基础的同学可以先去看看那篇文章。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> socket, AF_INET, SOCK_STREAM<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyConnection</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, address, family=AF_INET, <span class="hljs-built_in">type</span>=SOCK_STREAM</span>):<br>        self.address = address<br>        self.family = AF_INET<br>        self.<span class="hljs-built_in">type</span> = SOCK_STREAM<br>        self.local = threading.local()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self.local, <span class="hljs-string">&#x27;sock&#x27;</span>):<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;Already connected&#x27;</span>)<br>        <span class="hljs-comment"># 把socket连接存入local中</span><br>        self.local.sock = socket(self.family, self.<span class="hljs-built_in">type</span>)<br>        self.local.sock.connect(self.address)<br>        <span class="hljs-keyword">return</span> self.local.sock<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_ty, exc_val, tb</span>):<br>        self.local.sock.close()<br>        <span class="hljs-keyword">del</span> self.local.sock<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">conn, website</span>):<br>    <span class="hljs-keyword">with</span> conn <span class="hljs-keyword">as</span> s:<br>        header = <span class="hljs-string">&#x27;GET / HTTP/1.1\r\nHost: &#123;&#125;\r\nConnection: close\r\n\r\n&#x27;</span>.<span class="hljs-built_in">format</span>(website)<br>        s.send(header.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>        resp = <span class="hljs-string">b&#x27;&#x27;</span>.join(<span class="hljs-built_in">iter</span>(partial(s.recv, <span class="hljs-number">100000</span>), <span class="hljs-string">b&#x27;&#x27;</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Got &#123;&#125; bytes&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(resp)))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 建立一个TCP连接</span><br>    conn = LazyConnection((<span class="hljs-string">&#x27;www.sina.com.cn&#x27;</span>, <span class="hljs-number">80</span>))<br><br>    <span class="hljs-comment"># 爬取两个页面</span><br>    t1 = threading.Thread(target=spider, args=(conn,<span class="hljs-string">&quot;news.sina.com.cn&quot;</span>))<br>    t2 = threading.Thread(target=spider, args=(conn,<span class="hljs-string">&quot;blog.sina.com.cn&quot;</span>))<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Got <span class="hljs-number">765</span> <span class="hljs-built_in">bytes</span><br>Got <span class="hljs-number">513469</span> <span class="hljs-built_in">bytes</span><br></code></pre></td></tr></table></figure><p>如果是在这种场景下，要做到线程之间的状态信息的隔离，就肯定要借助<code>threading.local</code>，所以<code>threading.local</code>的存在是有存在的意义的。其他还有很多场景是必须借助<code>threading.local</code>才能实现的，而这些就要靠你们在真正的业务开发中去发现咯。</p><h2 id="10-6-【并发编程】线程池创建的几种方法"><a href="#10-6-【并发编程】线程池创建的几种方法" class="headerlink" title="10.6 【并发编程】线程池创建的几种方法"></a>10.6 【并发编程】线程池创建的几种方法</h2><h3 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1. 线程池的创建"></a>1. 线程池的创建</h3><h4 id="使用内置模块"><a href="#使用内置模块" class="headerlink" title="使用内置模块"></a>使用内置模块</h4><p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成cpu的大量开销。为解决这个问题，线程池的概念被提出来了。预先创建好一个合理数量的线程池，让过来的任务立刻能够使用，就形成了线程池。</p><p>在Python3中，创建线程池是通过<code>concurrent.futures</code>函数库中的<code>ThreadPoolExecutor</code>类来实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running thread-&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(threading.get_ident(), i))<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <br><span class="hljs-comment">## 创建一个最大容纳数量为5的线程池</span><br>pool = ThreadPoolExecutor(<span class="hljs-number">5</span>) <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>  <span class="hljs-comment"># 往线程池上塞任务</span><br>    pool.submit(target)<br></code></pre></td></tr></table></figure><p>创建线程池还可以使用更优雅的方式，就是使用上下文管理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> ThreadPoolExecutor(<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> pool:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        pool.submit(target) <br></code></pre></td></tr></table></figure><p>直接运行代码，从输出可以看出，前面我们设置线程池最大线程数，会保证“同时”仅有五个线程在工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">running thread-<span class="hljs-number">123145483767808</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145489022976</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145494278144</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145499533312</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145504788480</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145483767808</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145489022976</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145499533312</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145494278144</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145504788480</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145489022976</span>:<span class="hljs-number">2</span><br>running thread-<span class="hljs-number">123145499533312</span>:<span class="hljs-number">2</span><br>running thread-<span class="hljs-number">123145483767808</span>:<span class="hljs-number">2</span><br>running thread-<span class="hljs-number">123145504788480</span>:<span class="hljs-number">2</span><br>running thread-<span class="hljs-number">123145494278144</span>:<span class="hljs-number">2</span><br>....<br></code></pre></td></tr></table></figure><p>示例完毕，来说明一下：</p><ol><li><p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</p></li><li><p>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</p></li><li><p>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</p></li><li><p>使用 result() 方法可以获取任务的返回值。</p></li></ol><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>除了使用上述第三方模块的方法之外，我们还可以自己结合前面所学的消息队列来自定义线程池。</p><p>这里我们就使用queue来实现一个上面同样效果的例子，大家感受一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>(<span class="hljs-params">queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        task = queue.get()<br>        <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;stop&quot;</span>:<br>            queue.task_done()<br>            <span class="hljs-keyword">break</span><br><br>        task()<br>        queue.task_done()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_task</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running thread-&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(threading.get_ident(), i))<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span>(<span class="hljs-title class_ inherited__">Queue</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.maxsize):<br>            self.put(<span class="hljs-string">&quot;stop&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">custome_pool</span>(<span class="hljs-params">task_func, max_workers</span>):<br>    queue = MyQueue(max_workers)<br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_workers):<br>        t = threading.Thread(target=task_func, args=(queue,))<br>        t.daemon = <span class="hljs-literal">True</span><br>        t.start()<br><br>    <span class="hljs-keyword">return</span> queue<br><br><br><br>pool = custome_pool(task_func=target, max_workers=<span class="hljs-number">5</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    pool.put(do_task)<br><br>pool.close()<br>pool.join()<br></code></pre></td></tr></table></figure><p>输出是和上面是完全一样的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">running thread-<span class="hljs-number">123145469886464</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145475141632</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145485651968</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145490907136</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145480396800</span>:<span class="hljs-number">0</span><br>running thread-<span class="hljs-number">123145469886464</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145480396800</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145475141632</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145490907136</span>:<span class="hljs-number">1</span><br>running thread-<span class="hljs-number">123145485651968</span>:<span class="hljs-number">1</span><br>...<br></code></pre></td></tr></table></figure><p>构建线程池的方法，是可以很灵活的，大家有空可以自己多研究。但是建议只要掌握一种自己熟悉的，能快速上手的就好了。</p><h2 id="10-7-【并发编程】从-yield-开始入门协程"><a href="#10-7-【并发编程】从-yield-开始入门协程" class="headerlink" title="10.7 【并发编程】从 yield 开始入门协程"></a>10.7 【并发编程】从 yield 开始入门协程</h2><h3 id="简单介绍-yield"><a href="#简单介绍-yield" class="headerlink" title="简单介绍 yield"></a>简单介绍 yield</h3><p>本篇文章会先向你介绍一个陌生的 Python 关键词，他和 <code>return</code> 就像一对新兄弟，有相似之处，又各有不同。</p><ul><li><p><strong>相似的是</strong>：yield 和 return 都可以在一个函数里将值返回给调用方；</p></li><li><p><strong>不同的是</strong>：return 后，函数运行就终止了，而 yield 则只是暂停运行。</p></li></ul><p>关于 yield 的简单使用，请先看如下例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen = demo()<br><span class="hljs-meta">&gt;&gt;&gt; </span>gen<br>&lt;generator <span class="hljs-built_in">object</span> demo at <span class="hljs-number">0x10a9f5970</span>&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen:<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i)<br>...<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>重点有如下几个：</p><ol><li>含有 yield 的函数，不再是普通的函数，直接调用含有 yield 的函数，返回的是一个生成器对象（generator object）</li><li>可以使用 for 循环（实际还可以使用 list 或者 next 函数）来遍历该生成器对象，将 yield 的内容一个一个打印出来</li></ol><p>更多关于 yield 和生成器的内容，请前往前面的文章，里面有非常详细的讲解：<a href="http://python.iswbm.com/c03/c03_06.html">3.6 【基础】生成器</a></p><h3 id="向生成器中发送消息"><a href="#向生成器中发送消息" class="headerlink" title="向生成器中发送消息"></a>向生成器中发送消息</h3><p>函数暂停之后，如果调用者能在下一次恢复函数运行的时候，向它传递一些信息，那么整个程序的灵活性会大大提升。</p><p>下面通过一个简明的演示来看看，如何往生成器中发送消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">jumping_range</span>(<span class="hljs-params">N</span>):<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> index &lt; N:<br>        <span class="hljs-comment"># 通过send()发送的信息将赋值给jump</span><br>        jump = <span class="hljs-keyword">yield</span> index<br>        <span class="hljs-keyword">if</span> jump <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            jump = <span class="hljs-number">1</span><br>        index += jump<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    itr = jumping_range(<span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(itr))<br>    <span class="hljs-built_in">print</span>(itr.send(<span class="hljs-number">2</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(itr))<br>    <span class="hljs-built_in">print</span>(itr.send(-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>输出。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>2<br>3<br>2<br></code></pre></td></tr></table></figure><p>这里解释下为什么这么输出。<br>重点是<code>jump = yield index</code>这个语句。</p><p>分成两部分：</p><ul><li><code>yield index</code> 是将index <code>return</code>给外部调用程序。</li><li><code>jump = yield</code> 可以接收外部程序通过send()发送的信息，并赋值给<code>jump</code></li></ul><p>下一节，我将讲一个Python3.5新引入的语法：<code>yield from</code>。篇幅也比较多，所以就单独拿出来讲。<br><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="10-8-【并发编程】深入理解yield-from语法"><a href="#10-8-【并发编程】深入理解yield-from语法" class="headerlink" title="10.8 【并发编程】深入理解yield from语法"></a>10.8 【并发编程】深入理解yield from语法</h2><h3 id="1-为什么要使用协程"><a href="#1-为什么要使用协程" class="headerlink" title="1. 为什么要使用协程"></a>1. 为什么要使用协程</h3><p>在上一篇中，我们从生成器的基本认识与使用，成功过渡到了协程。</p><p>但一定有许多人，只知道协程是个什么东西，但并不知道为什么要用协程？换句话来说，并不知道在什么情况下用协程？<br>它相比多线程来说，有哪些过人之处呢？</p><p>在开始讲<code>yield from</code> 之前，我想先解决一下这个给很多人带来困惑的问题。</p><p>举个例子。<br>假如我们做一个爬虫。我们要爬取多个网页，这里简单举例两个网页(两个spider函数)，获取HTML（耗IO耗时），然后再对HTML对行解析取得我们感兴趣的数据。</p><p>我们的代码结构精简如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider_01</span>(<span class="hljs-params">url</span>):<br>    html = get_html(url)<br>    ...<br>    data = parse_html(html)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider_02</span>(<span class="hljs-params">url</span>):<br>    html = get_html(url)<br>    ...<br>    data = parse_html(html)<br></code></pre></td></tr></table></figure><p>我们都知道，<code>get_html()</code>等待返回网页是非常耗IO的，一个网页还好，如果我们爬取的网页数据极其庞大，这个等待时间就非常惊人，是极大的浪费。</p><p>聪明的程序员，当然会想如果能在<code>get_html()</code>这里暂停一下，不用傻乎乎地去等待网页返回，而是去做别的事。等过段时间再回过头来到刚刚暂停的地方，接收返回的html内容，然后还可以接下去解析<code>parse_html(html)</code>。</p><p>利用常规的方法，几乎是没办法实现如上我们想要的效果的。所以Python想得很周到，从语言本身给我们实现了这样的功能，这就是<code>yield</code>语法。可以实现在某一函数中暂停的效果。</p><p>试着思考一下，假如没有协程，我们要写一个并发程序。可能有以下问题</p><ol><li>使用最常规的同步编程要实现异步并发效果并不理想，或者难度极高。</li><li>由于GIL锁的存在，多线程的运行需要频繁的加锁解锁，切换线程，这极大地降低了并发性能；</li></ol><p>而协程的出现，刚好可以解决以上的问题。它的特点有</p><ol><li>协程是在单线程里实现任务的切换的</li><li>利用同步的方式去实现异步</li><li>不再需要锁，提高了并发性能</li></ol><h3 id="2-yield-from的用法详解"><a href="#2-yield-from的用法详解" class="headerlink" title="2. yield from的用法详解"></a>2. yield from的用法详解</h3><p><code>yield from</code> 是在Python3.3才出现的语法。所以这个特性在Python2中是没有的。</p><p><code>yield from</code> 后面需要加的是可迭代对象，它可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。</p><h4 id="2-1-简单应用：拼接可迭代对象"><a href="#2-1-简单应用：拼接可迭代对象" class="headerlink" title="2.1 简单应用：拼接可迭代对象"></a>2.1 简单应用：拼接可迭代对象</h4><p>我们可以用一个使用<code>yield</code>和一个使用<code>yield from</code>的例子来对比看下。</p><p>使用<code>yield</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 字符串</span><br>astr=<span class="hljs-string">&#x27;ABC&#x27;</span><br><span class="hljs-comment">## 列表</span><br>alist=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">## 字典</span><br>adict=&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;wangbm&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">## 生成器</span><br>agen=(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">*args, **kw</span>):<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> item:<br>            <span class="hljs-keyword">yield</span> i<br><br>new_list=gen(astr, alist, adict, agen)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(new_list))<br><span class="hljs-comment">## [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, &#x27;name&#x27;, &#x27;age&#x27;, 4, 5, 6, 7]</span><br></code></pre></td></tr></table></figure><p>使用<code>yield from</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 字符串</span><br>astr=<span class="hljs-string">&#x27;ABC&#x27;</span><br><span class="hljs-comment">## 列表</span><br>alist=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">## 字典</span><br>adict=&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;wangbm&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>&#125;<br><span class="hljs-comment">## 生成器</span><br>agen=(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>(<span class="hljs-params">*args, **kw</span>):<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> args:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> item<br><br>new_list=gen(astr, alist, adict, agen)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(new_list))<br><span class="hljs-comment">## [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3, &#x27;name&#x27;, &#x27;age&#x27;, 4, 5, 6, 7]</span><br></code></pre></td></tr></table></figure><p>由上面两种方式对比，可以看出，yield from后面加上可迭代对象，他可以把可迭代对象里的每个元素一个一个的yield出来，对比yield来说代码更加简洁，结构更加清晰。</p><h4 id="2-2-复杂应用：生成器的嵌套"><a href="#2-2-复杂应用：生成器的嵌套" class="headerlink" title="2.2 复杂应用：生成器的嵌套"></a>2.2 复杂应用：生成器的嵌套</h4><p>如果你认为只是 <code>yield from</code> 仅仅只有上述的功能的话，那你就太小瞧了它，它的更强大的功能还在后面。</p><p>当 <code>yield from</code> 后面加上一个生成器后，就实现了生成的嵌套。</p><p>当然实现生成器的嵌套，并不是一定必须要使用<code>yield from</code>，而是使用<code>yield from</code>可以让我们避免让我们自己处理各种料想不到的异常，而让我们专注于业务代码的实现。</p><p>如果自己用<code>yield</code>去实现，那只会加大代码的编写难度，降低开发效率，降低代码的可读性。既然Python已经想得这么周到，我们当然要好好利用起来。</p><p>讲解它之前，首先要知道这个几个概念</p><blockquote><p>1、<code>调用方</code>：调用委派生成器的客户端（调用方）代码<br>2、<code>委托生成器</code>：包含yield from表达式的生成器函数<br>3、<code>子生成器</code>：yield from后面加的生成器函数</p></blockquote><p>你可能不知道他们都是什么意思，没关系，来看下这个例子。</p><p>这个例子，是实现实时计算平均值的。<br>比如，第一次传入10，那返回平均数自然是10.<br>第二次传入20，那返回平均数是(10+20)&#x2F;2&#x3D;15<br>第三次传入30，那返回平均数(10+20+30)&#x2F;3&#x3D;20</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 子生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">average_gen</span>():<br>    total = <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_num = <span class="hljs-keyword">yield</span> average<br>        count += <span class="hljs-number">1</span><br>        total += new_num<br>        average = total/count<br><br><span class="hljs-comment">## 委托生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy_gen</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> average_gen()<br><br><span class="hljs-comment">## 调用方</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    calc_average = proxy_gen()<br>    <span class="hljs-built_in">next</span>(calc_average)            <span class="hljs-comment"># 预激下生成器</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 打印：10.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">20</span>))  <span class="hljs-comment"># 打印：15.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">30</span>))  <span class="hljs-comment"># 打印：20.0</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>认真阅读以上代码，你应该很容易能理解，调用方、委托生成器、子生成器之间的关系。我就不多说了</p><p><strong>委托生成器的作用是</strong>：在调用方与子生成器之间建立一个<code>双向通道</code>。</p><p>所谓的双向通道是什么意思呢？<br>调用方可以通过<code>send()</code>直接发送消息给子生成器，而子生成器yield的值，也是直接返回给调用方。</p><p>你可能会经常看到有些代码，还可以在<code>yield from</code>前面看到可以赋值。这是什么用法？</p><p>你可能会以为，子生成器yield回来的值，被委托生成器给拦截了。你可以亲自写个demo运行试验一下，并不是你想的那样。<br>因为我们之前说了，委托生成器，只起一个桥梁作用，它建立的是一个<code>双向通道</code>，它并没有权利也没有办法，对子生成器yield回来的内容做拦截。</p><p>为了解释这个用法，我还是用上述的例子，并对其进行了一些改造。添加了一些注释，希望你能看得明白。</p><p>按照惯例，我们还是举个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 子生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">average_gen</span>():<br>    total = <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_num = <span class="hljs-keyword">yield</span> average<br>        <span class="hljs-keyword">if</span> new_num <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        count += <span class="hljs-number">1</span><br>        total += new_num<br>        average = total/count<br><br>    <span class="hljs-comment"># 每一次return，都意味着当前协程结束。</span><br>    <span class="hljs-keyword">return</span> total,count,average<br><br><span class="hljs-comment">## 委托生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy_gen</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 只有子生成器要结束（return）了，yield from左边的变量才会被赋值，后面的代码才会执行。</span><br>        total, count, average = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> average_gen()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算完毕！！\n总共传入 &#123;&#125; 个数值， 总和：&#123;&#125;，平均数：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(count, total, average))<br><br><span class="hljs-comment">## 调用方</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    calc_average = proxy_gen()<br>    <span class="hljs-built_in">next</span>(calc_average)            <span class="hljs-comment"># 预激协程</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 打印：10.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">20</span>))  <span class="hljs-comment"># 打印：15.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">30</span>))  <span class="hljs-comment"># 打印：20.0</span><br>    calc_average.send(<span class="hljs-literal">None</span>)      <span class="hljs-comment"># 结束协程</span><br>    <span class="hljs-comment"># 如果此处再调用calc_average.send(10)，由于上一协程已经结束，将重开一协程</span><br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>运行后，输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10.0</span><br><span class="hljs-number">15.0</span><br><span class="hljs-number">20.0</span><br>计算完毕！！<br>总共传入 <span class="hljs-number">3</span> 个数值， 总和：<span class="hljs-number">60</span>，平均数：<span class="hljs-number">20.0</span><br></code></pre></td></tr></table></figure><h3 id="3-为什么要使用yield-from"><a href="#3-为什么要使用yield-from" class="headerlink" title="3. 为什么要使用yield from"></a>3. 为什么要使用yield from</h3><p>学到这里，我相信你肯定要问，既然委托生成器，起到的只是一个双向通道的作用，我还需要委托生成器做什么？我调用方直接调用子生成器不就好啦？</p><p>高能预警~~~</p><p>下面我们来一起探讨一下，到底yield from 有什么过人之处，让我们非要用它不可。</p><h4 id="3-1-因为它可以帮我们处理异常"><a href="#3-1-因为它可以帮我们处理异常" class="headerlink" title="3.1 因为它可以帮我们处理异常"></a>3.1 因为它可以帮我们处理异常</h4><p>如果我们去掉委托生成器，而直接调用子生成器。那我们就需要把代码改成像下面这样，我们需要自己捕获异常并处理。而不像使<code>yield from</code>那样省心。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 子生成器</span><br><span class="hljs-comment">## 子生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">average_gen</span>():<br>    total = <span class="hljs-number">0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        new_num = <span class="hljs-keyword">yield</span> average<br>        <span class="hljs-keyword">if</span> new_num <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">break</span><br>        count += <span class="hljs-number">1</span><br>        total += new_num<br>        average = total/count<br>    <span class="hljs-keyword">return</span> total,count,average<br><br><span class="hljs-comment">## 调用方</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    calc_average = average_gen()<br>    <span class="hljs-built_in">next</span>(calc_average)            <span class="hljs-comment"># 预激协程</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 打印：10.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">20</span>))  <span class="hljs-comment"># 打印：15.0</span><br>    <span class="hljs-built_in">print</span>(calc_average.send(<span class="hljs-number">30</span>))  <span class="hljs-comment"># 打印：20.0</span><br><br>    <span class="hljs-comment"># ----------------注意-----------------</span><br>    <span class="hljs-keyword">try</span>:<br>        calc_average.send(<span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:<br>        total, count, average = e.value<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算完毕！！\n总共传入 &#123;&#125; 个数值， 总和：&#123;&#125;，平均数：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(count, total, average))<br>    <span class="hljs-comment"># ----------------注意-----------------</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>此时的你，可能会说，不就一个<code>StopIteration</code>的异常吗？自己捕获也没什么大不了的。</p><p>你要是知道<code>yield from</code>在背后为我们默默无闻地做了哪些事，你就不会这样说了。</p><p>具体<code>yield from</code>为我们做了哪些事，可以参考如下这段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一些说明</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">_i：子生成器，同时也是一个迭代器</span><br><span class="hljs-string">_y：子生成器生产的值</span><br><span class="hljs-string">_r：yield from 表达式最终的值</span><br><span class="hljs-string">_s：调用方通过send()发送的值</span><br><span class="hljs-string">_e：异常对象</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>_i = <span class="hljs-built_in">iter</span>(EXPR)<br><br><span class="hljs-keyword">try</span>:<br>    _y = <span class="hljs-built_in">next</span>(_i)<br><span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> _e:<br>    _r = _e.value<br><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">try</span>:<br>            _s = <span class="hljs-keyword">yield</span> _y<br>        <span class="hljs-keyword">except</span> GeneratorExit <span class="hljs-keyword">as</span> _e:<br>            <span class="hljs-keyword">try</span>:<br>                _m = _i.close<br>            <span class="hljs-keyword">except</span> AttributeError:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                _m()<br>            <span class="hljs-keyword">raise</span> _e<br>        <span class="hljs-keyword">except</span> BaseException <span class="hljs-keyword">as</span> _e:<br>            _x = sys.exc_info()<br>            <span class="hljs-keyword">try</span>:<br>                _m = _i.throw<br>            <span class="hljs-keyword">except</span> AttributeError:<br>                <span class="hljs-keyword">raise</span> _e<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    _y = _m(*_x)<br>                <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> _e:<br>                    _r = _e.value<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-keyword">if</span> _s <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    _y = <span class="hljs-built_in">next</span>(_i)<br>                <span class="hljs-keyword">else</span>:<br>                    _y = _i.send(_s)<br>            <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> _e:<br>                _r = _e.value<br>                <span class="hljs-keyword">break</span><br>RESULT = _r<br></code></pre></td></tr></table></figure><p>以上的代码，稍微有点复杂，有兴趣的同学可以结合以下说明去研究看看。</p><ol><li>迭代器（即可指子生成器）产生的值直接返还给调用者</li><li>任何使用send()方法发给委派生产器（即外部生产器）的值被直接传递给迭代器。如果send值是None，则调用迭代器next()方法；如果不为None，则调用迭代器的send()方法。如果对迭代器的调用产生StopIteration异常，委派生产器恢复继续执行yield from后面的语句；若迭代器产生其他任何异常，则都传递给委派生产器。</li><li>子生成器可能只是一个迭代器，并不是一个作为协程的生成器，所以它不支持.throw()和.close()方法,即可能会产生AttributeError 异常。</li><li>除了GeneratorExit 异常外的其他抛给委派生产器的异常，将会被传递到迭代器的throw()方法。如果迭代器throw()调用产生了StopIteration异常，委派生产器恢复并继续执行，其他异常则传递给委派生产器。</li><li>如果GeneratorExit异常被抛给委派生产器，或者委派生产器的close()方法被调用，如果迭代器有close()的话也将被调用。如果close()调用产生异常，异常将传递给委派生产器。否则，委派生产器将抛出GeneratorExit 异常。</li><li>当迭代器结束并抛出异常时，yield from表达式的值是其StopIteration 异常中的第一个参数。</li><li>一个生成器中的return expr语句将会从生成器退出并抛出 StopIteration(expr)异常。</li></ol><p>没兴趣看的同学，只要知道，<code>yield from</code>帮我们做了很多的异常处理，而且全面，而这些如果我们要自己去实现的话，一个是编写代码难度增加，写出来的代码可读性极差，这些我们就不说了，最主要的是很可能有遗漏，只要哪个异常没考虑到，都有可能导致程序崩溃什么的</p><h2 id="10-9-【并发编程】初识异步IO框架：asyncio-上篇"><a href="#10-9-【并发编程】初识异步IO框架：asyncio-上篇" class="headerlink" title="10.9 【并发编程】初识异步IO框架：asyncio 上篇"></a>10.9 【并发编程】初识异步IO框架：asyncio 上篇</h2><p>通过前两节的铺垫（关于协程的使用），今天我们终于可以来介绍我们整个系列的重点 – <code>asyncio</code>。</p><p><code>asyncio</code>是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p><p>有些同学，可能很疑惑，既然有了以生成器为基础的协程，我们直接使用<code>yield</code> 和 <code>yield from</code> 不就可以手动实现对IO的调度了吗？ 为何Python吃饱了没事干，老重复造轮子。</p><p>这个问题很好回答，就跟为什么会有<code>Django</code>，为什么会有<code>Scrapy</code>，是一个道理。</p><p>他们都是框架，将很多很重复性高，复杂度高的工作，提前给你做好，这样你就可以专注于业务代码的研发。</p><p>跟着小明学完了协程的那些个难点，你是不是也发现了，协程的知识点我已经掌握了，但是我还是不知道怎么用，如何使用，都说它可以实现并发，但是我还是不知道如何入手？</p><p>那是因为，我们现在还缺少一个成熟的框架，帮助你完成那些复杂的动作。这个时候，<code>ayncio</code>就这么应运而生了。</p><h3 id="1-如何定义-x2F-创建协程"><a href="#1-如何定义-x2F-创建协程" class="headerlink" title="1. 如何定义&#x2F;创建协程"></a>1. 如何定义&#x2F;创建协程</h3><p>还记得在前两章节的时候，我们创建了生成器，是如何去检验我们创建的是不是生成器对象吗？</p><p>我们是借助了<code>isinstance()</code>函数，来判断是否是<code>collections.abc</code> 里的<code>Generator</code>类的子类实现的。</p><p>同样的方法，我们也可以用在这里。</p><p>只要在一个函数前面加上 <code>async</code> 关键字，这个函数对象是一个协程，通过<code>isinstance</code>函数，它确实是<code>Coroutine</code>类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> <span class="hljs-type">Coroutine</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello,&#x27;</span>, name)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成协程对象，并不会运行函数内的代码</span><br>    coroutine = hello(<span class="hljs-string">&quot;World&quot;</span>)<br><br>    <span class="hljs-comment"># 检查是否是协程 Coroutine 类型</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(coroutine, <span class="hljs-type">Coroutine</span>))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>前两节，我们说，生成器是协程的基础，那我们是不是有办法，将一个生成器，直接变成协程使用呢。答案是有的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Generator, <span class="hljs-type">Coroutine</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">只要在一个生成器函数头部用上 @asyncio.coroutine 装饰器</span><br><span class="hljs-string">就能将这个函数对象，【标记】为协程对象。注意这里是【标记】，划重点。</span><br><span class="hljs-string">实际上，它的本质还是一个生成器。</span><br><span class="hljs-string">标记后，它实际上已经可以当成协程使用。后面会介绍。</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><br><span class="hljs-meta">@asyncio.coroutine</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-comment"># 异步调用asyncio.sleep(1):</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    coroutine = hello()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(coroutine, Generator))  <span class="hljs-comment"># True</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(coroutine, <span class="hljs-type">Coroutine</span>))  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h3 id="2-asyncio的几个概念"><a href="#2-asyncio的几个概念" class="headerlink" title="2. asyncio的几个概念"></a>2. asyncio的几个概念</h3><p>在了解<code>asyncio</code>的使用方法前，首先有必要先介绍一下，这几个贯穿始终的概念。</p><ul><li><code>event_loop 事件循环</code>：程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</li><li><code>coroutine 协程</code>：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</li><li><code>future 对象</code>： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</li><li><code>task 任务</code>：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。Task 对象是 Future 的子类，它将 coroutine 和 Future 联系在一起，将 coroutine 封装成一个 Future 对象。</li><li><code>async/await 关键字</code>：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。</li></ul><p>这几个概念，干看可能很难以理解，没事，往下看实例，然后再回来，我相信你一定能够理解。</p><h3 id="3-学习协程是如何工作的"><a href="#3-学习协程是如何工作的" class="headerlink" title="3. 学习协程是如何工作的"></a>3. 学习协程是如何工作的</h3><p>协程完整的工作流程是这样的</p><ul><li>定义&#x2F;创建协程对象</li><li>将协程转为task任务</li><li>定义事件循环对象容器</li><li>将task任务扔进事件循环对象中触发</li></ul><p>光说不练假把戏，一起来看下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello,&#x27;</span>, name)<br><br><span class="hljs-comment">## 定义协程对象</span><br>coroutine = hello(<span class="hljs-string">&quot;World&quot;</span>)<br><br><span class="hljs-comment">## 定义事件循环对象容器</span><br>loop = asyncio.get_event_loop()<br><span class="hljs-comment">## task = asyncio.ensure_future(coroutine)</span><br><br><span class="hljs-comment">## 将协程转为task任务</span><br>task = loop.create_task(coroutine)<br><br><span class="hljs-comment">## 将task任务扔进事件循环对象中并触发</span><br>loop.run_until_complete(task)<br></code></pre></td></tr></table></figure><p>输出结果，当然显而易见</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> World<br></code></pre></td></tr></table></figure><h3 id="4-await与yield对比"><a href="#4-await与yield对比" class="headerlink" title="4. await与yield对比"></a>4. await与yield对比</h3><p>前面我们说，<code>await</code>用于挂起阻塞的异步调用接口。其作用在<code>一定程度上</code>类似于yield。</p><p>注意这里是，一定程度上，意思是效果上一样（都能实现暂停的效果），但是功能上却不兼容。就是你不能在生成器中使用<code>await</code>，也不能在async 定义的协程中使用<code>yield from</code>。</p><p>小明不是胡说八道的。有实锤。<br><img src="https://i.loli.net/2018/05/26/5b09794f45340.png" alt="普通函数中 不能使用 await"><br>再来一锤。<br><img src="https://i.loli.net/2018/05/26/5b0978b646230.png" alt="async 中 不能使用yield"></p><p>除此之外呢，还有一点很重要的。</p><ul><li><code>yield from</code> 后面可接 <code>可迭代对象</code>，也可接<code>future对象</code>&#x2F;协程对象；</li><li><code>await</code> 后面必须要接 <code>future对象</code>&#x2F;<code>协程对象</code></li></ul><p>如何验证呢？</p><p><code>yield from</code> 后面可接 <code>可迭代对象</code>，这个前两章已经说过了，这里不再赘述。<br>接下来，就只要验证，<code>yield from</code>和<code>await</code>都可以接<code>future对象</code>&#x2F;<code>协程对象</code>就可以了。</p><p>验证之前呢，要先介绍一下这个函数：<br><code>asyncio.sleep(n)</code>，这货是asyncio自带的工具函数，他可以模拟IO阻塞，他返回的是一个协程对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">func = asyncio.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(func, Future))      <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(func, <span class="hljs-type">Coroutine</span>))   <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>还有，要学习如何创建<code>Future对象</code>，不然怎么验证。<br>前面概念里说过，Task是Future的子类，这么说，我们只要创建一个task对象即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> asyncio.futures <span class="hljs-keyword">import</span> Future<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span>, name)<br><br>coroutine = hello(<span class="hljs-string">&quot;World&quot;</span>)<br><br><span class="hljs-comment">## 将协程转为task对象</span><br>task = asyncio.ensure_future(coroutine)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(task, Future))   <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>好了，接下来，开始验证。<br><img src="https://i.loli.net/2018/05/26/5b09814dc4714.png" alt="验证通过"></p><h3 id="5-绑定回调函数"><a href="#5-绑定回调函数" class="headerlink" title="5. 绑定回调函数"></a>5. 绑定回调函数</h3><p>异步IO的实现原理，就是在IO高的地方挂起，等IO结束后，再继续执行。在绝大部分时候，我们后续的代码的执行是需要依赖IO的返回值的，这就要用到回调了。</p><p>回调的实现，有两种，一种是绝大部分程序员喜欢的，利用的同步编程实现的回调。<br>这就要求我们要能够有办法取得协程的await的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sleep</span>(<span class="hljs-params">x</span>):<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;暂停了&#123;&#125;秒！&#x27;</span>.<span class="hljs-built_in">format</span>(x)<br><br><br>coroutine = _sleep(<span class="hljs-number">2</span>)<br>loop = asyncio.get_event_loop()<br><br>task = asyncio.ensure_future(coroutine)<br>loop.run_until_complete(task)<br><br><span class="hljs-comment">## task.result() 可以取得返回结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;返回结果：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(task.result()))<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">返回结果：暂停了2秒！<br></code></pre></td></tr></table></figure><p>还有一种是通过asyncio自带的添加回调函数功能来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sleep</span>(<span class="hljs-params">x</span>):<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;暂停了&#123;&#125;秒！&#x27;</span>.<span class="hljs-built_in">format</span>(x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">future</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是回调函数，获取返回结果是：&#x27;</span>, future.result())<br><br>coroutine = _sleep(<span class="hljs-number">2</span>)<br>loop = asyncio.get_event_loop()<br>task = asyncio.ensure_future(coroutine)<br><br><span class="hljs-comment">## 添加回调函数</span><br>task.add_done_callback(callback)<br><br>loop.run_until_complete(task)<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">这里是回调函数，获取返回结果是： 暂停了<span class="hljs-number">2</span>秒！<br></code></pre></td></tr></table></figure><p>和上面的结果是一样的。非常好。</p><hr><h2 id="10-10-【并发编程】深入异步IO框架：asyncio-中篇"><a href="#10-10-【并发编程】深入异步IO框架：asyncio-中篇" class="headerlink" title="10.10 【并发编程】深入异步IO框架：asyncio 中篇"></a>10.10 【并发编程】深入异步IO框架：asyncio 中篇</h2><p>今天的内容其实还挺多的，我准备了三天，到今天才整理完毕。希望大家看完，有所收获的，能给小明一个赞。这就是对小明最大的鼓励了。<br>为了更好地衔接这一节，我们先来回顾一下上一节的内容。</p><p>上一节，我们首先介绍了，如何创建一个协程对象.<br>主要有两种方法</p><ul><li>通过<code>async</code>关键字，</li><li>通过<code>@asyncio.coroutine</code> 装饰函数。</li></ul><p>然后有了协程对象，就需要一个事件循环容器来运行我们的协程。其主要的步骤有如下几点：</p><ul><li>将协程对象转为task任务对象</li><li>定义一个事件循环对象容器用来存放task</li><li>将task任务扔进事件循环对象中并触发</li></ul><p>为了让大家，对生成器和协程有一个更加清晰的认识，我还介绍了<code>yield</code>和<code>async/await</code>的区别。</p><p>最后，我们还讲了，如何给一个协程添加回调函数。</p><p>好了，用个形象的比喻，上一节，其实就只是讲了协程中的<code>单任务</code>。哈哈，是不是还挺难的？希望大家一定要多看几遍，多敲代码，不要光看。</p><p>那么这一节，我们就来看下，协程中的<code>多任务</code>。</p><h3 id="1-协程中的并发"><a href="#1-协程中的并发" class="headerlink" title="1. 协程中的并发"></a>1. 协程中的并发</h3><p>协程的并发，和线程一样。举个例子来说，就好像 一个人同时吃三个馒头，咬了第一个馒头一口，就得等这口咽下去，才能去啃第其他两个馒头。就这样交替换着吃。</p><p><code>asyncio</code>实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作。</p><p>第一步，当然是创建多个协程的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_some_work</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting: &#x27;</span>, x)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(x)<br><br><span class="hljs-comment">## 协程对象</span><br>coroutine1 = do_some_work(<span class="hljs-number">1</span>)<br>coroutine2 = do_some_work(<span class="hljs-number">2</span>)<br>coroutine3 = do_some_work(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">## 将协程转成task，并组成list</span><br>tasks = [<br>    asyncio.ensure_future(coroutine1),<br>    asyncio.ensure_future(coroutine2),<br>    asyncio.ensure_future(coroutine3)<br>]<br></code></pre></td></tr></table></figure><p>第二步，如何将这些协程注册到事件循环中呢。</p><p>有两种方法，至于这两种方法什么区别，稍后会介绍。</p><ul><li><p>使用<code>asyncio.wait()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>asyncio.gather()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 千万注意，这里的 「*」 不能省略</span><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.gather(*tasks))<br></code></pre></td></tr></table></figure></li></ul><p>最后，return的结果，可以用<code>task.result()</code>查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, task.result())<br></code></pre></td></tr></table></figure><p>完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment">## 协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_some_work</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting: &#x27;</span>, x)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(x)<br><br><span class="hljs-comment">## 协程对象</span><br>coroutine1 = do_some_work(<span class="hljs-number">1</span>)<br>coroutine2 = do_some_work(<span class="hljs-number">2</span>)<br>coroutine3 = do_some_work(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">## 将协程转成task，并组成list</span><br>tasks = [<br>    asyncio.ensure_future(coroutine1),<br>    asyncio.ensure_future(coroutine2),<br>    asyncio.ensure_future(coroutine3)<br>]<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.wait(tasks))<br><br><span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, task.result())<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Waiting:  <span class="hljs-number">1</span><br>Waiting:  <span class="hljs-number">2</span><br>Waiting:  <span class="hljs-number">4</span><br>Task ret:  Done after 1s<br>Task ret:  Done after 2s<br>Task ret:  Done after 4s<br></code></pre></td></tr></table></figure><h3 id="2-协程中的嵌套"><a href="#2-协程中的嵌套" class="headerlink" title="2. 协程中的嵌套"></a>2. 协程中的嵌套</h3><p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p><p>来看个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-comment">## 用于内部的协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_some_work</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waiting: &#x27;</span>, x)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(x)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Done after &#123;&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(x)<br><br><span class="hljs-comment">## 外部的协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建三个协程对象</span><br>    coroutine1 = do_some_work(<span class="hljs-number">1</span>)<br>    coroutine2 = do_some_work(<span class="hljs-number">2</span>)<br>    coroutine3 = do_some_work(<span class="hljs-number">4</span>)<br><br>    <span class="hljs-comment"># 将协程转为task，并组成list</span><br>    tasks = [<br>        asyncio.ensure_future(coroutine1),<br>        asyncio.ensure_future(coroutine2),<br>        asyncio.ensure_future(coroutine3)<br>    ]<br><br>    <span class="hljs-comment"># 【重点】：await 一个task列表（协程）</span><br>    <span class="hljs-comment"># dones：表示已经完成的任务</span><br>    <span class="hljs-comment"># pendings：表示未完成的任务</span><br>    dones, pendings = <span class="hljs-keyword">await</span> asyncio.wait(tasks)<br><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> dones:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, task.result())<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br></code></pre></td></tr></table></figure><p>如果这边，使用的是<code>asyncio.gather()</code>，是这么用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 注意这边返回结果，与await不一样</span><br><br>results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, result)<br></code></pre></td></tr></table></figure><p>输出还是一样的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Waiting</span>:  <span class="hljs-number">1</span><br><span class="hljs-attribute">Waiting</span>:  <span class="hljs-number">2</span><br><span class="hljs-attribute">Waiting</span>:  <span class="hljs-number">4</span><br><span class="hljs-attribute">Task</span> ret:  Done after <span class="hljs-number">1</span>s<br><span class="hljs-attribute">Task</span> ret:  Done after <span class="hljs-number">2</span>s<br><span class="hljs-attribute">Task</span> ret:  Done after <span class="hljs-number">4</span>s<br></code></pre></td></tr></table></figure><p>仔细查看，可以发现这个例子完全是由 上面「<code>协程中的并发</code>」例子改编而来。结果完全一样。只是把创建协程对象，转换task任务，封装成在一个协程函数里而已。外部的协程，嵌套了一个内部的协程。</p><p>其实你如果去看下<code>asyncio.await()</code>的源码的话，你会发现下面这种写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><p>看似没有嵌套，实际上内部也是嵌套的。</p><p>这里也把源码，贴出来，有兴趣可以看下，没兴趣，可以直接跳过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 内部协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">_wait</span>(<span class="hljs-params">fs, timeout, return_when, loop</span>):<br>    <span class="hljs-keyword">assert</span> fs, <span class="hljs-string">&#x27;Set of Futures is empty.&#x27;</span><br>    waiter = loop.create_future()<br>    timeout_handle = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> timeout <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        timeout_handle = loop.call_later(timeout, _release_waiter, waiter)<br>    counter = <span class="hljs-built_in">len</span>(fs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_on_completion</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-keyword">nonlocal</span> counter<br>        counter -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (counter &lt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span><br>            return_when == FIRST_COMPLETED <span class="hljs-keyword">or</span><br>            return_when == FIRST_EXCEPTION <span class="hljs-keyword">and</span> (<span class="hljs-keyword">not</span> f.cancelled() <span class="hljs-keyword">and</span><br>                                                f.exception() <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>)):<br>            <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                timeout_handle.cancel()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> waiter.done():<br>                waiter.set_result(<span class="hljs-literal">None</span>)<br><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        f.add_done_callback(_on_completion)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> waiter<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-keyword">if</span> timeout_handle <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            timeout_handle.cancel()<br><br>    done, pending = <span class="hljs-built_in">set</span>(), <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> fs:<br>        f.remove_done_callback(_on_completion)<br>        <span class="hljs-keyword">if</span> f.done():<br>            done.add(f)<br>        <span class="hljs-keyword">else</span>:<br>            pending.add(f)<br>    <span class="hljs-keyword">return</span> done, pending<br><br><span class="hljs-comment">## 外部协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait</span>(<span class="hljs-params">fs, *, loop=<span class="hljs-literal">None</span>, timeout=<span class="hljs-literal">None</span>, return_when=ALL_COMPLETED</span>):<br>    <span class="hljs-keyword">if</span> futures.isfuture(fs) <span class="hljs-keyword">or</span> coroutines.iscoroutine(fs):<br>        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;expect a list of futures, not <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(fs).__name__&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> fs:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;Set of coroutines/Futures is empty.&#x27;</span>)<br>    <span class="hljs-keyword">if</span> return_when <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (FIRST_COMPLETED, FIRST_EXCEPTION, ALL_COMPLETED):<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&#x27;Invalid return_when value: <span class="hljs-subst">&#123;return_when&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> loop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        loop = events.get_event_loop()<br><br>    fs = &#123;ensure_future(f, loop=loop) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(fs)&#125;<br>    <span class="hljs-comment"># 【重点】：await一个内部协程</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _wait(fs, timeout, return_when, loop)<br></code></pre></td></tr></table></figure><h3 id="3-协程中的状态"><a href="#3-协程中的状态" class="headerlink" title="3. 协程中的状态"></a>3. 协程中的状态</h3><p>还记得我们在讲生成器的时候，有提及过生成器的状态。同样，在协程这里，我们也了解一下协程（准确的说，应该是Future对象，或者Task任务）有哪些状态。</p><blockquote><p><code>Pending</code>：创建future，还未执行<br><code>Running</code>：事件循环正在调用执行任务<br><code>Done</code>：任务执行完毕<br><code>Cancelled</code>：Task被取消后的状态</p></blockquote><p>可手工 <code>python3 xx.py</code> 执行这段代码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Running in the loop...&quot;</span>)<br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> flag &lt; <span class="hljs-number">1000</span>:<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;F:\\test.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(<span class="hljs-string">&quot;------&quot;</span>)<br>        flag += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stop the loop&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    coroutine = hello()<br>    loop = asyncio.get_event_loop()<br>    task = loop.create_task(coroutine)<br><br>    <span class="hljs-comment"># Pending：未执行状态</span><br>    <span class="hljs-built_in">print</span>(task)<br>    <span class="hljs-keyword">try</span>:<br>        t1 = threading.Thread(target=loop.run_until_complete, args=(task,))<br>        <span class="hljs-comment"># t1.daemon = True</span><br>        t1.start()<br><br>        <span class="hljs-comment"># Running：运行中状态</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(task)<br>        t1.join()<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># 取消任务</span><br>        task.cancel()<br>        <span class="hljs-comment"># Cacelled：取消任务</span><br>        <span class="hljs-built_in">print</span>(task)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(task)<br></code></pre></td></tr></table></figure><p>顺利执行的话，将会打印 <code>Pending</code> -&gt; <code>Pending：Runing</code> -&gt; <code>Finished</code> 的状态变化</p><p>假如，执行后 立马按下 Ctrl+C，则会触发task取消，就会打印 <code>Pending</code> -&gt; <code>Cancelling</code> -&gt; <code>Cancelling</code> 的状态变化。</p><h3 id="4-gather与wait"><a href="#4-gather与wait" class="headerlink" title="4. gather与wait"></a>4. gather与wait</h3><p>还记得上面我说，把多个协程注册进一个事件循环中有两种方法吗？</p><ul><li><p>使用<code>asyncio.wait()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure></li><li><p>使用<code>asyncio.gather()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 千万注意，这里的 「*」 不能省略</span><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.gather(*tasks))<br></code></pre></td></tr></table></figure></li></ul><p><code>asyncio.gather</code> 和 <code>asyncio.wait</code> 在asyncio中用得的比较广泛，这里有必要好好研究下这两货。</p><p>还是照例用例子来说明，先定义一个协程函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">name, number</span>):<br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, number+<span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Task %s: Compute factorial(%s)...&quot;</span> % (name, i))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        f *= i<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Task %s: factorial(%s) = %s&quot;</span> % (name, number, f))<br></code></pre></td></tr></table></figure><h3 id="5-接收参数方式"><a href="#5-接收参数方式" class="headerlink" title="5. 接收参数方式"></a>5. 接收参数方式</h3><h4 id="asyncio-wait"><a href="#asyncio-wait" class="headerlink" title="asyncio.wait"></a>asyncio.wait</h4><p> 接收的tasks，必须是一个list对象，这个list对象里，存放多个的task。</p><p>它可以这样，用<code>asyncio.ensure_future</code>转为task对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">tasks=[<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>)),<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>)),<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>))<br>]<br><br>loop = asyncio.get_event_loop()<br><br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><p>也可以这样，不转为task对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><br>tasks=[<br>       factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>),<br>       factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>),<br>       factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>)<br>]<br><br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><h4 id="asyncio-gather"><a href="#asyncio-gather" class="headerlink" title="asyncio.gather"></a>asyncio.gather</h4><p>接收的就比较广泛了，他可以接收list对象，但是 <code>*</code> 不能省略</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">tasks=[<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>)),<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>)),<br>       asyncio.ensure_future(factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>))<br>]<br><br>loop = asyncio.get_event_loop()<br><br>loop.run_until_complete(asyncio.gather(*tasks))<br></code></pre></td></tr></table></figure><p>还可以这样，和上面的 <code>*</code> 作用一致，这是因为<code>asyncio.gather()</code>的第一个参数是 <code>*coros_or_futures</code>，它叫 <code>非命名键值可变长参数列表</code>，可以集合所有没有命名的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><br>loop.run_until_complete(asyncio.gather(<br>    factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>),<br>    factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>),<br>    factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>),<br>))<br></code></pre></td></tr></table></figure><p>甚至还可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = asyncio.get_event_loop()<br><br>group1 = asyncio.gather(*[factorial(<span class="hljs-string">&quot;A&quot;</span> ,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)])<br>group2 = asyncio.gather(*[factorial(<span class="hljs-string">&quot;B&quot;</span>, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)])<br>group3 = asyncio.gather(*[factorial(<span class="hljs-string">&quot;B&quot;</span>, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>)])<br><br>loop.run_until_complete(asyncio.gather(group1, group2, group3))<br></code></pre></td></tr></table></figure><h3 id="6-返回结果不同"><a href="#6-返回结果不同" class="headerlink" title="6. 返回结果不同"></a>6. 返回结果不同</h3><h4 id="asyncio-wait-1"><a href="#asyncio-wait-1" class="headerlink" title="asyncio.wait"></a>asyncio.wait</h4><p><code>asyncio.wait</code> 返回<code>dones</code>和<code>pendings</code></p><ul><li><code>dones</code>：表示已经完成的任务</li><li><code>pendings</code>：表示未完成的任务</li></ul><p>如果我们需要获取，运行结果，需要手工去收集获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dones, pendings = <span class="hljs-keyword">await</span> asyncio.wait(tasks)<br><br><span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> dones:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, task.result())<br></code></pre></td></tr></table></figure><h4 id="asyncio-gather-1"><a href="#asyncio-gather-1" class="headerlink" title="asyncio.gather"></a>asyncio.gather</h4><p><code>asyncio.gather</code> 它会把值直接返回给我们，不需要手工去收集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">results = <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><br><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Task ret: &#x27;</span>, result)<br></code></pre></td></tr></table></figure><h3 id="7-wait有控制功能"><a href="#7-wait有控制功能" class="headerlink" title="7. wait有控制功能"></a>7. wait有控制功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">coro</span>(<span class="hljs-params">tag</span>):<br>    <span class="hljs-keyword">await</span> asyncio.sleep(random.uniform(<span class="hljs-number">0.5</span>, <span class="hljs-number">5</span>))<br><br>loop = asyncio.get_event_loop()<br><br>tasks = [coro(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br><br><br><span class="hljs-comment">## 【控制运行任务数】：运行第一个任务就返回</span><br><span class="hljs-comment">## FIRST_COMPLETED ：第一个任务完全返回</span><br><span class="hljs-comment">## FIRST_EXCEPTION：产生第一个异常返回</span><br><span class="hljs-comment">## ALL_COMPLETED：所有任务完成返回 （默认选项）</span><br>dones, pendings = loop.run_until_complete(<br>    asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次完成的任务数:&quot;</span>, <span class="hljs-built_in">len</span>(dones))<br><br><br><span class="hljs-comment">## 【控制时间】：运行一秒后，就返回</span><br>dones2, pendings2 = loop.run_until_complete(<br>    asyncio.wait(pendings, timeout=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二次完成的任务数:&quot;</span>, <span class="hljs-built_in">len</span>(dones2))<br><br><br><span class="hljs-comment">## 【默认】：所有任务完成后返回</span><br>dones3, pendings3 = loop.run_until_complete(asyncio.wait(pendings2))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第三次完成的任务数:&quot;</span>, <span class="hljs-built_in">len</span>(dones3))<br><br>loop.close()<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">第一次完成的任务数: <span class="hljs-number">1</span><br>第二次完成的任务数: <span class="hljs-number">4</span><br>第三次完成的任务数: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="10-11-【并发编程】实战异步IO框架：asyncio-下篇"><a href="#10-11-【并发编程】实战异步IO框架：asyncio-下篇" class="headerlink" title="10.11 【并发编程】实战异步IO框架：asyncio 下篇"></a>10.11 【并发编程】实战异步IO框架：asyncio 下篇</h2><h3 id="1-动态添加协程"><a href="#1-动态添加协程" class="headerlink" title="1. 动态添加协程"></a>1. 动态添加协程</h3><p>在实战之前，我们要先了解下在asyncio中如何将协程态添加到事件循环中的。这是前提。</p><p>如何实现呢，有两种方法：</p><ul><li>主线程是同步的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_loop</span>(<span class="hljs-params">loop</span>):<br>    <span class="hljs-comment"># 一个在后台永远运行的事件循环</span><br>    asyncio.set_event_loop(loop)<br>    loop.run_forever()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_sleep</span>(<span class="hljs-params">x, queue, msg=<span class="hljs-string">&quot;&quot;</span></span>):<br>    time.sleep(x)<br>    queue.put(msg)<br><br>queue = Queue()<br><br>new_loop = asyncio.new_event_loop()<br><br><span class="hljs-comment">## 定义一个线程，并传入一个事件循环对象</span><br>t = Thread(target=start_loop, args=(new_loop,))<br>t.start()<br><br><span class="hljs-built_in">print</span>(time.ctime())<br><br><span class="hljs-comment">## 动态添加两个协程</span><br><span class="hljs-comment">## 这种方法，在主线程是同步的</span><br>new_loop.call_soon_threadsafe(do_sleep, <span class="hljs-number">6</span>, queue, <span class="hljs-string">&quot;第一个&quot;</span>)<br>new_loop.call_soon_threadsafe(do_sleep, <span class="hljs-number">3</span>, queue, <span class="hljs-string">&quot;第二个&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    msg = queue.get()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; 协程运行完..&quot;</span>.<span class="hljs-built_in">format</span>(msg))<br>    <span class="hljs-built_in">print</span>(time.ctime())<br></code></pre></td></tr></table></figure><p>由于是同步的，所以总共耗时6+3&#x3D;9秒.</p><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">11</span>:<span class="hljs-number">16</span> <span class="hljs-number">2018</span><br>第一个 协程运行完..<br>Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">11</span>:<span class="hljs-number">22</span> <span class="hljs-number">2018</span><br>第二个 协程运行完..<br>Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">11</span>:<span class="hljs-number">25</span> <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><ul><li>主线程是异步的，这是重点，一定要掌握。。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_loop</span>(<span class="hljs-params">loop</span>):<br>    <span class="hljs-comment"># 一个在后台永远运行的事件循环</span><br>    asyncio.set_event_loop(loop)<br>    loop.run_forever()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_sleep</span>(<span class="hljs-params">x, queue, msg=<span class="hljs-string">&quot;&quot;</span></span>):<br>    <span class="hljs-keyword">await</span> asyncio.sleep(x)<br>    queue.put(msg)<br><br>queue = Queue()<br><br>new_loop = asyncio.new_event_loop()<br><br><span class="hljs-comment">## 定义一个线程，并传入一个事件循环对象</span><br>t = Thread(target=start_loop, args=(new_loop,))<br>t.start()<br><br><span class="hljs-built_in">print</span>(time.ctime())<br><br><span class="hljs-comment">## 动态添加两个协程</span><br><span class="hljs-comment">## 这种方法，在主线程是异步的</span><br>asyncio.run_coroutine_threadsafe(do_sleep(<span class="hljs-number">6</span>, queue, <span class="hljs-string">&quot;第一个&quot;</span>), new_loop)<br>asyncio.run_coroutine_threadsafe(do_sleep(<span class="hljs-number">3</span>, queue, <span class="hljs-string">&quot;第二个&quot;</span>), new_loop)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    msg = queue.get()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; 协程运行完..&quot;</span>.<span class="hljs-built_in">format</span>(msg))<br>    <span class="hljs-built_in">print</span>(time.ctime())<br></code></pre></td></tr></table></figure><p>输出结果</p><p>由于是异步的，所以总共耗时max(6, 3)&#x3D;<code>6</code>秒</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35</span> <span class="hljs-number">2018</span><br>第二个 协程运行完..<br>Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">38</span> <span class="hljs-number">2018</span><br>第一个 协程运行完..<br>Thu May <span class="hljs-number">31</span> <span class="hljs-number">22</span>:<span class="hljs-number">23</span>:<span class="hljs-number">41</span> <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><h3 id="2-利用redis实现动态添加任务"><a href="#2-利用redis实现动态添加任务" class="headerlink" title="2. 利用redis实现动态添加任务"></a>2. 利用redis实现动态添加任务</h3><p>对于并发任务，通常是用生成消费模型，对队列的处理可以使用类似master-worker的方式，master主要用户获取队列的msg，worker用户处理消息。</p><p>为了简单起见，并且协程更适合单线程的方式，我们的主线程用来监听队列，子线程用于处理队列。这里使用redis的队列。主线程中有一个是无限循环，用户消费队列。</p><p>先安装Redis<br>到 <a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a> 下载<br><img src="https://i.loli.net/2018/06/03/5b13ba8525bcf.png"><br>解压到你的路径。<br><img src="https://i.loli.net/2018/06/03/5b13ba9f66baa.png"></p><p>然后，在当前路径运行cmd，运行redis的服务端。<br><img src="https://i.loli.net/2018/06/03/5b13bab682a32.png"><br>服务开启后，我们就可以运行我们的客户端了。<br>并依次输入key&#x3D;queue，value&#x3D;5,3,1的消息。<br><img src="https://i.loli.net/2018/06/03/5b13bad79f5ce.png"></p><p>一切准备就绪之后，我们就可以运行我们的代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> redis<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start_loop</span>(<span class="hljs-params">loop</span>):<br>    <span class="hljs-comment"># 一个在后台永远运行的事件循环</span><br>    asyncio.set_event_loop(loop)<br>    loop.run_forever()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_sleep</span>(<span class="hljs-params">x, queue</span>):<br>    <span class="hljs-keyword">await</span> asyncio.sleep(x)<br>    queue.put(<span class="hljs-string">&quot;ok&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_redis</span>():<br>    connection_pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, db=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> redis.Redis(connection_pool=connection_pool)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        task = rcon.rpop(<span class="hljs-string">&quot;queue&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> task:<br>            time.sleep(<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">continue</span><br>        asyncio.run_coroutine_threadsafe(do_sleep(<span class="hljs-built_in">int</span>(task), queue), new_loop)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(time.ctime())<br>    new_loop = asyncio.new_event_loop()<br><br>    <span class="hljs-comment"># 定义一个线程，运行一个事件循环对象，用于实时接收新任务</span><br>    loop_thread = Thread(target=start_loop, args=(new_loop,))<br>    loop_thread.setDaemon(<span class="hljs-literal">True</span>)<br>    loop_thread.start()<br>    <span class="hljs-comment"># 创建redis连接</span><br>    rcon = get_redis()<br><br>    queue = Queue()<br><br>    <span class="hljs-comment"># 子线程：用于消费队列消息，并实时往事件对象容器中添加新任务</span><br>    consumer_thread = Thread(target=consumer)<br>    consumer_thread.setDaemon(<span class="hljs-literal">True</span>)<br>    consumer_thread.start()<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        msg = queue.get()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;协程运行完..&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前时间：&quot;</span>, time.ctime())<br></code></pre></td></tr></table></figure><p>稍微讲下代码</p><p><code>loop_thread</code>：单独的线程，运行着一个事件对象容器，用于实时接收新任务。<br><code>consumer_thread</code>：单独的线程，实时接收来自Redis的消息队列，并实时往事件对象容器中添加新任务。</p><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">Thu May <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">42</span>:<span class="hljs-number">48</span> <span class="hljs-number">2018</span><br>协程运行完..<br>当前时间： Thu May <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">42</span>:<span class="hljs-number">49</span> <span class="hljs-number">2018</span><br><br>协程运行完..<br>当前时间： Thu May <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">42</span>:<span class="hljs-number">51</span> <span class="hljs-number">2018</span><br><br>协程运行完..<br>当前时间： Thu May <span class="hljs-number">31</span> <span class="hljs-number">23</span>:<span class="hljs-number">42</span>:<span class="hljs-number">53</span> <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><p>我们在Redis，分别发起了5s，3s，1s的任务。<br>从结果来看，这三个任务，确实是并发执行的，1s的任务最先结束，三个任务完成总耗时5s</p><p>运行后，程序是一直运行在后台的，我们每一次在Redis中输入新值，都会触发新任务的执行。。</p><h2 id="10-12-【并发编程】生成器与协程，你分清了吗？"><a href="#10-12-【并发编程】生成器与协程，你分清了吗？" class="headerlink" title="10.12 【并发编程】生成器与协程，你分清了吗？"></a>10.12 【并发编程】生成器与协程，你分清了吗？</h2><p>如你所见，下面这代码将定义一个生成器的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> food:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小明 吃完&#123;&#125;了&quot;</span>.<span class="hljs-built_in">format</span>(food))<br>        <span class="hljs-keyword">yield</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小明 要开始吃&#123;&#125;...&quot;</span>.<span class="hljs-built_in">format</span>(food))<br>        time.sleep(<span class="hljs-number">1</span>)<br><br>food = <span class="hljs-literal">None</span><br>MING = eat()     <span class="hljs-comment"># 产生一个生成器</span><br>MING.send(<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 预激</span><br>food = <span class="hljs-string">&quot;面包&quot;</span><br>MING.send(<span class="hljs-string">&#x27;面包&#x27;</span>)<br>MING.send(<span class="hljs-string">&#x27;苹果&#x27;</span>)<br>MING.send(<span class="hljs-string">&#x27;香肠&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行一下，从结果中可以看出，不管我们塞给小明什么东西，小明都将只能将他们当成面包吃。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">小明 要开始吃面包...<br>小明 吃完面包了<br>小明 要开始吃面包...<br>小明 吃完面包了<br>小明 要开始吃面包...<br>小明 吃完面包了<br></code></pre></td></tr></table></figure><p>那再来看一下协程的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>():<br>    food = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> food:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小明 吃完&#123;&#125;了&quot;</span>.<span class="hljs-built_in">format</span>(food))<br>        food = <span class="hljs-keyword">yield</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小明 开始吃&#123;&#125;...&quot;</span>.<span class="hljs-built_in">format</span>(food))<br>        time.sleep(<span class="hljs-number">1</span>)<br><br>MING = eat()      <span class="hljs-comment"># 产生一个生成器</span><br>MING.send(<span class="hljs-literal">None</span>)   <span class="hljs-comment"># 预激</span><br>MING.send(<span class="hljs-string">&#x27;面包&#x27;</span>)<br>MING.send(<span class="hljs-string">&#x27;苹果&#x27;</span>)<br>MING.send(<span class="hljs-string">&#x27;香肠&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行一下，从结果中可以看出，小明已经可以感知我们塞给他的是什么食物。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs erlang">小明 开始吃面包...<br>小明 吃完面包了<br>小明 开始吃苹果...<br>小明 吃完苹果了<br>小明 开始吃香肠...<br>小明 吃完香肠了<br></code></pre></td></tr></table></figure><p>仔细观察一下，上面两段代码并没有太大的区别，我们将主要关注点集中在 <code>yield</code>  关键词上。</p><p>可以发现，生成器里 <code>yield</code> 左边并没有变量，而在协程里，<code>yield</code> 左边有一个变量。</p><p>在函数被调用后，一个生成器就产生了，而一般的生成器不能再往生成器内部传递参数了，而这个当生成器里的 yield 左边有变量时，就不一样了，它仍然可以在外部接收新的参数。这就是生成器与协程的最大区别。</p><p><strong>协程的优点：</strong></p><ul><li><p>线程属于系统级别调度，而协程是程序员级别的调度。使用协程避免了无意义的调度，减少了线程上下文切换的开销，由此可以提高性能。</p></li><li><p>高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</p></li><li><p>无需原子操作锁定及同步的开销</p></li><li><p>方便切换控制流，简化编程模型</p></li></ul><p><strong>协程的缺点：</strong></p><p>　　（1）无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。</p><p>　　（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序</p><p>协程很类似于Javascript单线程下异步处理的概念，协程同样是单线程的，之所以能够进行并发是因为通过某种方式保存了执行栈的上下文，在一定条件下将执行权交由其他栈，在一定条件下又通过执行栈上下文恢复栈。<br><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="10-14-【并发编程】浅谈线程安全那些事儿"><a href="#10-14-【并发编程】浅谈线程安全那些事儿" class="headerlink" title="10.14 【并发编程】浅谈线程安全那些事儿"></a>10.14 【并发编程】浅谈线程安全那些事儿</h2><p>在并发编程时，如果多个线程访问同一资源，我们需要保证访问的时候不会产生冲突，数据修改不会发生错误，这就是我们常说的 <strong>线程安全</strong> 。</p><p>那什么情况下，访问数据时是安全的？什么情况下，访问数据是不安全的？如何知道你的代码是否线程安全？要如何访问数据才能保证数据的安全？</p><p>本篇文章会一一回答你的问题。</p><h3 id="1-线程不安全是怎样的？"><a href="#1-线程不安全是怎样的？" class="headerlink" title="1. 线程不安全是怎样的？"></a>1. 线程不安全是怎样的？</h3><p>要搞清楚什么是线程安全，就要先了解线程不安全是什么样的。</p><p>比如下面这段代码，开启两个线程，对全局变量 number 各自增 10万次，每次自增 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>number = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):<br>        number += <span class="hljs-number">1</span><br><br>thread_01 = Thread(target=target)<br>thread_02 = Thread(target=target)<br>thread_01.start()<br>thread_02.start()<br><br>thread_01.join()<br>thread_02.join()<br><br><span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><p>正常我们的预期输出结果，一个线程自增100万，两个线程就自增 200 万嘛，输出肯定为 2000000 。</p><p>可事实却并不是你想的那样，不管你运行多少次，每次输出的结果都会不一样，而这些输出结果都有一个特点是，都小于 200 万。</p><p>以下是执行三次的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1459782</span><br><span class="hljs-number">1379891</span><br><span class="hljs-number">1432921</span><br></code></pre></td></tr></table></figure><p>这种现象就是线程不安全，究其根因，其实是我们的操作 <code>number += 1</code> ，不是原子操作，才会导致的线程不安全。</p><h3 id="2-什么是原子操作？"><a href="#2-什么是原子操作？" class="headerlink" title="2. 什么是原子操作？"></a>2. 什么是原子操作？</h3><p>原子操作（<strong>atomic operation</strong>），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程。</p><p>它有点类似数据库中的 <strong>事务</strong>。</p><p>在 Python 的<a href="https://docs.python.org/3.5/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe">官方文档</a>上，列出了一些常见原子操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">L.append(x)<br>L1.extend(L2)<br>x = L[i]<br>x = L.pop()<br>L1[i:j] = L2<br>L.sort()<br>x = y<br>x.field = y<br>D[x] = y<br>D1.update(D2)<br>D.keys()<br></code></pre></td></tr></table></figure><p>而下面这些就不是原子操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">i = i+<span class="hljs-number">1</span><br>L.append(L[-<span class="hljs-number">1</span>])<br>L[i] = L[j]<br>D[x] = D[x] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>像上面的我使用自增操作 <code>number += 1</code>，其实等价于 <code>number = number + 1</code>，可以看到这种可以拆分成多个步骤（先读取相加再赋值），并不属于原子操作。</p><p>这样就导致多个线程同时读取时，有可能读取到同一个 number 值，读取两次，却只加了一次，最终导致自增的次数小于预期。</p><p>当我们还是无法确定我们的代码是否具有原子性的时候，可以尝试通过 <code>dis</code> 模块里的 dis 函数来查看</p><p><img src="http://image.iswbm.com/20200506080445.png"></p><p>当我们执行这段代码时，可以看到 <code>number += 1</code> 这一行代码，由两条字节码实现。</p><ul><li><code>BINARY_ADD</code> ：将两个值相加</li><li><code>STORE_GLOBAL</code>： 将相加后的值重新赋值</li></ul><p>每一条字节码指令都是一个整体，无法分割，他实现的效果也就是我们所说的原子操作。</p><p>当一行代码被分成多条字节码指令的时候，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确。</p><p>为了对比，我们从上面列表的原子操作拿一个出来也来试试，是不是真如官网所说的原子操作。</p><p>这里我拿字典的 update 操作举例，代码和执行过程如下图</p><p><img src="http://image.iswbm.com/20200506081541.png"></p><p>从截图里可以看到，<code>info.update(new)</code> 虽然也分为好几个操作</p><ul><li><code>LOAD_GLOBAL</code>：加载全局变量</li><li><code>LOAD_ATTR</code>： 加载属性，获取 update 方法</li><li><code>LOAD_FAST</code>：加载 new 变量</li><li><code>CALL_FUNCTION</code>：调用函数</li><li><code>POP_TOP</code>：执行更新操作</li></ul><p>但我们要知道真正会引导数据冲突的，其实不是读操作，而是写操作。</p><p>上面这么多字节码指令，写操作都只有一个（<strong>POP_TOP</strong>），因此字典的 update 方法是原子操作。</p><h3 id="3-实现人工原子操作"><a href="#3-实现人工原子操作" class="headerlink" title="3. 实现人工原子操作"></a>3. 实现人工原子操作</h3><p>在多线程下，我们并不能保证我们的代码都具有原子性，因此如何让我们的代码变得具有 “原子性” ，就是一件很重要的事。</p><p>方法也很简单，就是当你在访问一个多线程间共享的资源时，加锁可以实现类似原子操作的效果，一个代码要嘛不执行，执行了的话就要执行完毕，才能接受线程的调度。</p><p>因此，我们使用加锁的方法，对例子一进行一些修改，使其具备原子性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br><br>number = <span class="hljs-number">0</span><br>lock = Lock()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-keyword">global</span> number<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            number += <span class="hljs-number">1</span><br><br>thread_01 = Thread(target=target)<br>thread_02 = Thread(target=target)<br>thread_01.start()<br>thread_02.start()<br><br>thread_01.join()<br>thread_02.join()<br><br><span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><p>此时，不管你执行多少遍，输出都是 2000000.</p><h3 id="4-为什么-Queue-是线程安全的？"><a href="#4-为什么-Queue-是线程安全的？" class="headerlink" title="4. 为什么 Queue 是线程安全的？"></a>4. 为什么 Queue 是线程安全的？</h3><p>Python 的 threading 模块里的消息通信机制主要有如下三种：</p><ol><li>Event</li><li>Condition</li><li>Queue</li></ol><p>使用最多的是 Queue，而我们都知道它是线程安全的。当我们对它进行写入和提取的操作不会被中断而导致错误，这也是我们在使用队列时，不需要额外加锁的原因。</p><p>他是如何做到的呢？</p><p>其根本原因就是 Queue 实现了锁原语，因此他能像第三节那样实现人工原子操作。</p><blockquote><p>原语指由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性；即原语的执行必须是连续的，在执行过程中不允许被中断。</p></blockquote><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://zhuanlan.zhihu.com/p/34150765">https://zhuanlan.zhihu.com/p/34150765</a></p><p><a href="https://juejin.im/post/5b129a1be51d45068a6c91d4#comment">https://juejin.im/post/5b129a1be51d45068a6c91d4#comment</a></p><h1 id="第十一章：代码美化"><a href="#第十一章：代码美化" class="headerlink" title="第十一章：代码美化"></a>第十一章：代码美化</h1><h2 id="11-1-【代码美化】如何更好进行变量的命名？"><a href="#11-1-【代码美化】如何更好进行变量的命名？" class="headerlink" title="11.1 【代码美化】如何更好进行变量的命名？"></a>11.1 【代码美化】如何更好进行变量的命名？</h2><p>命名是一件困难的事情，要想出一个恰到好处的命名需要一番功夫，尤其我们的母语还不是编程语言所通用的英语。不过这一切都是值得了，好的命名让你的代码更直观，更有表达力。</p><p>在进行变量的命名时，应注意：</p><ol><li>变量名，最好能体现 『变量用途』，『数据类型』，『单复数』等</li><li>变量名，请不要过于随便，如使用数字 1，和字母 a</li><li>变量名，不要如不能正确引导，至少要做到不误导。比如 user_list 不应该是一个字典类型 </li><li>变量名，请使用蛇形命名法（如 user_info），而不是使用驼峰命名法（userInfo）。</li></ol><h2 id="11-2-【代码美化】写好函数的-6-个建议"><a href="#11-2-【代码美化】写好函数的-6-个建议" class="headerlink" title="11.2 【代码美化】写好函数的 6 个建议"></a>11.2 【代码美化】写好函数的 6 个建议</h2><p>Python 虽然好用，但用好真的很难。</p><p>尤其是函数部分，只要写不好，后面的一连串人都会遭殃。</p><p>看又看不懂，测试起来也麻烦，维护又维护不动，真是让人头疼。</p><p>那怎么写好一个 Python 函数呢？</p><p>《Writing Idiomatic Python》一书的作者在 Medium 上发表了一篇文章，给出了 6 个建议。</p><p>希望能够给你带来帮助。</p><h3 id="0-怎样算是好函数？"><a href="#0-怎样算是好函数？" class="headerlink" title="0. 怎样算是好函数？"></a>0. 怎样算是好函数？</h3><p>“好”的 Python 函数和“差”的 Python 函数之间有什么差别呢？每个人都有自己的理解。基于我的理解，如果一个 Python 函数能够符合下面的大部分条件，我会认为它是一个“好”函数：</p><ul><li>命名合理</li><li>单一功能</li><li>包括文档字符串</li><li>返回一个值</li><li>不超过 50 行</li><li>是幂等函数或纯函数</li></ul><p>对许多人来说，这些要求可能显得过于苛刻了。</p><p>不过，我保证，如果你的函数遵循这些规则，你的代码会非常漂亮，会让其他的程序员都“馋哭”的。</p><p>下面，我将一一讨论这些规则，然后总结它们是如何创造“好”函数的。</p><h3 id="1-注意命名"><a href="#1-注意命名" class="headerlink" title="1. 注意命名"></a>1. 注意命名</h3><p>在这个问题上，我最喜欢的一句话是：</p><blockquote><p>计算机科学中只有两件事很让人头疼：缓存失效和命名。</p></blockquote><p>尽管这听起来很莫名其妙，但给一个事情命名太难了。下面是一个反面案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getknn</span>(<span class="hljs-params">from_df</span>):<br></code></pre></td></tr></table></figure><p>原文中这个代码没有放上去，我们根据上下文信息进行了补充。</p><p>这个函数命名的第一个问题是它使用了缩写。</p><p>对于那些并不出名的缩略词来说，使用完整的英语单词会更好。缩写单词的唯一原因是为了节省打字时间，但是每个现代编辑器都有自动填充功能，所以你只需要键入一次全名就可以了。</p><p>缩写通常是特定领域的。在上面的代码中，KNN 指的是“K-Nearest Neighbors”，df 指的是“DataFrame”，这是一个数据结构。如果另一个不熟悉这些首字母缩写的程序员正在阅读代码，几乎很难看懂。</p><p>关于这个函数的名字还有另外两个小瑕疵：</p><ul><li>“get”这个词是无关紧要的。对于大多数命名比较好的函数来说，很明显有一些东西会从函数中返回，它的名字将反映这一点。</li><li>from_df 也不是必要的。如果没有明确的参数名称，函数的文档字符串或类型注释会描述参数的类型。</li></ul><p>那么我们如何重命名这个函数呢？很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">k_nearest_neighbors</span>(<span class="hljs-params">dataframe</span>):<br></code></pre></td></tr></table></figure><p>即使是外行，这个函数要计算的内容也很清楚，参数的名称(dataframe)也清楚地表明了参数类型。</p><h3 id="2-单一功能"><a href="#2-单一功能" class="headerlink" title="2. 单一功能"></a>2. 单一功能</h3><p>单一功能原则不仅适用于类和模块，也同样适用于函数。</p><p>一个函数应该只有一个功能。也就是说，它应该只做一件事。</p><p>一个重要的原因是，如果每个函数只做一件事，只有这件事发生了变化，才需要改变这个函数。</p><p>此外，如果这个函数的单个功能不再需要了，直接把它删了就行了。</p><p>还是用例子来说明吧。下面这个函数，可以做不止一件“事情”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_and</span> print_stats(list_of_numbers):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span>(list_of_numbers)<br>    mean = statistics.mean(list_of_numbers)<br>    median = statistics.median(list_of_numbers)<br>    mode = statistics.mode(list_of_numbers)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-----------------Stats-----------------&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;SUM: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>) <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MEAN: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(mean)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MEDIAN: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(median)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;MODE: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(mode)<br></code></pre></td></tr></table></figure><p>这个函数做了两件事：一是计算一组关于数字列表的统计数据，二是将它们打印到 STDOUT。</p><p>如果需要计算新的或不同的统计数据，或者需要改变输出的格式，就需要对这个函数进行调整。</p><p>所以，这个函数最好写成两个独立的函数：一个用来执行并返回计算结果，另一个用来获取这些结果并打印出来。</p><p>这种处理方式，不仅能让测试函数更容易，并且还允许这两个部分有了迁移性，如果合适的话，还可能一起应用到不同的模块中。</p><p>在编程中，你会发现好多函数都可以做很多很多事情。同样，为了可读性和可测试性，这些函数应该被分解成更小的函数，每个函数只有一个功能。</p><h3 id="3-文档字符串（Docstrings）"><a href="#3-文档字符串（Docstrings）" class="headerlink" title="3. 文档字符串（Docstrings）"></a>3. 文档字符串（Docstrings）</h3><p>虽然每个人似乎都知道 PEP - 8，它定义了 Python 的样式指南，但是很少有人知道 PEP - 257，它是关于文档字符串的。我再这里不简单地重复 PEP - 257 的内容了，你可以在闲暇时读一下。其中的关键内容是：</p><ul><li>每个函数都需要有一个文档字符串</li><li>使用适当的语法和标点符号；用完整的句子写</li><li>首先对函数的作用进行一句话的总结</li><li>使用说明性语言而不是描述性语言</li></ul><p>在编写函数时，要养成写文档字符串的习惯，并在编写函数代码之前尝试写一下。</p><p>如果你不能写一个清晰的文档字符串来描述函数做什么，就说明你需要再考虑考虑为什么要写这个函数了。</p><h3 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h3><p>函数可以被认为是一些独立的程序。它们以参数的形式接受一些输入，并返回一些结果。</p><p>参数有没有都可以，但从 Python 内部的角度来看，返回值是必须要有的。你不可能创建一个没有返回值的函数。如果函数没有返回值，Python 会“强制”返回 None。你可以测试一下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">❯ python3<br>Python <span class="hljs-number">3.7</span><span class="hljs-number">.0</span> (default, Jul <span class="hljs-number">232018</span>, <span class="hljs-number">20</span>:<span class="hljs-number">22</span>:<span class="hljs-number">55</span>)<br>[Clang <span class="hljs-number">9.1</span><span class="hljs-number">.0</span> (clang-<span class="hljs-number">902.0</span><span class="hljs-number">.39</span><span class="hljs-number">.2</span>)] on darwin<br><span class="hljs-type">Type</span> <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span>o<span class="hljs-string">r&quot;license&quot;</span><span class="hljs-keyword">for</span> more information.<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-meta">... </span>  <span class="hljs-built_in">print</span>(a + b)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-meta">&gt;&gt;&gt; </span>b isNone<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>你会发现 b 的返回值实际上是 None。即使你写的函数没有返回语句，它仍然会返回一些东西。而且，每个函数都应该返回一个有用的值，测试起来也会更方便。毕竟，你写的代码应该能够被测试。</p><p>试想一下，测试上面的 add 函会有多艰难。遵循这个概念，我们应该这样写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;foo.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> input_file:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> input_file:<br>        <span class="hljs-keyword">if</span> line.strip().lower().endswith(<span class="hljs-string">&#x27;cat&#x27;</span>):<br>        <span class="hljs-comment"># ... do something useful with these lines</span><br></code></pre></td></tr></table></figure><p><code>if line.strip().lower().endswith(‘cat’):</code> 这一行能够工作，是因为每个字符串方法( strip ( )、lower ( )、end swith ( ) )都返回一个字符串作为调用函数的结果。</p><p>当给定函数没有返回值时，有一些常见的原因：</p><p><strong>“它所做的只是[一些与 I&#x2F;O 相关的事情，比如将一个值保存到数据库中]。我不能返回任何有用的东西。”</strong></p><p>我不同意。如果操作顺利完成，函数可以返回 True。</p><p><strong>“我们修改了其中一个参数，将其用作参考参数。”</strong></p><p>这里有两点需要注意。首先，尽最大努力避免这种做法。用好了令人惊讶，用不好非常危险。</p><p>其次，即使这样做不可行，复制某个参数的成本太高，你也可以回到上一条建议。</p><p><strong>“我需要返回多个值。单独返回一个值是没有意义的。”</strong></p><p>可以使用元组返回多个值。</p><p>总是返回一个有用的值，调用者总是可以自由地忽略它们。</p><h3 id="5-函数长度"><a href="#5-函数长度" class="headerlink" title="5. 函数长度"></a>5. 函数长度</h3><p>让你读一个 200 行的函数，并说出它是做什么的，你是什么感受？</p><p>函数的长度直接影响可读性，从而影响可维护性。所以要保持你的函数简短。50 行是一个随意的数字，在我看来是合理的。你编写的大多数函数应该要短一些。</p><p>如果一个函数遵循单一功能原则，它很可能是相当短的。如果它是纯函数或是幂等的(下面讨论) ，它也可能是短的。</p><p>那么，如果函数太长，应该怎么做？重构。这会改变程序的结构而不改变其行为。</p><p>从一个长函数中提取几行代码，并把它们变成自己的函数。这是缩短长函数的最快、也是最常见的方式。</p><p>加上你给所有这些新函数取了合适的名称，因此生成的代码读起来也会更容易。</p><h3 id="6-幂等和函数纯度"><a href="#6-幂等和函数纯度" class="headerlink" title="6. 幂等和函数纯度"></a>6. 幂等和函数纯度</h3><p>不管被调用了多少次，幂等函数总是在给定相同参数集的情况下返回相同的值。</p><p>结果不依赖于非局部变量、参数的可变性或来自任何 I &#x2F; O 流的数据。下面的这个 add_three(number)函数是幂等函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_three</span>(<span class="hljs-params">number</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> number + <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>不管一个人调用 add_three(7)多少次，答案总是 10。以下是一个非幂等函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_three</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Return 3 + the number entered by the user.&quot;&quot;&quot;</span><br>    number = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Enter a number: &#x27;</span>))<br>    <span class="hljs-keyword">return</span> number + <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这个函数的返回值取决于 I &#x2F; O，即用户输入的数字。对 add_three()的每次调用都会返回不同的值。</p><p>如果它被调用两次，用户可以第一次输入 3，第二次输入 7，分别调用 add_three()返回 6 和 10。</p><p>幂等性的一个现实中例子是在电梯前点击“向上”按钮。第一次按时，电梯会被“通知”你要上去。因为按按钮是幂等的，所以反复按它都没有什么影响。结果是一样的。</p><h4 id="6-1-为什么幂等很重要？"><a href="#6-1-为什么幂等很重要？" class="headerlink" title="6.1 为什么幂等很重要？"></a>6.1 为什么幂等很重要？</h4><p>可维护性和可维护性。幂等函数很容易测试，因为在使用相同的参数时，它们总是返回相同的结果。</p><p>测试仅仅是检查通过不同调用返回值的预期值。更重要的是，这些测试很快，这是单元测试中一个重要且经常被忽视的问题。</p><p>而在处理幂等函数时，重构是轻而易举的事情。无论如何在函数之外更改代码，使用相同的参数调用它的结果总是一样的。</p><h4 id="6-2-什么是纯函数？"><a href="#6-2-什么是纯函数？" class="headerlink" title="6.2 什么是纯函数？"></a>6.2 什么是纯函数？</h4><p>在函数编程中，如果一个函数既幂等又没有可观察到的副作用，它就被认为是纯函数。函数外部的任何东西都不会影响这个值。</p><p>然而，这并不意味着函数不能影响非局部变量或 I &#x2F; O 流之类的事情。例如，如果上面 add_three(number)的幂等版本在返回结果之前打印了结果，那么它仍然被认为是幂等的，因为当它访问 I &#x2F; O 流时，这个访问与从函数返回的值无关。</p><p>调用 print()只是一个副作用：除了返回值之外，还与程序的其他部分或系统本身进行了一些交互。</p><p>让我们把我们的 add_three(number)示例再向前推进一步。我们可以编写下面的代码片段来确定调用 add_three(number)的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">add_three_calls = <span class="hljs-number">0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_three</span>(<span class="hljs-params">number</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return *number* + 3.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> add_three_calls<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Returning <span class="hljs-subst">&#123;number + <span class="hljs-number">3</span>&#125;</span>&#x27;</span>)<br>    add_three_calls += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> number + <span class="hljs-number">3</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">num_calls</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Return the number of times *add_three* was called.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> add_three_calls<br></code></pre></td></tr></table></figure><p>我们现在正在打印到控制台(一个副作用)并修改一个非局部变量(另一个副作用)，但是由于这两者都不影响函数返回的值，它仍然是幂等的。</p><p>纯函数没有副作用。它不仅不使用任何“外部数据”来计算值，除了计算和返回所述值之外，它与系统&#x2F;程序的其余部分都没有交互。因此，虽然我们新的 add_three(number)定义仍然是幂等的，但它不再是纯的。</p><p>纯函数没有日志语句或 print()调用。它们不使用数据库或互联网连接。它们不访问或修改非局部变量。它们不调用任何其他非纯函数。</p><p>简而言之，它们无法做到爱因斯坦所说的“远距离幽灵般的行动”(在计算机科学环境中)。它们不会以任何方式修改程序或系统的其余部分。</p><p>在命令式编程(编写 Python 代码时所做的那种)中，它们是所有函数中最安全的函数。</p><p>它们也很容易被测试和维护，甚至比只是幂等函数更重要的是，测试它们基本上可以和执行它们一样快。</p><p>测试本身很简单：没有数据库连接或其他外部资源进行模拟，也不需要安装代码，之后也没有什么需要清理的。</p><p>明确地说，幂等性和纯函数只是一种期望，不是必需的。也就是说，由于好处很多，我们可能会希望只编写纯函数或幂等函数，但这不现实。</p><p>重要的是，我们要有意识开始写代码来隔离副作用和外部依赖性。这会使得我们编写的每一行代码都更容易被测试。## 11.3 【代码美化】自觉遵守 PEP8 代码风格</p><p>每个编程语言都有自己的编码，而在 Python 中最受认可的是 PEP 8的编码风格规范。每个写 Python 代码的人都有必要过一遍 PEP 8的内容  ，它可以让你的代码“ 更好看”，更容易被阅读。</p><h3 id="1-代码编排"><a href="#1-代码编排" class="headerlink" title="1. 代码编排"></a>1. 代码编排</h3><ol><li>缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。</li><li>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。</li><li>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。</li></ol><h3 id="2-文档编排"><a href="#2-文档编排" class="headerlink" title="2. 文档编排"></a>2. 文档编排</h3><ol><li>模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。</li><li>不要在一句import中多个库，比如import os, sys不推荐。</li><li>如果采用from XX import XX引用库，可以省略 module，都是可能出现命名冲突，这时就要采用import XX。</li></ol><h3 id="3-空格的使用"><a href="#3-空格的使用" class="headerlink" title="3. 空格的使用"></a>3. 空格的使用</h3><p>总体原则，避免不必要的空格。</p><ol><li>各种右括号前不要加空格。</li><li>逗号、冒号、分号前不要加空格。</li><li>函数的左括号前不要加空格。如Func(1)。</li><li>序列的左括号前不要加空格。如list[2]。</li><li>操作符左右各加一个空格，不要为了对齐增加空格。</li><li>函数默认参数使用的赋值符左右省略空格。</li><li>不要将多句语句写在同一行，尽管使用‘；’允许。</li><li>if&#x2F;for&#x2F;while语句中，即使执行语句只有一句，也必须另起一行。</li></ol><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4. 注释"></a>4. 注释</h3><p>总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。</p><p>1、块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## Description : Module config.</span><br><span class="hljs-comment">## </span><br><span class="hljs-comment">## Input : None</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">## Output : None</span><br></code></pre></td></tr></table></figure><p>2、行注释，在一句代码后加注释。比如：(但是这种方式尽量少使用)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">x = x + 1       <span class="hljs-comment"># Increment x</span><br></code></pre></td></tr></table></figure><p>3、避免无谓的注释。</p><h3 id="5-文档描述"><a href="#5-文档描述" class="headerlink" title="5. 文档描述"></a>5. 文档描述</h3><ol><li>为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。</li><li>如果docstring要换行，参考如下例子,详见PEP 257</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Return a foobang</span><br><span class="hljs-string">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-命名规范"><a href="#6-命名规范" class="headerlink" title="6. 命名规范"></a>6. 命名规范</h3><p>总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。</p><ol><li>尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。</li><li>模块命名尽量短小，使用全部小写的方式，可以使用下划线。</li><li>包命名尽量短小，使用全部小写的方式，不可以使用下划线。<br> 4.类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。</li><li>异常命名使用CapWords+Error后缀的方式。</li><li>全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是<strong>all</strong>机制;二是前缀一个下划线。</li><li>函数命名使用全部小写的方式，可以使用下划线。</li><li>常量命名使用全部大写的方式，可以使用下划线。</li><li>类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。</li><li>类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。</li><li>类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。</li><li>为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。</li><li>类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。## 11.4 【代码美化】Pythonic 代码的 15 个案例</li></ol><p>Python由于语言的简洁性，让我们以人类思考的方式来写代码，新手更容易上手，老鸟更爱不释手。</p><p>要写出 Pythonic（优雅的、地道的、整洁的）代码，还要平时多观察那些大牛代码，这里明哥收集了一些比较常见的 Pythonic 写法，帮助你养成写优秀代码的习惯。</p><h3 id="01-变量交换"><a href="#01-变量交换" class="headerlink" title="01. 变量交换"></a>01. 变量交换</h3><p>交换两个变量的值，正常都会想利用一个中间临时变量来过渡。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tmp = a<br>a = b<br>b = tmp<br></code></pre></td></tr></table></figure><p>能用一行代码解决的（并且不影响可读性的），决不用三行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a,b = b,a<br></code></pre></td></tr></table></figure><h3 id="02-列表推导"><a href="#02-列表推导" class="headerlink" title="02. 列表推导"></a>02. 列表推导</h3><p>下面是一个非常简单的 for 循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    my_list.append(i*<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>在一个 for 循环中，如果逻辑比较简单，不如试用一下列表的列表推导式，虽然只有一行代码，但也逻辑清晰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_list = [i*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br></code></pre></td></tr></table></figure><h3 id="03-单行表达式"><a href="#03-单行表达式" class="headerlink" title="03. 单行表达式"></a>03. 单行表达式</h3><p>上面两个案例，都将多行代码用另一种方式写成了一行代码。</p><p>这并不意味着，代码行数越少，就越 Pythonic 。</p><p>比如下面这样写，就不推荐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>); <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;world&#x27;</span>)<br><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,world&#x27;</span>)<br><br><span class="hljs-keyword">if</span> &lt;<span class="hljs-built_in">complex</span> comparison&gt; <span class="hljs-keyword">and</span> &lt;other <span class="hljs-built_in">complex</span> comparison&gt;:<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>建议还是按照如下的写法来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>（<span class="hljs-string">&#x27;hello&#x27;</span>）<br><span class="hljs-built_in">print</span>（<span class="hljs-string">&#x27;world&#x27;</span>）<br><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello,world&#x27;</span>)<br><br>cond1 = &lt;<span class="hljs-built_in">complex</span> comparison&gt;<br>cond2 = &lt;other <span class="hljs-built_in">complex</span> comparison&gt;<br><span class="hljs-keyword">if</span> cond1 <span class="hljs-keyword">and</span> cond2:<br>    <span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><h3 id="04-带索引遍历"><a href="#04-带索引遍历" class="headerlink" title="04. 带索引遍历"></a>04. 带索引遍历</h3><p>使用 for 循环时，如何取得对应的索引，初学者习惯使用 range + len 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(my_list)):<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&quot;--&gt;&quot;</span>, my_list[i])<br></code></pre></td></tr></table></figure><p>更好的做法是利用 enumerate 这个内置函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i,item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(my_list):<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&quot;--&gt;&quot;</span>,item)<br></code></pre></td></tr></table></figure><h3 id="05-序列解包"><a href="#05-序列解包" class="headerlink" title="05. 序列解包"></a>05. 序列解包</h3><p>使用 <code>*</code> 可以对一个列表解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a, *rest = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">## a = 1, rest = [2, 3]</span><br><br>a, *middle, c = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-comment">## a = 1, middle = [2, 3], c = 4</span><br></code></pre></td></tr></table></figure><h3 id="06-字符串拼接"><a href="#06-字符串拼接" class="headerlink" title="06. 字符串拼接"></a>06. 字符串拼接</h3><p>如果一个列表（或者可迭代对象）中的所有元素都是字符串对象，想要将他们连接起来，通常做法是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">letters = [<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>]<br>s=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> let <span class="hljs-keyword">in</span> letters:<br>    s += let<br></code></pre></td></tr></table></figure><p>更推荐的做法是使用 join 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">letters = [<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>]<br>word = <span class="hljs-string">&#x27;&#x27;</span>.join(letters)<br></code></pre></td></tr></table></figure><h3 id="07-真假判断"><a href="#07-真假判断" class="headerlink" title="07. 真假判断"></a>07. 真假判断</h3><p>判断一个变量是否为真（假），新手习惯直接使用 <code>==</code> 与 True、False、None 进行对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> attr == <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;True!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> attr == <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;attr is None!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>实际上，<code>&quot;&quot;</code>、<code>[]</code>、<code>&#123;&#125;</code> 这些没有任何元素的容器都是假值，可直接使用 <code>if not xx</code> 来判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> attr:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;attr is truthy!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> attr:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;attr is falsey!&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="08-访问字典元素"><a href="#08-访问字典元素" class="headerlink" title="08. 访问字典元素"></a>08. 访问字典元素</h3><p>当直接使用 <code>[]</code> 来访问字典里的元素时，若key不存在，是会抛异常的，所以新会可能会先判断一下是否有这个 key，有再取之。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;<br><span class="hljs-keyword">if</span> d.has_key(<span class="hljs-string">&#x27;hello&#x27;</span>):<br>    <span class="hljs-built_in">print</span>(d[<span class="hljs-string">&#x27;hello&#x27;</span>])    <span class="hljs-comment"># prints &#x27;world&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;default_value&#x27;</span>)<br></code></pre></td></tr></table></figure><p>更推荐的做法是使用 <code>get</code> 来取，如果没有该 key 会默认返回 None（当然你也可以设置默认返回值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;<br><br><span class="hljs-built_in">print</span>(d.get(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;default_value&#x27;</span>)) <span class="hljs-comment"># prints &#x27;world&#x27;</span><br><span class="hljs-built_in">print</span>(d.get(<span class="hljs-string">&#x27;thingy&#x27;</span>, <span class="hljs-string">&#x27;default_value&#x27;</span>)) <span class="hljs-comment"># prints &#x27;default_value&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="09-操作列表"><a href="#09-操作列表" class="headerlink" title="09. 操作列表"></a>09. 操作列表</h3><p>下面这段代码，会根据条件过滤过列表中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>b = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">4</span>:<br>        b.append(i)<br></code></pre></td></tr></table></figure><p>实际上可以使用列表推导或者高阶函数 filter 来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>b = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">4</span>]<br><span class="hljs-comment">## Or:</span><br>b = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x &gt; <span class="hljs-number">4</span>, a)<br></code></pre></td></tr></table></figure><p>除了 filter 之外，还有 map、reduce 这两个函数也很好用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> i: i + <span class="hljs-number">3</span>, a)<br><span class="hljs-comment">## b: [6,7,8]</span><br></code></pre></td></tr></table></figure><h3 id="10-文件读取"><a href="#10-文件读取" class="headerlink" title="10. 文件读取"></a>10. 文件读取</h3><p>文件读取是非常常用的操作，在使用完句柄后，是需要手动调用 close 函数来关闭句柄的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(fp.read())<br>fp.close()<br></code></pre></td></tr></table></figure><p>如果代码写得太长，即使你知道需要手动关闭句柄，却也会经常会漏掉。因此推荐养成习惯使用 <code>with open</code> 来读写文件，上下文管理器会自动执行关闭句柄的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> fp.readlines():<br>        <span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure><h3 id="11-代码续行"><a href="#11-代码续行" class="headerlink" title="11. 代码续行"></a>11. 代码续行</h3><p>将一个长度较长的字符串放在一行中，是很影响代码可读性的(下面代码可向左滑动)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">long_string = <span class="hljs-string">&#x27;For a long time I used to go to bed early. Sometimes, when I had put out my candle, my eyes would close so quickly that I had not even time to say “I’m going to sleep.”&#x27;</span><br></code></pre></td></tr></table></figure><p>稍等注重代码可读性的人，会使用三个引号 <code>\</code>来续写 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">long_string = <span class="hljs-string">&#x27;For a long time I used to go to bed early. &#x27;</span> \<br>              <span class="hljs-string">&#x27;Sometimes, when I had put out my candle, &#x27;</span> \<br>              <span class="hljs-string">&#x27;my eyes would close so quickly that I had not even time to say “I’m going to sleep.”&#x27;</span><br></code></pre></td></tr></table></figure><p>不过，对我来说，我更喜欢这样子写 使用括号包裹 <code>()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">long_string = (<br>    <span class="hljs-string">&quot;For a long time I used to go to bed early. Sometimes, &quot;</span><br>    <span class="hljs-string">&quot;when I had put out my candle, my eyes would close so quickly &quot;</span><br>    <span class="hljs-string">&quot;that I had not even time to say “I’m going to sleep.”&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>导包的时候亦是如此</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> some.deep.module.inside.a.module <span class="hljs-keyword">import</span> (<br>    a_nice_function, another_nice_function, yet_another_nice_function)<br></code></pre></td></tr></table></figure><h3 id="12-显式代码"><a href="#12-显式代码" class="headerlink" title="12. 显式代码"></a>12. 显式代码</h3><p>有时候出于需要，我们会使用一些特殊的魔法来使代码适应更多的场景不确定性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_complex</span>(<span class="hljs-params">*args</span>):<br>    x, y = args<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(**<span class="hljs-built_in">locals</span>())<br></code></pre></td></tr></table></figure><p>但若非必要，请不要那么做。无端增加代码的不确定性，会让原先本就动态的语言写出更加动态的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_complex</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;x&#x27;</span>: x, <span class="hljs-string">&#x27;y&#x27;</span>: y&#125;<br></code></pre></td></tr></table></figure><h3 id="13-使用占位符"><a href="#13-使用占位符" class="headerlink" title="13. 使用占位符"></a>13. 使用占位符</h3><p>对于暂不需要，却又不得不接收的的变量，请使用占位符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;foobar.txt&#x27;</span><br>basename, _, ext = filename.rpartition(<span class="hljs-string">&#x27;.&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="14-链式比较"><a href="#14-链式比较" class="headerlink" title="14. 链式比较"></a>14. 链式比较</h3><p>对于下面这种写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">score = <span class="hljs-number">85</span><br><span class="hljs-keyword">if</span> score &gt; <span class="hljs-number">80</span> <span class="hljs-keyword">and</span> score &lt; <span class="hljs-number">90</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;良好&quot;</span>)<br></code></pre></td></tr></table></figure><p>其实还有更好的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">score = <span class="hljs-number">85</span><br><span class="hljs-keyword">if</span> <span class="hljs-number">80</span> &lt; score &lt; <span class="hljs-number">90</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;良好&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果你理解了上面的链式比较操作，那么你应该知道为什么下面这行代码输出的结果是 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> == <span class="hljs-literal">False</span> == <span class="hljs-literal">True</span> <br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="15-三目运算"><a href="#15-三目运算" class="headerlink" title="15. 三目运算"></a>15. 三目运算</h3><p>对于简单的判断并赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">20</span><br><span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;adult&quot;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">type</span> = <span class="hljs-string">&quot;teenager&quot;</span><br></code></pre></td></tr></table></figure><p>其实是可以使用三目运算，一行搞定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">20</span>  <br>b = <span class="hljs-string">&quot;adult&quot;</span> <span class="hljs-keyword">if</span> age &gt; <span class="hljs-number">18</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;teenager&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="11-5-【代码美化】写出漂亮-Python-代码的-20条准则"><a href="#11-5-【代码美化】写出漂亮-Python-代码的-20条准则" class="headerlink" title="11.5 【代码美化】写出漂亮 Python 代码的 20条准则"></a>11.5 【代码美化】写出漂亮 Python 代码的 20条准则</h2><p>通常，当我们在学校学习时，编程美学不是一个关键问题。用 Python 写代码时，个人也会遵循自己的风格。然而，当我们必须花大把时间来理解一个人的隐式代码时，这项工作肯定不受欢迎，这种情况同样可能发生在别人阅读我们的代码时。所以，让我们聚焦 Python 之禅和一些改进技巧，从而解决问题。</p><h3 id="1-Python-之禅？"><a href="#1-Python-之禅？" class="headerlink" title="1. Python 之禅？"></a>1. Python 之禅？</h3><p>对于此前没听说过的人，请在 Python 解释器中键入并执行<code>import this</code>，会出现由 Tim Peters 撰写的 19 条指导原则：</p><ol><li>优美胜于丑陋；</li><li>明了胜于晦涩；</li><li>简单胜于复杂；</li><li>复杂胜于晦涩；</li><li>扁平胜于嵌套；</li><li>间隔胜于紧凑；</li><li>可读性很重要；</li><li>特例不足以特殊到违背这些原则；</li><li>实用性胜过纯粹；</li><li>永远不要默默地忽视错误；</li><li>除非明确需要这样做；</li><li>面对模棱两可，拒绝猜测；</li><li>解决问题最直接的方法应该有一种，最好只有一种；</li><li>当然这是没法一蹴而就的，除非你是荷兰人；</li><li>做也许好过不做；</li><li>但不想就做还不如不做；</li><li>如果方案难以描述明白，那么一定是个糟糕的方案；</li><li>如果实现容易描述，那可能是个好方案；</li><li>命名空间是一种绝妙的理念，多加利用！</li></ol><p>在这篇文章中，我将分享自己对这些格言的理解以及我学到的一些有用的 Python 技巧。</p><h3 id="2-优美胜于丑陋"><a href="#2-优美胜于丑陋" class="headerlink" title="2. 优美胜于丑陋"></a>2. 优美胜于丑陋</h3><p>Python 具有语法简单、代码可读性强和命令类似英语等特点，这让编写 Python 代码比使用其他编程语言更容易、更高效。例如，使用<code>or</code> <code>and</code>和<code>|| &amp;&amp;</code>构建语义相同的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## &amp;&amp;, ||</span><br><span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span> &amp;&amp; b == <span class="hljs-number">1</span> || c == <span class="hljs-literal">True</span>:<br><br><span class="hljs-comment">## and, or</span><br><span class="hljs-keyword">if</span> a == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> b == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> c == <span class="hljs-literal">True</span>:<br><br><span class="hljs-comment">## 这两个逻辑表达式在 Python 中是相同的</span><br><span class="hljs-comment">## 从语义的角度来看，可以使用选择操作符来构造完全相同的表达式。</span><br></code></pre></td></tr></table></figure><p>此外，代码的布局和组成非常重要，有大量资源涉及这个主题。下面是最受欢迎也是我最喜欢的一个：PEP 8——Python 代码风格指南。</p><p><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p><p>浏览完 PEP8 后，看看下面这些文章，其中展示了一些亮点和应用：</p><ul><li><p>如何参照 PEP 8 编写漂亮的 Python 代码</p><p><a href="https://realpython.com/python-pep8/">https://realpython.com/python-pep8/</a></p></li><li><p>优雅的 Python 与 PEP8</p><p><a href="https://medium.com/@mariasurmenok/stylish-python-with-pep8-c3ca93531418">https://medium.com/@mariasurmenok/stylish-python-with-pep8-c3ca93531418</a></p></li><li><p>PEP-8 的陷阱</p><p><a href="https://medium.com/@ian.reinert/the-pitfalls-of-pep-8-b6108b006ed9">https://medium.com/@ian.reinert/the-pitfalls-of-pep-8-b6108b006ed9</a></p></li></ul><p>永远不要弄乱你的代码。要优雅而美丽。</p><h3 id="3-明了胜于晦涩"><a href="#3-明了胜于晦涩" class="headerlink" title="3. 明了胜于晦涩"></a>3. 明了胜于晦涩</h3><p>在 Python 中，良好的命名约定不仅可以提升你的课堂成绩，而且还能让你的代码更明了。幸运的是，你能在 PEP8 中找到一些指导原则，我想在下面强调其中的一些要点。</p><p><a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></p><ul><li>一般来说，避免使用以下名称：</li><li>太宽泛，如<code>my_list</code>；</li><li>太冗长，如<code>list_of_machine_learning_data_set</code>；</li><li>太模糊，如“1”、“I”、“o”、“O”。</li><li>包 &#x2F; 模块名应该全部小写：</li><li>首选使用一个单词命名；</li><li>当需要使用多个单词时，使用下划线分割它们。</li><li>类名应遵循 UpperCaseCamelCase 规范</li><li>变量\方法\函数应该采用小写（如果需要，用下划线分割）</li><li>常量名必须全大写（如果需要，用下划线分割）</li></ul><p>一切都必须清晰易懂。</p><h3 id="4-简单胜于复杂"><a href="#4-简单胜于复杂" class="headerlink" title="4. 简单胜于复杂"></a>4. 简单胜于复杂</h3><blockquote><p>简单比复杂更难：你必须付出巨大艰辛，化繁为简。但这一切到最后都是值得的，因为一旦你做到了，你便能创造奇迹。——乔布斯</p></blockquote><p>很多时候，在处理迭代器时，我们还需要保存迭代计数。Python 通过提供一个名为<code>enumerate()</code>的内置函数简化这一任务。以下是一种不成熟的方法，然后是推荐方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">words = [<span class="hljs-string">&#x27;Hannibal&#x27;</span>, <span class="hljs-string">&#x27;Hanny&#x27;</span>, <span class="hljs-string">&#x27;Steeve&#x27;</span>]<br><span class="hljs-comment">## 不成熟的方法</span><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>    <span class="hljs-built_in">print</span>(index, word)<br>    index += <span class="hljs-number">1</span><br><br><span class="hljs-comment">## 推荐方法</span><br><span class="hljs-keyword">for</span> index, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(words):<br>    <span class="hljs-built_in">print</span>(index, word)<br></code></pre></td></tr></table></figure><p>另一个示例是使用内置的<code>zip()</code>函数，该函数创建一个迭代器，对来自两个或多个迭代器的元素进行配对。你可以使用它来快速有效地解决常见的编程问题，比如创建字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">subjects = [<span class="hljs-string">&#x27;math&#x27;</span>, <span class="hljs-string">&#x27;chemistry&#x27;</span>, <span class="hljs-string">&#x27;biology&#x27;</span>, <span class="hljs-string">&#x27;pyhsics&#x27;</span>]<br>grades = [<span class="hljs-string">&#x27;100&#x27;</span>, <span class="hljs-string">&#x27;83&#x27;</span>, <span class="hljs-string">&#x27;90&#x27;</span>, <span class="hljs-string">&#x27;92&#x27;</span>]<br>grades_dict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(subjects, grades))<br><span class="hljs-built_in">print</span>(grades_dict)<br></code></pre></td></tr></table></figure><p>化繁为简的能力就是消除不必要的东西，保留必要的东西。</p><h3 id="5-复杂胜于晦涩"><a href="#5-复杂胜于晦涩" class="headerlink" title="5. 复杂胜于晦涩"></a>5. 复杂胜于晦涩</h3><p>复杂（complex ）和晦涩（complicated ）的区别在于，复杂是指组件的系统层级，晦涩是指难度高。</p><p>有时候，尽管我们试图让任务变得简单和傻瓜化，结果可能仍然很糟。</p><p>在这种情况下，编程优化变得很有必要，我最喜欢的学习方法是完成 coding challenge websites 上的工作。你可以查看其他人的解决方案，甚至能受到更好算法的启发。</p><p><a href="https://www.freecodecamp.org/news/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f/">https://www.freecodecamp.org/news/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f/</a></p><p>对于入门，HackerRank 提供了适合新手程序员的各种级别任务，这非常棒。之后，可以去尝试更专业的网站，比如 Coderbyte 和 Topcoder。</p><h3 id="6-扁平胜于嵌套"><a href="#6-扁平胜于嵌套" class="headerlink" title="6. 扁平胜于嵌套"></a>6. 扁平胜于嵌套</h3><p>嵌套模块在 Python 中并不常见——至少我之前没有见过像<code>module.class.subclass.function</code>这样的东西——可读性不好。虽然在另一个子模块中构建子模块可能会减少代码行数，但我们不希望用户被不直观的语法所困扰。</p><h3 id="7-间隔胜于紧凑"><a href="#7-间隔胜于紧凑" class="headerlink" title="7. 间隔胜于紧凑"></a>7. 间隔胜于紧凑</h3><p>不要在一行中插入太多代码，这会给读者带来压力。建议最大行长度 79 个字符。这样，当使用代码评审工具时，编辑器窗口宽度限制才能很好工作。</p><p><img src="https://image.iswbm.com/20221211103823.png"></p><p>使用 Python 从 Unsplash 下载图片</p><h3 id="8-可读性很重要"><a href="#8-可读性很重要" class="headerlink" title="8. 可读性很重要"></a>8. 可读性很重要</h3><p>代码的阅读次数比编写次数多。考虑下缩进，它让代码更容易阅读，比较下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">money = <span class="hljs-number">10000000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I earn&quot;</span>, money, <span class="hljs-string">&quot;dollars by writing on medium.&quot;</span>)<br><br>money = <span class="hljs-number">10_000_000</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;I earn <span class="hljs-subst">&#123;money&#125;</span> dollars by writing on medium.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在本例中，代码结果相同，但是后一段代码通过使用下划线占位符和 f-string 提供了更好的可读性。在 Python 3.6 发布后，f-string 开始让格式化变得更简单，并且在处理包含更多变量的更长的句子时更强大。</p><blockquote><p>一个作家的风格不应该在他的思想和读者的思想间设置障碍。</p></blockquote><h3 id="9-特例不足以特殊到违背这些原则"><a href="#9-特例不足以特殊到违背这些原则" class="headerlink" title="9. 特例不足以特殊到违背这些原则"></a>9. 特例不足以特殊到违背这些原则</h3><p>关键是为一般情况提供一贯支持，尝试将一个繁琐的项目重新组织成一个简单形式。例如，根据其功能，结构化类的代码或将其分类到不同的文件中，即使 Python 并不强迫你这样做。由于 Python 是一种多范式编程语言，解决问题的一个强大方法是创建对象，这就是所谓的面向对象编程。</p><p>面向对象编程是一种组织程序结构的编程范式，让属性和行为可以被看作是单独对象。它的优点是直观和易于操作，许多教程都很好地解释了这些概念。</p><h3 id="10-实用性胜过纯粹"><a href="#10-实用性胜过纯粹" class="headerlink" title="10. 实用性胜过纯粹"></a>10. 实用性胜过纯粹</h3><p>这句格言与前一句相矛盾，它提醒我们保持它们之间的平衡</p><h3 id="11-永远不要默默地忽视错误"><a href="#11-永远不要默默地忽视错误" class="headerlink" title="11. 永远不要默默地忽视错误"></a>11. 永远不要默默地忽视错误</h3><p>放过错误最终会留下隐式 Bug，并且这些 Bug 更难被发现。Python 提供了健壮的错误处理，与其他语言相比，程序员使用该工具并不难。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Please enter an Integer: &quot;</span>))<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Oops! This is not an Integer.&quot;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br>    <span class="hljs-built_in">print</span>(err)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You did it! Great job!&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ヽ(✿ﾟ▽ﾟ)ノ&#x27;</span>)<br><br><span class="hljs-comment">## 1. 这段代码可能中断。</span><br><span class="hljs-comment">## 2. 如果出现值错误就会触发。</span><br><span class="hljs-comment">## 3. 处理值错误之外的错误。</span><br><span class="hljs-comment">## 4. 如果没有触发错误就执行。</span><br><span class="hljs-comment">## 5. 不管是否触发错误都执行。</span><br></code></pre></td></tr></table></figure><p>根据 Python 文档：“即使一个语句或表达式在语法上是正确的，在试图执行它时也可能会导致错误。”特别是对于大型项目，我们不希望在耗时的计算后，代码崩溃。这就是异常管理的魅力所在。</p><h3 id="12-除非明确需要这样做"><a href="#12-除非明确需要这样做" class="headerlink" title="12. 除非明确需要这样做"></a>12. 除非明确需要这样做</h3><p>在某些情况下，小错误不会困扰你。不过，也许你想捕获特定错误。要获得关于特定错误消息的更多细节，我建议阅读官方的内置异常文档并找到你需要的内容。</p><p><a href="https://docs.python.org/3/library/exceptions.html">https://docs.python.org/3/library/exceptions.html</a></p><h3 id="13-面对模棱两可，拒绝猜测"><a href="#13-面对模棱两可，拒绝猜测" class="headerlink" title="13. 面对模棱两可，拒绝猜测"></a>13. 面对模棱两可，拒绝猜测</h3><blockquote><p>重要的是要不断学习，享受挑战，容忍歧义。我们都不知道最终会怎样。——玛蒂娜·霍纳</p></blockquote><p>这句话优雅而抒情，但在编程中不是一个好的隐喻。歧义可能是指不清楚的语法、复杂的程序结构或触发错误消息的错误。例如，第一次使用<code>numpy</code>模块时的一个简单错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.arange(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(a &lt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;smaller than 3&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>ValueError: 具有多个元素的数组的真值不明确，请使用 a.any() 或 a.all()</p></blockquote><p>如果执行上面代码，你将在输出中发现一个由 5 个布尔值组成的数组，表明值在 3 以下。因此，<code>if</code>语句不可能确定状态。消息中显示的内置函数<code>.all</code>() 和<code>.any()</code>用于代替 And&#x2F;Or。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])<br>b = np.array([<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>])<br>c = np.array([<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>])<br><br><span class="hljs-built_in">print</span>(a.<span class="hljs-built_in">all</span>())<br><span class="hljs-built_in">print</span>(a.<span class="hljs-built_in">any</span>())<br><br><span class="hljs-built_in">print</span>(b.<span class="hljs-built_in">all</span>())<br><span class="hljs-built_in">print</span>(b.<span class="hljs-built_in">any</span>())<br><br><span class="hljs-built_in">print</span>(c.<span class="hljs-built_in">all</span>())<br><span class="hljs-built_in">print</span>(c.<span class="hljs-built_in">any</span>())<br></code></pre></td></tr></table></figure><p>输出表明，<code>.all()</code>仅在所有项都为<code>True</code>时才返回<code>True</code>，而.<code>any()</code>在有一项为<code>True</code>时就返回<code>True</code>。</p><h3 id="14-解决问题最直接的方法应该有一种，最好只有一种"><a href="#14-解决问题最直接的方法应该有一种，最好只有一种" class="headerlink" title="14. 解决问题最直接的方法应该有一种，最好只有一种"></a>14. 解决问题最直接的方法应该有一种，最好只有一种</h3><p>想想为什么 Python 被描述为一种易于学习的编程语言。Python 具有非凡的内置函数 &#x2F; 库和高度的可扩展性，它鼓励程序员优雅地编写代码。尽管有更多的解决方案可以提供灵活性，但对于同一个问题，它们可能会花费更多时间。</p><p><img src="https://image.iswbm.com/20221211103910.png"></p><p>输入 import antigravity 并执行</p><h3 id="15-当然这是没法一蹴而就的，除非你是荷兰人"><a href="#15-当然这是没法一蹴而就的，除非你是荷兰人" class="headerlink" title="15. 当然这是没法一蹴而就的，除非你是荷兰人"></a>15. 当然这是没法一蹴而就的，除非你是荷兰人</h3><p>Python 之父 Guido van Rossum 是一位荷兰程序员，他让这句格言变得无可争议。你不会声称自己比他更了解 Python……至少我不会。</p><h3 id="16-做也许好过不做"><a href="#16-做也许好过不做" class="headerlink" title="16. 做也许好过不做"></a>16. 做也许好过不做</h3><blockquote><p>你可以拖延，但时间不会，失去的时间一去不复返。——本杰明·富兰克林</p></blockquote><p>对于那些像我一样患有拖延症，正在寻求改变的人，看看这个，和恐慌怪兽合作。</p><p><a href="https://embed.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator">https://embed.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator</a></p><p>另一方面，这个格言的另一个方面是阻止你过度计划，这并不比看 Netflix 更有效率。</p><p>拖延和过度计划的共同特征就是“什么都做不了。”</p><h3 id="17-不想就做还不如不做"><a href="#17-不想就做还不如不做" class="headerlink" title="17. 不想就做还不如不做"></a>17. 不想就做还不如不做</h3><p>“做也许好过不做”并不意味着计划没用。把你的想法写下来，设定一个要征服的目标，比不想就做要好。</p><p>例如，我通常在每个星期天花一个小时来制定我的周计划，并在睡觉前更新我明天的计划，看看有什么需要推迟的事情。</p><h3 id="18-如果解决方案难以解释清楚，那一定很糟糕"><a href="#18-如果解决方案难以解释清楚，那一定很糟糕" class="headerlink" title="18. 如果解决方案难以解释清楚，那一定很糟糕"></a>18. 如果解决方案难以解释清楚，那一定很糟糕</h3><p>回想一下“复杂胜于晦涩”的理念。通常，晦涩的代码意味着弱设计，特别是在像 Python 这样的高级编程语言中。</p><p>然而，在某些情况下，其领域知识的复杂性可能会让实现难以解释，而如何优化让其明晰易懂至关重要。这里有一个规划项目指南，可以给你提供帮助。</p><p><a href="https://docs.python-guide.org/writing/structure/">https://docs.python-guide.org/writing/structure/</a></p><h3 id="19-如果实现容易描述，那可能是个好方案"><a href="#19-如果实现容易描述，那可能是个好方案" class="headerlink" title="19. 如果实现容易描述，那可能是个好方案"></a>19. 如果实现容易描述，那可能是个好方案</h3><p>使设计（甚至人们的生活）更容易，即使背景知识可能很深刻，这是编程的专业知识，我认为也是编程中最困难的部分。</p><p>利用 Python 的简单性和可读性来实现一些疯狂的想法。</p><h3 id="20-命名空间是一种绝妙的理念，多加利用！"><a href="#20-命名空间是一种绝妙的理念，多加利用！" class="headerlink" title="20. 命名空间是一种绝妙的理念，多加利用！"></a>20. 命名空间是一种绝妙的理念，多加利用！</h3><p>最后但同样重要的是，命名空间是一组符号，用于组织各种对象，以便这些对象可以通过惟一的名称引用。在 Python 中，命名空间是由以下元素组成的系统：</p><ol><li>内置命名空间：可以在不创建自定义函数或导入模块（如<code>print()</code>函数）的情况下调用。</li><li>全局命名空间：当用户创建一个类或函数时，将创建一个全局命名空间。</li><li>局部命名空间：局部作用域中的命名空间。</li></ol><p><img src="https://image.iswbm.com/20221211103952.png"><br>命名空间关系图</p><p>命名空间系统可以防止 Python 模块名称之间产生冲突。</p><p>延展阅读：</p><p><a href="https://medium.com/better-programming/how-to-make-python-programming-more-elegant-and-decent-4b5962695aa9">https://medium.com/better-programming/how-to-make-python-programming-more-elegant-and-decent-4b5962695aa9</a></p><h2 id="11-6-【代码美化】择优选择-EAFP-和-LBYL-代码风格"><a href="#11-6-【代码美化】择优选择-EAFP-和-LBYL-代码风格" class="headerlink" title="11.6 【代码美化】择优选择 EAFP 和 LBYL 代码风格"></a>11.6 【代码美化】择优选择 EAFP 和 LBYL 代码风格</h2><h3 id="1-EAFP-风格"><a href="#1-EAFP-风格" class="headerlink" title="1. EAFP 风格"></a>1. EAFP 风格</h3><p>Python 有一套自己的哲学，其中 EAFP 是其中比较有名的。它的全称是</p><blockquote><p>Easier to Ask for Forgiveness than Permission</p></blockquote><p>强行翻译一下，就是 <strong>寻求原谅比获得授权更容易</strong>。</p><p>对于第一次接触这个 EAFP 名词的同学，可能不好理解这句话的意思。</p><p>没有关系，咱先看一下 EAFP 风格的代码是什么样的，你就能立马 get 了。</p><p>下面这段代码，我在 try 里使用 <code>[key]</code> 的方法获取字典一个 value 值，但是由于 profile 并没有 age 的键。所以会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>&#125;<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(profile[<span class="hljs-string">&quot;age&quot;</span>])<br><span class="hljs-keyword">except</span> KeyError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Key is not exist&quot;</span>)<br></code></pre></td></tr></table></figure><p>像这种，先相信代码本身没有问题，任其执行，有问题了再通过捕获进行处理的代码风格，就叫做 EAFP 风格。</p><p>我个人把这种写法，称之为 <strong>面向崩溃编程</strong>。</p><h3 id="2-LBYL-风格"><a href="#2-LBYL-风格" class="headerlink" title="2. LBYL 风格"></a>2. LBYL 风格</h3><p>LBYL 的全称是 </p><blockquote><p>Look Before You Leap</p></blockquote><p>翻译一下，就是 <code>你跳之前先看看</code>，这是一种比较保守的写法。这种写法可能会有让你写很多的 if 判断语句来规避可能出现错误的各种场景。</p><p>还是以上面的代码为例，使用 LBYL 风格来写的话，是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">profile = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;王炳明&quot;</span>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;age&quot;</span> <span class="hljs-keyword">in</span> profile:<br>    <span class="hljs-built_in">print</span>(profile[<span class="hljs-string">&quot;age&quot;</span>])<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Key is not exist&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-选择哪种风格？"><a href="#3-选择哪种风格？" class="headerlink" title="3. 选择哪种风格？"></a>3. 选择哪种风格？</h3><p>用一个生动的例子来描述他们的区别。</p><p>有一对小伙伴一起约去某名山游玩，由于这座山比较险峻，有各种各校的悬崖。</p><p>伙伴A，是一个比较大胆开放的人，他自己穿上了降落伞，所以在游玩的时候，无所顾忌，都不看路，一旦不小心跌落悬崖了也有降落伞保命。  – <code>这是 EAFP 风格</code></p><p>而伙伴B，是一个比较保守的人，他没有穿降落伞，所以每走一走都要看一看，前面是不是悬崖。– <code>这是 LBLY 风格</code></p><p>EAFP虽然是 Python 比较推荐的一种编码风格，但更多情况下，这两种风格会同时存在于你的代码中代码风格的目的是增强代码的可读性和健壮性，在有些场景下 EAFP 风格更加易读，在有些场景下 LBLY 风格更加易读，因此不必纠结使用哪种风格，具体情况应该具体分析。## 11.7 【代码美化】使用 flake8 保证代码风格</p><p><code>pep8</code> 是Python 语言的一个代码编写规范。如若你是新手，目前只想快速掌握基础，而不想过多去注重代码的的编写风格（虽然这很重要），那你可以尝试一下这个工具 - <code>autopep8</code></p><p>首先在全局环境中（不要在虚拟环境中安装），安装一下这个工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo pip install autopep8<br></code></pre></td></tr></table></figure><p>然后在 PyCharm 导入这个工具，具体设置如下图</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">Name:</span> <span class="hljs-title class_">AutoPep8</span><br><span class="hljs-symbol">Description:</span> autopep8 your code<br><span class="hljs-symbol">Program:</span> autopep8<br><span class="hljs-symbol">Arguments:</span> --<span class="hljs-keyword">in</span>-place --aggressive --aggressive <span class="hljs-variable">$FilePath</span><span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-title class_">Working</span> <span class="hljs-symbol">directory:</span> <span class="hljs-variable">$ProjectFileDir</span><span class="hljs-variable">$</span><br><span class="hljs-variable"></span><span class="hljs-title class_">Output</span> <span class="hljs-symbol">filters:</span> <span class="hljs-variable">$FILE_PATH</span><span class="hljs-variable">$\</span><span class="hljs-symbol">:</span><span class="hljs-variable">$LINE</span><span class="hljs-variable">$\</span><span class="hljs-symbol">:</span><span class="hljs-variable">$COLUMN</span><span class="hljs-variable">$\</span><span class="hljs-symbol">:</span>.*<br></code></pre></td></tr></table></figure><p><img src="http://image.iswbm.com/20190323164120.png"></p><p>我随意写了一段不符合 pep8 规范的代码。</p><p><img src="http://image.iswbm.com/20190323211635.png"></p><p>点击右键，选择 <code>External Tools</code> -&gt; <code>AutoPep8</code></p><p><img src="http://image.iswbm.com/20190323211301.png"></p><p>看一下效果，还是挺明显的。</p><p><img src="http://image.iswbm.com/20190324111603.png"></p><p>你可能会说，Pycharm 本身就自带这个功能了呀，快捷键 <code>Command</code>+<code>Option</code>+<code>L</code> ，就可以实现一键pep8了。你可以对比一下，Pycharm 自带的代码 pep8 化功能 并没有像这个<code>autopep8</code> 来得彻底。 我相信你最终的选择肯定是后者。</p><h1 id="第十二章：虚拟环境"><a href="#第十二章：虚拟环境" class="headerlink" title="第十二章：虚拟环境"></a>第十二章：虚拟环境</h1><h2 id="12-1-【虚拟环境】为什么要有虚拟环境？"><a href="#12-1-【虚拟环境】为什么要有虚拟环境？" class="headerlink" title="12.1 【虚拟环境】为什么要有虚拟环境？"></a>12.1 【虚拟环境】为什么要有虚拟环境？</h2><p>虚拟环境的意义，就如同虚拟机 一样，它可以实现不同环境中Python依赖包相互独立，互不干扰。</p><p>举个例子吧。</p><p>假设我们的电脑里有两个项目，他们都用到同一个第三方包，本来一切都顺利。但是由于某种原因，项目B由于某些原因要使用这个第三方包的一些新特性（新版本才有），而如果就这样贸然升级了，对项目A的影响我们无法评估，这个时候我们就特别需要有一种解决方案可以让项目A和B，处于两个不同的Python环境中。互不影响。</p><p>为了方便大家对虚拟环境有个认识，我列举了下其优点：</p><ul><li>使不同应用开发环境独立</li><li>环境升级不影响其他应用，也不会影响全局的python环境</li><li>可以防止系统中出现包管理混乱和版本的冲突</li></ul><p>市场上管理 Python 版本和环境的工具有很多，这里列举几个：</p><ul><li><code>p</code>：非常简单的交互式 python 版本管理工具。</li><li><code>pyenv</code>：简单的 Python 版本管理工具。</li><li><code>Vex</code>：可以在虚拟环境中执行命令。</li><li><code>virtualenv</code>：创建独立 Python 环境的工具。</li><li><code>virtualenvwrapper</code>：virtualenv 的一组扩展。</li></ul><p>工具很多，但个人认为最好用的，当属 <code>virtualenvwrapper</code>，推荐大家也使用。 ## 12.2 【虚拟环境】方案一：使用 virtualenv</p><h3 id="1-安装virtualenv"><a href="#1-安装virtualenv" class="headerlink" title="1. 安装virtualenv"></a>1. 安装virtualenv</h3><p>由于 virtualenvwrapper 是 virtualenv 的一组扩展，所以如果要使用 virtualenvwrapper，就必须先安装 virtualenv。</p><p><strong>基本使用</strong></p><p>由于virtualenv创建虚拟环境是在当前环境下创建的。所以我们要准备一个专门存放虚拟环境的目录。（以下操作在Linux在完成，windows相对简单，请自行完成，有不明白的请微信与我联系。）</p><p><strong>创建</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 准备目录并进入</span><br>$ <span class="hljs-built_in">mkdir</span> -p /home/wangbm/Envs<br>$ <span class="hljs-built_in">cd</span> !$<br><br><span class="hljs-comment">## 创建虚拟环境（按默认的Python版本）</span><br><span class="hljs-comment">## 执行完，当前目录下会有一个my_env01的目录</span><br>$ virtualenv my_env01<br><br><span class="hljs-comment">## 你也可以指定版本</span><br>$ virtualenv -p /usr/bin/python2.7 my_env01<br>$ virtualenv -p /usr/bin/python3.6 my_env02<br><br><span class="hljs-comment">## 你肯定觉得每次都要指定版本，相当麻烦吧？</span><br><span class="hljs-comment">## 在Linux下，你可以把这个选项写进入环境变量中</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7&quot;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p><strong>进入&#x2F;退出</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home/wangbm/Envs<br><br><span class="hljs-comment">## 进入</span><br>$ <span class="hljs-built_in">source</span> my_env01/bin/activate<br><br><span class="hljs-comment">## 退出</span><br>$ deactivate<br></code></pre></td></tr></table></figure><p><strong>删除</strong><br>删除虚拟环境，只需删除对应的文件夹就行了。并不会影响全局的Python和其他环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home/wangbm/Envs<br>$ <span class="hljs-built_in">rm</span> -rf my_env01<br></code></pre></td></tr></table></figure><blockquote><p>注意：<br>创建的虚拟环境，不会包含原生全局环境的第三方包，其会保证新建虚拟环境的干净。</p></blockquote><p>如果你需要和全局环境使用相同的第三方包。可以使用如下方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 导出依赖包</span><br>$ pip freeze &gt; requirements.txt<br><br><span class="hljs-comment">## 安装依赖包</span><br>$ pip install -r requirements.txt <br></code></pre></td></tr></table></figure><h3 id="2-使用-virtualenvwrapper"><a href="#2-使用-virtualenvwrapper" class="headerlink" title="2. 使用 virtualenvwrapper"></a>2. 使用 virtualenvwrapper</h3><p>virtualenv 虽然已经相当好用了，可是功能还是不够完善。</p><p>你可能也发现了，要进入虚拟环境，必须得牢记之前设置的虚拟环境目录，如果你每次按规矩来，都将环境安装在固定目录下也没啥事。但是很多情况下，人是会懒惰的，到时可能会有很多个虚拟环境散落在系统各处，你将有可能忘记它们的名字或者位置。</p><p>还有一点，virtualenv 切换环境需要两步，退出 -&gt; 进入。不够简便。</p><p>为了解决这两个问题，virtualenvwrapper就诞生了。</p><p><strong>安装</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 安装 - Linux</span><br>pip install virtualenvwrapper<br><br><span class="hljs-comment">## 安装 - Windows</span><br>pip install virtualenvwrapper-win<br></code></pre></td></tr></table></figure><p><strong>配置</strong><br>先find一下<code>virtualenvwrapper.sh</code>文件的位置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">find / <span class="hljs-literal">-name</span> virtualenvwrapper.sh<br><span class="hljs-comment">## /usr/bin/virtualenvwrapper.sh</span><br></code></pre></td></tr></table></figure><p>若是 windows 则使用everything 查找 virtualenvwrapper.bat 脚本</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">D:<span class="hljs-string">\Program</span> Files (x86)<span class="hljs-string">\Python38-32\Scripts\virtualenvwrapper.bat</span><br></code></pre></td></tr></table></figure><p>在~&#x2F;.bashrc 文件新增配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">WORKON_HOME</span>=<span class="hljs-variable">$HOME</span>/.virtualenvs<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PROJECT_HOME</span>=<span class="hljs-variable">$HOME</span>/workspace<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">VIRTUALENVWRAPPER_SCRIPT</span>=/usr/bin/virtualenvwrapper.sh<br>source /usr/bin/virtualenvwrapper.sh<br></code></pre></td></tr></table></figure><p>若是 windows 则新增环境变量：<code>WORKON_HOME</code></p><p><img src="http://image.iswbm.com/20200209161935.png"></p><p><strong>基本语法</strong>：</p><p>mkvirtualenv [-a project_path] [-i package] [-r requirements_file] [virtualenv options] ENVNAME</p><p><strong>常用方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建</span><br>$ mkvirtualenv my_env01<br><br><span class="hljs-comment">## 进入</span><br>$ workon my_env01<br><br><span class="hljs-comment">## 退出</span><br>$ deactivate<br><br><span class="hljs-comment">## 列出所有的虚拟环境，两种方法</span><br>$ workon<br>$ lsvirtualenv<br><br><span class="hljs-comment">## 在虚拟环境内直接切换到其他环境</span><br>$ workon my_env02<br><br><span class="hljs-comment">## 删除虚拟环境</span><br>$ rmvirtualenv my_env01<br></code></pre></td></tr></table></figure><p><strong>其他命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 列出帮助文档</span><br>$ virtualenvwrapper<br><br><span class="hljs-comment">## 拷贝虚拟环境</span><br>$ cpvirtualenv ENVNAME [TARGETENVNAME]<br><br><span class="hljs-comment">## 在所有的虚拟环境上执行命令</span><br>$ allvirtualenv pip install -U pip<br><br><span class="hljs-comment">## 删除当前环境的所有第三方包</span><br>$ wipeenv<br><br><span class="hljs-comment">## 进入到当前虚拟环境的目录</span><br>$ cdsitepackages<br><br><span class="hljs-comment">## 进入到当前虚拟环境的site-packages目录</span><br>$ cdvirtualenv<br><br><span class="hljs-comment">## 显示 site-packages 目录中的内容</span><br>$ lssitepackages<br></code></pre></td></tr></table></figure><p>更多内容，可查看 官方文档<br><a href="https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html">https://virtualenvwrapper.readthedocs.io/en/latest/command_ref.html</a></p><h3 id="3-实战演示"><a href="#3-实战演示" class="headerlink" title="3. 实战演示"></a>3. 实战演示</h3><p>以上内容，是一份使用指南。接下来，一起来看看，如何在项目中使用虚拟环境。</p><p>如何使用在我们的开发中使用我们的虚拟环境呢</p><p>通常我们使用的场景有如下几种</p><ul><li>交互式中</li><li>PyCharm中</li><li>工程中</li></ul><p>接下来，我将一一展示。</p><h4 id="3-1-交互式中"><a href="#3-1-交互式中" class="headerlink" title="3.1 交互式中"></a>3.1 交互式中</h4><p>先对比下，全局环境和虚拟环境的区别，全局环境中有requests包，而虚拟环境中并未安装。<br>当我们敲入 <code>workon my_env01</code>，前面有<code>my_env01</code>的标识，说明我们已经处在虚拟环境中。后面所有的操作，都将在虚拟环境下执行。<br><img src="https://i.loli.net/2018/06/11/5b1e7d36ce8ad.png"></p><h4 id="3-2-工程项目中"><a href="#3-2-工程项目中" class="headerlink" title="3.2 工程项目中"></a>3.2 工程项目中</h4><p>我们的工程项目，都有一个入口文件，仔细观察，其首行可以指定Python解释器。</p><p>倘若我们要在虚拟环境中运行这个项目，只要更改这个文件头部即可。</p><p>现在我还是以，<code>import requests</code> 为例，来说明，是否是在虚拟环境下运行的，如果是，则和上面一样，会报错。</p><p>文件内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/root/.virtualenvs/my_env01/bin/python</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;ok&quot;</span><br></code></pre></td></tr></table></figure><p>运行前，注意添加执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> +x ming.py<br></code></pre></td></tr></table></figure><p>好了。来执行一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./ming.py<br></code></pre></td></tr></table></figure><p>发现和预期一样，真的报错了。说明我们指定的虚拟环境有效果。<br><img src="https://i.loli.net/2018/06/11/5b1e7f140be6a.png"></p><h4 id="3-3-PyCharm中"><a href="#3-3-PyCharm中" class="headerlink" title="3.3 PyCharm中"></a>3.3 PyCharm中</h4><p>点击 File - Settings - Project - Interpreter<br><img src="https://i.loli.net/2018/06/11/5b1e805c996c8.png"><br>点击小齿轮。如图点击添加，按提示添加一个虚拟环境。然后点 OK 就可以使用这个虚拟环境，之后的项目都会在这个虚拟环境下运行。<br><img src="https://i.loli.net/2018/06/11/5b1e812db603f.png"></p><p><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="12-3-【虚拟环境】方案二：使用-pipenv"><a href="#12-3-【虚拟环境】方案二：使用-pipenv" class="headerlink" title="12.3 【虚拟环境】方案二：使用 pipenv"></a>12.3 【虚拟环境】方案二：使用 pipenv</h2><p>以前一直使用pip+virtualenv+virtualwrapper管理模块和环境， 但是virtualwrapper在windows上使用不太方便，而且包和环境分开管理确实经常不记得哪个是哪个了。 </p><p>为什么 会推荐 pipenv 呢？</p><ul><li>它是 <code>virtualenv</code> 和 <code>pip</code> 的合体，可以合起来使用；</li><li>使用<code>Pipfile</code> 和 <code>Pipfile.lock</code>替代<code>requirements.txt</code></li><li>可以使用 <code>pipenv graph</code>很方便的看出包的依赖关系。</li><li>通过加载<code>.env</code>文件简化开发工作流程</li></ul><h3 id="1-安装pipenv"><a href="#1-安装pipenv" class="headerlink" title="1. 安装pipenv"></a>1. 安装pipenv</h3><p>如果你的电脑上没有安装 pipenv，可以使用如下方法安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># mac</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install pipenv</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># windows</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install [--user] pipenv</span><br></code></pre></td></tr></table></figure><p>如果你的电脑是 windows 的。</p><p><img src="http://image.iswbm.com/Fk6WZ2xbqg2DM3AvnYCpsiKQ4xOn"></p><p>需要将如标示路径，加入到 环境变量 PATH 中。</p><p><img src="http://image.iswbm.com/FjuJ8yZsgjkzVuBRZHxK1ZnnzaEX"></p><p>然后需要重启一下，CMD 终端才能够刷新环境变量。</p><h3 id="2-创建虚拟环境"><a href="#2-创建虚拟环境" class="headerlink" title="2. 创建虚拟环境"></a>2. 创建虚拟环境</h3><p>DjangoWebBlog 是我们的项目目录，进入这个目录下创建虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> DjangoWebBlog &amp;&amp; <span class="hljs-built_in">cd</span> DjangoWebBlog</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在当前目录下创建一个虚拟环境（默认的Python版本）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install</span><br></code></pre></td></tr></table></figure><p>你也可以指定版本创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --two      <span class="hljs-comment"># 相当于 pipenv --python /usr/bin/python2</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --three    <span class="hljs-comment"># 相当于 pipenv --python /usr/bin/python3</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --python 3.7 <span class="hljs-comment"># 也可以指定具体的版本</span></span><br>pipenv install --python 2<br></code></pre></td></tr></table></figure><p>这边以安装 python2 版本的虚拟环境为例说明。</p><p><img src="http://image.iswbm.com/20190612211330.png"></p><p>如果你原项目使用的是 requirements.txt 这个管理包的方式，这时候执行 <code>pipenv --tow</code> 创建一个虚拟环境后，会找到 requirements.txt ，并根据这里面的依赖包生成 Pipfile文件。</p><p><img src="http://image.iswbm.com/20190612213015.png"></p><h3 id="3-查询虚拟环境"><a href="#3-查询虚拟环境" class="headerlink" title="3. 查询虚拟环境"></a>3. 查询虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 返回项目的路径</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --<span class="hljs-built_in">where</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 返回虚拟环境路径</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --venv</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 返回该虚拟环境的解释器</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --py</span><br></code></pre></td></tr></table></figure><p>演示如下：</p><p><img src="http://image.iswbm.com/20190612213950.png"></p><h3 id="4-操作虚拟环境"><a href="#4-操作虚拟环境" class="headerlink" title="4. 操作虚拟环境"></a>4. 操作虚拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 进入这个虚拟环境</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv shell</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 退出这个虚拟环境</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">deactivate</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 移除当前目录的虚拟环境</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv --<span class="hljs-built_in">rm</span></span><br></code></pre></td></tr></table></figure><p>执行 <code>pipenv shell</code> 就可以进入这个虚拟环境，在头部会有虚拟环境的标识名称。有这个标识，说明已经进入虚拟环境。</p><p><img src="http://image.iswbm.com/20190612211925.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 在当前虚拟环境中运行</span><br>$ pipenv run python  <span class="hljs-comment"># 进入交互式,跟直接执行 python 一样</span><br>$ pipenv run python 文件名 <span class="hljs-comment"># 运行文件</span><br>$ pipenv run pip ...  <span class="hljs-comment"># 运行pip</span><br></code></pre></td></tr></table></figure><h3 id="5-虚拟环境包管理"><a href="#5-虚拟环境包管理" class="headerlink" title="5. 虚拟环境包管理"></a>5. 虚拟环境包管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 安装一个本地包（setup.py）到虚拟环境（Pipfile）</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install -e .</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 安装、卸载模块</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install requests</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv uninstall requests</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv uninstall --all   <span class="hljs-comment"># 卸载全部包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install -r path/to/requirements.txt</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 安装所有依赖</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv install --dev</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 更新包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv update <span class="hljs-comment"># 更新所有包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv update --outdated <span class="hljs-comment"># 打印所有要更新的包</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv update &lt;包名&gt; <span class="hljs-comment"># 更新指定的包</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 将Pipfile和Pipfile.lock文件里面的包导出为requirements.txt文件</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv run pip freeze  <span class="hljs-comment"># 相当于pipenv run pip freeze &gt;requirements.txt</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv lock -r &gt; requirements.txt</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv lock -r --dev <span class="hljs-comment"># 若只想导出开发用的包</span></span><br></code></pre></td></tr></table></figure><h3 id="6-其他命令"><a href="#6-其他命令" class="headerlink" title="6. 其他命令"></a>6. 其他命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 创建一个包含预发布的锁文件:</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv lock --pre</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 打印所有包的依赖关系图</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv graph</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 检查安全漏洞</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipenv check</span><br></code></pre></td></tr></table></figure><p>打印该虚拟环境下所有包的依赖关系图</p><p><img src="http://image.iswbm.com/20190614000336.png"></p><p>有的python第三方包旧版本会有安全漏洞，使用 pipenv check 可以检查安全漏洞。</p><p><img src="http://image.iswbm.com/20190612215924.png"></p><h2 id="12-4-【虚拟环境】方案三：使用-pipx"><a href="#12-4-【虚拟环境】方案三：使用-pipx" class="headerlink" title="12.4 【虚拟环境】方案三：使用 pipx"></a>12.4 【虚拟环境】方案三：使用 pipx</h2><h3 id="1-什么是-pipx"><a href="#1-什么是-pipx" class="headerlink" title="1. 什么是 pipx"></a>1. 什么是 pipx</h3><p>pipx 是一款用于帮助你安装和运行那些用 python 编写的终端程序，它类似于 macOS 上的 brew，Ubuntu 上的 apt，CentOS 上的 yum。</p><p>pipx 依赖 pip 和 venv，它只能在 python 3.6+ 的 Python 版本中才能使用。</p><p>默认情况下，pipx 和 pip 一样会从 pypi 上安装包，同时 pipx 也能像 pip 一样从本地、git仓库、wheel 文件中安装包。</p><p>为了避免你在安装 python app时，由于多版本而导致冲突，通常我们会使用 venv 或者 virtualenv 新建一个虚拟环境，然后将 app 安装到虚拟环境中。</p><p>后续你对这个 app 的管理操作，都得先进入这个虚拟环境。</p><p>发现没有？好像有点麻烦。</p><p>pipx 的存在使这个流程变得更加舒畅，使用 pipx 你可以无需关注虚拟环境的存在，并在你的机器上安装多个版本的 python app。</p><h3 id="2-安装使用"><a href="#2-安装使用" class="headerlink" title="2. 安装使用"></a>2. 安装使用</h3><p>安装 pipx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pip install --user pipx</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m userpath append ~/.local/bin</span><br>Success!<br></code></pre></td></tr></table></figure><p>使用 Pipx 需要注意两个路径</p><ol><li>二进制文件的保存位置：默认是 <code>~/.local/bin</code>，可使用环境变量 <code>PIPX_BIN_DIR</code> 进行更改，或者执行如下命令(<code>python3 -m userpath append $&#123;you_path&#125;</code>)</li><li>虚拟环境的保存位置：默认是 <code>~/.local/pipx</code>，可使用环境变量 <code>PIPX_HOME</code> 进行更改</li></ol><p>在我安装好 pipx ，准备使用的时候，发现全局找不到 pipx 这个命令。</p><p><img src="http://image.iswbm.com/image-20201130124107950.png"></p><p>按照如上图所示，难道使用全路径执行命令？</p><p><strong>不，怎么都觉得不太对劲。。</strong></p><p>想要解决这个问题，其实很简单，有两种方法（两种都可以，我演示使用的第一种方法）：</p><ol><li>添加个软链接指向刚刚那个全路径就好啦</li><li>将这个路径添加到 PATH 中 <code>/Users/MING/Library/Python/3.9/bin/ </code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -s /Users/MING//Library/Python/3.9/bin/pipx /usr/local/bin/pipx</span><br></code></pre></td></tr></table></figure><p>软链接建好后，就可以直接使用 <code>pipx</code> 的命令啦。</p><p><img src="http://image.iswbm.com/image-20201130124554404.png"></p><p>刚刚我使用 pipx 安装了 youtube-dl 后，其实并没有将这个 youtube-dl 安装到系统全局的 Python 环境中。</p><p>还记得最开始，我强调过两个非常重要的路径吗？</p><p>现在来看一下，这个路径下面都有哪些东西？</p><p><img src="http://image.iswbm.com/image-20201130125257203.png"></p><p>从截图上可以看出</p><ul><li>pipx 在 <code>~/.local/pipx/venvs</code> 目录下新建了个名叫 <code>youtube-dl </code> 的虚拟机环境</li><li>并将 <code>youtube-dl </code> 安装到这个虚拟机环境中</li><li>然后在 <code>~/.local/bin</code> 的目录下新建一个软链接，指向这个虚拟环境中</li><li>这样 <code>youtube-dl </code> 就变成全局的工具啦。</li></ul><p><img src="http://image.iswbm.com/image-20201130131138939.png"></p><p>为了避免你新安装的 youtube-dl 与全局的冲突，你也可以指定 pipx 的命令来运行 youtube-dl </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run youtube-dl --no-check-certificate https://www.bilibili.com/video/BV1jK4y1h7uA</span><br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="http://image.iswbm.com/image-20201130210539907.png"></p><p>pip run 也可以直接执行在线的 python 脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py</span><br>pipx is working!<br></code></pre></td></tr></table></figure><h3 id="3-查看包"><a href="#3-查看包" class="headerlink" title="3. 查看包"></a>3. 查看包</h3><p>查看已安装过的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx list</span><br></code></pre></td></tr></table></figure><h3 id="4-安装包"><a href="#4-安装包" class="headerlink" title="4. 安装包"></a>4. 安装包</h3><p>下载最新版本的 python 包，并安装到新建的虚拟环境中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx install &lt;PACKAGE&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-运行APP"><a href="#4-运行APP" class="headerlink" title="4. 运行APP"></a>4. 运行APP</h3><p><code>pipx run</code> 后面可接一个包的 url 链接，会将这个包下载下来并运行，也可以接已安装过的应用名来直接运行它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run &lt;PACKAGE_URL/APP&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个 app 有多个版本，那么可以通过 <code>spec</code> 指定版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run --spec PACKAGE==1.0.0 app</span><br></code></pre></td></tr></table></figure><p>更神奇的是，pipx 支持指定 git 代码仓库直接运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run --spec git+https://github.com/psf/black.git black</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定分支</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run --spec git+https://github.com/psf/black.git@branch black</span>  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定某个git hash</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run --spec git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 black</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 指定某个发行版本</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black <span class="hljs-comment"># install a release</span></span><br></code></pre></td></tr></table></figure><h3 id="5-升级包"><a href="#5-升级包" class="headerlink" title="5. 升级包"></a>5. 升级包</h3><p>升级某个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx upgrade &lt;pkg&gt;</span><br></code></pre></td></tr></table></figure><p>升级全部包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx upgrade-all</span><br></code></pre></td></tr></table></figure><h3 id="6-卸载包"><a href="#6-卸载包" class="headerlink" title="6. 卸载包"></a>6. 卸载包</h3><p>卸载某个包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx uninstall &lt;pkg&gt;</span><br></code></pre></td></tr></table></figure><p>卸载全部包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx uninstall-all</span><br></code></pre></td></tr></table></figure><p>重装全部包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx reinstall-all</span><br></code></pre></td></tr></table></figure><h3 id="7-使用-pip"><a href="#7-使用-pip" class="headerlink" title="7. 使用 pip"></a>7. 使用 pip</h3><p>每执行一次 pipx install 就会新建一个虚拟环境，那我们有没有办法管理这些虚拟机环境呢？</p><p>比如我想看这个虚拟环境里安装了哪些包？</p><p>使用如下命令就可以像使用 pip 一样，来管理 pipx 的虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pipx runpip &lt;env_name&gt; &lt;args&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://image.iswbm.com/image-20201130215320069.png"></p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><p>执行 <code>pipx completions</code> 可以启用 pipx 的补全说明。</p><p>对于不同的终端开启方式不一样，我使用的是 zsh，方法是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">autoload</span> -U bashcompinit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">bashcompinit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(register-python-argcomplete pipx)</span>&quot;</span></span><br></code></pre></td></tr></table></figure><p>我安装好后，可以使用 tab 键进行命令补全。</p><p><img src="http://image.iswbm.com/image-20201130220233001.png"></p><p>执行 <code>pipx ensurepath</code> 可以确保 <code>~/.local/bin</code> 这个重要的目录，已经放入到 <code>$PATH</code> 的变量中。</p><p><img src="http://image.iswbm.com/image-20201130215826513.png"></p><h3 id="9-pipx-vs-pip"><a href="#9-pipx-vs-pip" class="headerlink" title="9. pipx vs pip"></a>9. pipx vs pip</h3><p>pipx 只是解决 pip 的一个痛点，因此他的适用场景比较单一，它只适用于安装和运行那些有提供命令行入口的app。</p><ul><li>pip 适用于大多数的 Python 版本，而 pipx 需要 Python 3.6+ 才可以使用</li><li>pipx 依赖 pip 和 venv，可以使用 pip 安装pipx ，反过来则不行。</li><li>pip 和 pipx 默认都是从 pypi 上安装包</li><li>pipx 在安装和管理 cli 应用程序时，比 pip 更灵活，它可以在允许在隔离环境中安装和运行 Python 应用</li></ul><h3 id="10-参考文章"><a href="#10-参考文章" class="headerlink" title="10. 参考文章"></a>10. 参考文章</h3><ul><li><a href="https://github.com/pipxproject/pipx">https://github.com/pipxproject/pipx</a></li><li><a href="https://pipxproject.github.io/pipx/comparisons/##">https://pipxproject.github.io/pipx/comparisons/##</a> 12.5 【虚拟环境】方案四：使用 poetry</li></ul><h3 id="1-安装-poetry"><a href="#1-安装-poetry" class="headerlink" title="1. 安装 poetry"></a>1. 安装 poetry</h3><p>poetry提供多种安装方式，个人推荐从以下2种方式中选择：</p><p>方式一：（推荐）使用在线脚本进行安装，是最为推荐的安装方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python</span><br></code></pre></td></tr></table></figure><p>方式二：（pip） 官方不建议这么做，因为有可能会造成依赖冲突，可以考虑用 pipx 或 pipsi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install --user poetry</span><br></code></pre></td></tr></table></figure><p>安装后，可以使用如下命令检测是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry --version</span><br>Poetry version 1.1.4<br></code></pre></td></tr></table></figure><p>如果不可用，可能是环境变量没有设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜ echo $PATH<br>/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin<br></code></pre></td></tr></table></figure><p>我使用第一种方法，安装后，会自动把设置环境变量的命令写入 <code>.zshrc</code>，要使之立即生效，需要手动 source 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜ <span class="hljs-built_in">tail</span> -n 1 ~/.zshrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.poetry/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><br>➜ <span class="hljs-built_in">source</span> ~/.zshrc<br><br>➜ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>/Users/iswbm/.poetry/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin<br></code></pre></td></tr></table></figure><h3 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h3><p>如果你是在一个已有的项目里使用 Poetry，你只需要执行 poetry init 命令来创建一个 pyproject.toml 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry init</span><br></code></pre></td></tr></table></figure><p>而如果是新建 一个项目，可以使用这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry new demo-priject</span><br></code></pre></td></tr></table></figure><p>运行完后，在当前目录下就会多一个 <code>demo-project</code> 的目录，这个目录下的文件结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">tree demo-priject</span><br>demo-priject<br>├── README.rst<br>├── demo_priject<br>│   └── __init__.py<br>├── pyproject.toml<br>└── tests<br>    ├── __init__.py<br>    └── test_demo_priject.py<br></code></pre></td></tr></table></figure><p>如果要把项目代码放入到 src 目录下，在创建项目时，可以加上 <code>--src</code> 参数。</p><h3 id="3-创建虚拟环境"><a href="#3-创建虚拟环境" class="headerlink" title="3. 创建虚拟环境"></a>3. 创建虚拟环境</h3><p>使用 poetry install 命令创建虚拟环境（确保当前目录有 pyproject.toml 文件）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry install</span><br></code></pre></td></tr></table></figure><p>这个命令会读取 pyproject.toml 中的所有依赖（包括开发依赖）并安装，如果不想安装开发依赖，可以附加 –no-dev 选项。如果项目根目录有 poetry.lock 文件，会安装这个文件中列出的锁定版本的依赖。如果执行 add&#x2F;remove 命令的时候没有检测到虚拟环境，也会为当前目录自动创建虚拟环境。</p><p><img src="http://image.iswbm.com/image-20201220164337699.png"></p><h3 id="4-使用虚拟环境"><a href="#4-使用虚拟环境" class="headerlink" title="4. 使用虚拟环境"></a>4. 使用虚拟环境</h3><p>创建虚拟环境后，如果想要在虚拟环境下执行命令，比如去执行脚本，去使用 pip list 等等。</p><p>可以在项目目录下，使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry run &lt;commands&gt;</span><br></code></pre></td></tr></table></figure><p>比如我查看该虚拟环境中安装了哪些包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry run pip list</span><br></code></pre></td></tr></table></figure><p>再比如我想在该虚拟环境下执行 <code>app.py</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry run python app.py</span><br></code></pre></td></tr></table></figure><p>每次在虚拟环境下做点啥事，命令前面都要加上 <code>poetry run</code>，有点太麻烦了。</p><p>这时可以使用下面这条命令，直接激活当前的虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry shell</span><br></code></pre></td></tr></table></figure><h3 id="5-包的管理"><a href="#5-包的管理" class="headerlink" title="5. 包的管理"></a>5. 包的管理</h3><p>安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry add &lt;pkg&gt;</span><br></code></pre></td></tr></table></figure><p>添加 –dev 参数可以指定为开发依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry add pytest --dev</span><br></code></pre></td></tr></table></figure><p>查看所有安装的依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry show</span><br></code></pre></td></tr></table></figure><p>加上 <code>--tree</code> 可以查看他们的依赖关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry show --tree</span><br></code></pre></td></tr></table></figure><p>加上 <code>--outdated</code> 可以查看可以更新的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry show --outdated</span><br></code></pre></td></tr></table></figure><p>如果要更新依赖可以执行这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 更新全部</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry update</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 更新某个依赖</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry update foo</span><br></code></pre></td></tr></table></figure><p>想卸载某个包，用这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry remove foo</span><br></code></pre></td></tr></table></figure><h3 id="6-常用配置"><a href="#6-常用配置" class="headerlink" title="6. 常用配置"></a>6. 常用配置</h3><p>Poetry 的配置存储在单独的文件中，比 Pipenv 设置环境变量的方式要方便一点。配置通过 poetry config 命令设置，比如下面的命令可以写入 PyPI 的账号密码信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry config http-basic.pypi username password</span><br></code></pre></td></tr></table></figure><p>下面的命令设置在项目内创建虚拟环境文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">poetry config settings.virtualenvs.in-project <span class="hljs-literal">true</span></span><br></code></pre></td></tr></table></figure><p>另一个常用的配置是设置 PyPI 镜像源，以使用豆瓣提供的 PyPI 镜像源为例，你需要在 pyproject.toml 文件里加入这部分内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[[tool.poetry.source]]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;aliyun&quot;</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">&quot;https://mirrors.aliyun.com/pypi/simple/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7. 参考文章"></a>7. 参考文章</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/81025311">相比 Pipenv，Poetry 是一个更好的选择</a></li><li><a href="https://greyli.com/set-pypi-mirror/">从国内的 PyPI 镜像（源）安装 Python 包</a>## 12.6 【虚拟环境】方案五：使用 venv</li></ul><p>在前面介绍的几种方法中，都需要借助第三方模块来完成虚拟环境的管理。</p><p>但其实在 Python 3 中就自带了一个专门用门管理虚拟环境的模块，它叫 <code>venv</code>。</p><h3 id="1-创建虚拟环境"><a href="#1-创建虚拟环境" class="headerlink" title="1. 创建虚拟环境"></a>1. 创建虚拟环境</h3><p><code>venv</code> 后可以接一个目录（如果此目录不存在，会自动创建）用于创建你的虚拟环境，他可以是绝对路径，也可以是相对路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># mac or linux</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m venv [venv_dir]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># windows: 一定要指定  --without-pip</span></span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 最后再手动执行命令安装 python -m ensurepip</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m venv --without-pip [venv_dir]</span><br></code></pre></td></tr></table></figure><p>使用 venv 创建虚拟环境的速度非常快，大概只需要两三秒的样子。</p><p><img src="http://image.iswbm.com/image-20201226172542169.png"></p><p>创建完成后，在你所指定的目录下会有一个 <code>pyvenv.cfg</code> 的配置文件，它记录着虚拟环境的基本信息，包括你使用的 Python 的家目录，还有当前虚拟环境的 Python 版本，是否开启使用系统的 site-packages 模块，如果开启了，那么当你就可以直接使用系统中已经装过的第三方模块，但是你在虚拟环境下装的模块就不能被其他地方的程序使用。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">home</span> = /usr/local/bin<br><span class="hljs-attr">include-system-site-packages</span> = <span class="hljs-literal">false</span><br><span class="hljs-attr">version</span> = <span class="hljs-number">3.9</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果你的环境中有 Python 3.8 也有 Python 3.9 ，那该怎么办呢？</p><p>只要你在创建时，用你预期版本的 Python 去执行就好啦</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3.8 -m venv [venv_dir]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3.9 -m venv [venv_dir]</span><br></code></pre></td></tr></table></figure><p>可如果你的环境中有两个 Python 3.9 呢？你想使用不在 <code>PATH</code> 的中的 Python 去创建，就要用绝对路径去创建了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">/usr/local/bin/python3 -m venv [venv_dir]</span><br></code></pre></td></tr></table></figure><h3 id="2-进入创建环境"><a href="#2-进入创建环境" class="headerlink" title="2. 进入创建环境"></a>2. 进入创建环境</h3><p>进入虚拟环境的方法，对比之前介绍的方案，venv 的方法就相当原始了。</p><p>如果你使用 Windows ，那么在 cmd 下进行 <code>Scripts</code> 目录，执行 <code>activate.bat</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># cmd.exe</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">.\Scripts\activate.bat</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># PowserShell</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">.\Scripts\Activate.ps1</span><br></code></pre></td></tr></table></figure><p>如果你使用PowserShell激活虚拟环境出现如下错误，那要先执行这个命令：<code>Set-ExecutionPolicy RemoteSigned</code>，再按 <code>Y</code></p><p><img src="http://image.iswbm.com/20201231140727.png"></p><p>而如果你使用的 Mac 或者 Linux，那么直接执行下面命令就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> bin/activate</span><br></code></pre></td></tr></table></figure><p>执行完后，若在你的命令行下有 <code>demo</code> 字样（之所以是 demo ，因为我们创建时的目录名就是 demo），说明你已经处于虚拟环境下。 由于虚拟环境是全新的干净环境，此时你使用 <code>pip list</code> ，会看到啥包都没有，只有最基本的 pip 和 setuptools 。</p><p><img src="http://image.iswbm.com/image-20201226174305992.png"></p><h3 id="3-退出虚拟环境"><a href="#3-退出虚拟环境" class="headerlink" title="3. 退出虚拟环境"></a>3. 退出虚拟环境</h3><p>退出虚拟环境，无论是 Windows 、 Mac 、 还是 Linux ，方法都是同一条命令。退出后，你的虚拟环境名称（如上面的 <code>demo</code> ）也会消失。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">deactivate</span><br></code></pre></td></tr></table></figure><h3 id="4-总结一下-1"><a href="#4-总结一下-1" class="headerlink" title="4. 总结一下"></a>4. 总结一下</h3><p><code>venv</code> 是 Python3 中自带的虚拟环境管理工具，不需要额外安装，功能简单，用法也简单。但是它不能像 poetry 和 pipenv 用于项目的管理，因此 venv 建议只做了解，在一些简单的场景中可以使用，如果是复杂的项目中，可以直接上 poetry 和 pipenv。</p><h2 id="12-7-【本地环境】方案六：使用-PDM"><a href="#12-7-【本地环境】方案六：使用-PDM" class="headerlink" title="12.7 【本地环境】方案六：使用 PDM"></a>12.7 【本地环境】方案六：使用 PDM</h2><p>PDM 是一个新的 Python 的包管理器，也许你还未知晓它的存在，但实际上PDM 已经诞生两年，并在 2021 年发布 1.0 版本，目前最高的版本是 1.12.8。</p><p>在刚听到 PDM 时，我下意识认为它是 Python Development Manager，又一个和 Pipenv 和 Poetry 一样换汤不换药的虚拟环境管理工具。</p><p>一直到我翻到了作者的博客，才知道 PDM 的全称是 Python Development Master，比我想像的还要牛逼一个档次。</p><p>值得一提的是，PDM 的作者是 PyPa 成员、Pipenv 目前主要的维护者之一，最重要的是，是他是中国人，因此这是一款国人开发的工具。</p><h3 id="1-Why-PDM？"><a href="#1-Why-PDM？" class="headerlink" title="1. Why PDM？"></a>1. Why PDM？</h3><p>早期的包管理器（如 Pipevn，Poetry），都是基于虚拟环境的，虚拟环境主要是为了隔离项目开发环境，但如果涉及到虚拟 环境嵌套虚拟环境，问题就难搞了，经常会出现问题。</p><p>PDM 得益于一个 2018 年的 PEP 提案（PEP582，Python local packages directory），完全摒弃了虚拟环境。</p><p>从<a href="https://frostming.com/2020/02-28/pdm-introduction/">作者的博客</a>上来看，当初之所以要重复造个轮子，完全是因为 Pipenv 和 Poetry 都不够好用，正好有 PEP582 ，可以开发一个划时代的 Python 包管理工具，它就是 PDM 。</p><p>PDM 包含如下特性：</p><ul><li>PEP 582 本地项目库目录，支持安装与运行命令，<strong>完全不需要虚拟环境</strong>。</li><li>一个简单且相对快速的依赖解析器，特别是对于大的二进制包发布。</li><li>兼容 PEP 517 的构建后端，用于构建发布包(源码格式与 wheel 格式)</li><li>拥有灵活且强大的插件系统（有插件系统直接就拉开一个档次）</li><li><a href="https://www.python.org/dev/peps/pep-0621">PEP 621</a> 元数据格式</li><li>像 <a href="https://pnpm.io/motivation#saving-disk-space-and-boosting-installation-speed">pnpm</a> 一样的中心化安装缓存，节省磁盘空间</li></ul><p>尽管 PDM 是国人开发，但考虑到国际化，官网文档是全英文的。</p><p>我花了整整一天，通读完文档，消化了 70% 的 PDM 用法，现将心得整理分享出来，会对你上手 PDM 有帮助。</p><p>关于 PDM，内容挺多的，打算分两篇文章来完整地介绍它：</p><ul><li>面向新手的入门级教程</li><li>面向骨灰级选手的教程</li></ul><p>本篇是第一篇，先让大家对 pdm 的基本用法有一个框架性的理解，而 pdm 真正竞争力请持续关注后续文章。</p><h3 id="2-安装-PDM"><a href="#2-安装-PDM" class="headerlink" title="2. 安装 PDM"></a>2. 安装 PDM</h3><p>PDM 的安装方法有很多种，在官网上就有 6 种，比如 pip、pipx、homebrew 等</p><p>在以前的文章中，我推荐过 pipx 工具，在安装那种命令行应用的包时非常好用。</p><p>而此时 PDM 就是一个命令行工具，因此我也推荐使用 pipx 安装，方便统一对命令行进行管理</p><p>执行 pipx install pdm 即可安装</p><p><img src="http://image.iswbm.com/image-20220212200413787.png"></p><p>PDM 只有 Python 3.7+ 的版本才能使用，使用其他的方法安装，要先保证你的 Python 版本，但使用 pipx 则不需要你去操心。</p><h3 id="3-初始化-PDM"><a href="#3-初始化-PDM" class="headerlink" title="3. 初始化 PDM"></a>3. 初始化 PDM</h3><p>执行 pdm init 就会开始初始化，初始化的时候，会让你选择项目的一些信息</p><ul><li>是否要上传 PyPI</li><li>依赖的 Python 版本</li><li>License 类型</li><li>作者信息</li><li>邮箱信息</li></ul><p>我机器上有 Python  2.7 和 Python 3.10 两个版本，在初始化项目时会把机器上的所有 Python 版本都扫描出来了，会让选择项目的 Python 版本。</p><p><img src="http://image.iswbm.com/image-20220212204609288.png"></p><p> 完成之后，PDM 会将你的选择以 toml 格式写入 pyproject.toml 配置文件中。</p><p><img src="http://image.iswbm.com/image-20220212204627731.png"></p><h3 id="4-PDM-用法"><a href="#4-PDM-用法" class="headerlink" title="4. PDM 用法"></a>4. PDM 用法</h3><p>pdm 有非常多的命令，使用 <code>-h</code> 可以看到帮助菜单</p><p><img src="http://image.iswbm.com/image-20220212204708840.png"></p><h4 id="4-1-安装包"><a href="#4-1-安装包" class="headerlink" title="4.1 安装包"></a>4.1 安装包</h4><p>和 Poetry 一样，安装使用的是 add 命令，但 pdm 的 add 比 poetry 好用，主要体现在分组，具体请关注后续文章</p><p><img src="http://image.iswbm.com/image-20220212205148934.png"></p><h4 id="4-2-查看包"><a href="#4-2-查看包" class="headerlink" title="4.2 查看包"></a>4.2 查看包</h4><p>使用 pdm list 可以以列表形式列出当前环境已安装的包</p><p><img src="http://image.iswbm.com/image-20220212205220953.png"></p><p>再加个 <code>--graph</code> 就能以树状形式查看，直接依赖包和间接依赖包关系的层级一目了然</p><p><img src="http://image.iswbm.com/image-20220212222032290.png"></p><p>pdm list 还有两个选项：</p><ul><li><code>--freeze</code>：以 requirements.txt 的格式列出已安装的包</li><li><code>--json</code>：以 json 的格式列出已安装的包，但必须与 <code>--graph</code> 同时使用</li></ul><p>要查看某个包的某体详情，直接用 pdm show 即可</p><p><img src="http://image.iswbm.com/image-20220212211203788.png"></p><h4 id="4-3-删除包"><a href="#4-3-删除包" class="headerlink" title="4.3 删除包"></a>4.3 删除包</h4><p>删除包使用的是 remove 命令</p><p><img src="http://image.iswbm.com/image-20220212215831751.png"></p><h4 id="4-4-项目配置"><a href="#4-4-项目配置" class="headerlink" title="4.4 项目配置"></a>4.4 项目配置</h4><p>不加任何参数，可以打印出该项目的环境配置</p><p><img src="http://image.iswbm.com/image-20220212211303563.png"></p><p>想要修改的话，只要加 key 和 value 做为参数即可，以修改 pypi 镜像代理为例</p><p>原来上面是豆瓣源，现在我要改成阿里源，只需要执行如下命令，可比 poetry 方便多啦～</p><p><img src="http://image.iswbm.com/image-20220212212225849.png"></p><p>pdm config 里面有非常多的配置，想要一一搞清楚的可以去官网查阅：<a href="https://pdm.fming.dev/configuration/">https://pdm.fming.dev/configuration/</a></p><h4 id="4-5-运行命令"><a href="#4-5-运行命令" class="headerlink" title="4.5 运行命令"></a>4.5 运行命令</h4><p>想要在 pdm 的环境中执行命令或者项目，可以使用  run 命令，若是执行项目时，有诸多参数，可以在 pyproject.toml 配置命令别名，具体用法，请往后看</p><p><img src="http://image.iswbm.com/image-20220212211033303.png"></p><h4 id="4-6-查看环境"><a href="#4-6-查看环境" class="headerlink" title="4.6 查看环境"></a>4.6 查看环境</h4><p>使用 <code>info</code> 命令，可以查看当前项目的环境信息</p><p><img src="http://image.iswbm.com/image-20220212223811269.png"></p><h4 id="4-7-更新包"><a href="#4-7-更新包" class="headerlink" title="4.7 更新包"></a>4.7 更新包</h4><p>更新的话，简单的场景下，使用下面这两条即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 更新所有包</span><br>pdm update <br><br><span class="hljs-comment">## 更新某个包</span><br>pdm update &lt;pkg&gt;<br></code></pre></td></tr></table></figure><p>复杂的场景，pdm 也都为你考虑到了，它提供了很多选项，可以根据需要使用（以下如有解释错误，请帮忙指正）</p><ul><li><code>--save-compatible</code>：项目依赖可兼容的版本</li><li><code>--save-wildcard</code>：保存通配符版本（暂不明白）</li><li><code>--save-exact</code>：保存有指定确切版本的包</li><li><code>--save-minimum</code>：保持最小版本的包</li><li><code>--update-reuse</code>：尽量只更新命令行中指定的包，其依赖包能不更新则不更新</li><li><code>--update-eager</code>：更新某个包顺带更新其依赖包（递归升级）</li><li><code>--prerelease</code>：允许提前释放（暂不明白）</li><li><code>--unconstrained</code>：忽略包版本的约束，可将包升级至最新版本</li><li><code>--top</code>：仅更新有在 pyproject.toml 的包</li><li><code>--dry-run</code>：试运行，而不去修改 lock 文件</li><li><code>--no-sync</code>：只更新 lock 文件，但不更新包</li></ul><p>如果你的依赖包有设置分组，还可以指定分组进行更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdm update -G security -G http<br></code></pre></td></tr></table></figure><p>也可以指定分组更新分组里的某个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdm update -G security cryptography<br></code></pre></td></tr></table></figure><p>再加个 <code>-d</code> 就可以再指定 dev 依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 更新所有的 dev 依赖</span><br>pdm update -d<br><br><span class="hljs-comment">## 更新 dev 依赖下某个分组的某个包</span><br>pdm update -dG <span class="hljs-built_in">test</span> pytest<br></code></pre></td></tr></table></figure><p>同样地，也可以指定 <code>--prod</code> 或者  <code>--production</code> 升级非 dev （即生产）的包。</p><h4 id="4-8-切换-py"><a href="#4-8-切换-py" class="headerlink" title="4.8 切换 py"></a>4.8 切换 py</h4><p>当你在初始化 pdm 项目时，就已经选定了当前的 Python 版本和可用的 Python 版本范围，后面如果想更改，可以使用 use 命令，但版本要受之前设定的版本范围约束。</p><p>假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">pdm <span class="hljs-keyword">use</span> python3<span class="hljs-number">.9</span><br></code></pre></td></tr></table></figure><h3 id="5-命令别名"><a href="#5-命令别名" class="headerlink" title="5. 命令别名"></a>5. 命令别名</h3><p>在 pyproject.toml 添加 <code>[tool.pdm.scripts]</code> 可以设置快捷命令别名，若项目的执行有非常多的参数，这种设定别名的方法将很有用。</p><p><img src="http://image.iswbm.com/image-20220213001224815.png"></p><p> <code>[tool.pdm.scripts]</code> 有两种形式</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment">## 第一种</span><br><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">start</span> = <span class="hljs-string">&quot;python main.py&quot;</span><br><br><span class="hljs-comment">## 第一种</span><br><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">start</span> = &#123;cmd = <span class="hljs-string">&quot;python main.py&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>但若想在参数中加注释，就必须得使用第二种方法，例如这样</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">start</span> = &#123;cmd = [<br>    <span class="hljs-string">&quot;flask&quot;</span>,<br>    <span class="hljs-string">&quot;run&quot;</span>,<br>    <span class="hljs-comment"># Important comment here about always using port 54321</span><br>    <span class="hljs-string">&quot;-p&quot;</span>, <span class="hljs-string">&quot;54321&quot;</span><br>]&#125;<br></code></pre></td></tr></table></figure><p>除了 cmd 之外，还有两个参数</p><p>一个是 shell 参数，从输出来看你应该和看出和 cmd 的区别，和 <code>subprocess.Popen()</code> with <code>shell=True</code> 差不多一个意思 </p><p><img src="http://image.iswbm.com/image-20220213003342952.png"></p><p>一个是 env_file 参数，可以指定配置环境变量的文件</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">start.cmd</span> = <span class="hljs-string">&quot;flask run -p 54321&quot;</span><br><span class="hljs-attr">start.env_file</span> = <span class="hljs-string">&quot;.env&quot;</span><br></code></pre></td></tr></table></figure><p>如果想要把这个环境变量的文件不仅限于某个命令，而是 pdm run 全局，可以这样配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">_.env_file</span> = <span class="hljs-string">&quot;.env&quot;</span><br></code></pre></td></tr></table></figure><p>加 <code>--list</code> 或者  <code>-l</code>可以查看所有设置的快捷别名</p><p><img src="http://image.iswbm.com/image-20220213003948180.png"></p><p>对于每一个快捷命令，都可以设置 pre 和 post 命令：</p><ul><li>pre 命令：在每次快捷命令执行前会执行</li><li>post 命令：在每次快捷命令执行后会执行</li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.pdm.scripts]</span><br><span class="hljs-attr">pre_compress</span> = <span class="hljs-string">&quot;&#123;&#123; Run BEFORE the `compress` script &#125;&#125;&quot;</span><br><span class="hljs-attr">compress</span> = <span class="hljs-string">&quot;tar czvf compressed.tar.gz data/&quot;</span><br><span class="hljs-attr">post_compress</span> = <span class="hljs-string">&quot;&#123;&#123; Run AFTER the `compress` script &#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="6-自动补全"><a href="#6-自动补全" class="headerlink" title="6. 自动补全"></a>6. 自动补全</h3><p>pdm 的命令虽多，但并不复杂，并不太需要使用自动补全，若你真的需要补全，也可以实现。</p><p>对于不同的 shell，自动补全的配置方式都不太一样，这个在官网上有详细的说明。</p><p>如果你和我一样使用的 zsh，可以参照我的配置方式。</p><p><img src="http://image.iswbm.com/image-20220212214047051.png"></p><p>截图中间有一步是 vim ~&#x2F;.zshrc ，是将 pdm 插件配置到 zsh 中</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">plugins</span><span class="hljs-operator">=</span>(git z macos extract zsh-syntax-highlighting zsh-autosuggestions pdm)<br></code></pre></td></tr></table></figure><h3 id="7-方案兼容"><a href="#7-方案兼容" class="headerlink" title="7. 方案兼容"></a>7. 方案兼容</h3><h4 id="其他方案迁移到-pdm"><a href="#其他方案迁移到-pdm" class="headerlink" title="其他方案迁移到 pdm"></a>其他方案迁移到 pdm</h4><p>pdm 足够好用，也足够开放，如果你当前使用的是其他的包管理器，比如 pipenv ，poetry，或者还在用最原始的 requirements.txt ，你也可以很方便的迁移到 pdm 中来：</p><ul><li>使用 pdm import -f {file} 无需初始化，直接转换</li><li>执行 pdm init 或者  pdm install 的时候，会自动识别你当前的依赖情况并转换</li></ul><h4 id="pdm-迁移到其他方案"><a href="#pdm-迁移到其他方案" class="headerlink" title="pdm 迁移到其他方案"></a>pdm 迁移到其他方案</h4><p>同样的，你也可以当 pdm 管理的项目，导出为其他方案</p><p>pyproject.toml 和 pdm.lock是 pdm 的两个核心文件。</p><p>pdm 做为一个后起之秀，也没有忘记向前兼容，它支持：</p><ul><li><p>将 pyproject.toml 转成 setup.py</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdm <span class="hljs-built_in">export</span> -f setuppy -o setup.py<br></code></pre></td></tr></table></figure></li><li><p>将 pdm.lock 转成 requirements.txt</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdm <span class="hljs-built_in">export</span> -o requirements.txt<br></code></pre></td></tr></table></figure></li></ul><h3 id="8-总结一下"><a href="#8-总结一下" class="headerlink" title="8. 总结一下"></a>8. 总结一下</h3><p>花了很大的力气，终于把 PDM 的基本用法给介绍完毕，相信一定会有人会提出质疑：这就是你所谓的 <strong>划时代的包管理器</strong> ？</p><p>实际上，上面仅仅是入门操作，而 PDM 的一些核心知识，考虑到篇幅有限，我将这些进阶类的内容安排在后续文章，它将包括但不仅限于：</p><ul><li>PDM 的原理剖析：PEP 582 提案</li><li>发布包的构建：PEP 517 提案</li><li>Hook 脚本的定义与使用</li><li>插件管理系统与自定义插件</li><li>缓存管理系统的介绍</li></ul><p>这些内容是 PDM 的核心，只有理解了这些，你才能真正用好 PDM，到那时你会感慨：<strong>为什么  Guido 还不把这样的工具收编成标准的包管理工具？</strong><br><img src="http://image.iswbm.com/20210606214719.png"></p><h2 id="12-7-【最强工具】方案六：pyenv"><a href="#12-7-【最强工具】方案六：pyenv" class="headerlink" title="12.7 【最强工具】方案六：pyenv"></a>12.7 【最强工具】方案六：pyenv</h2><p>前面介绍过非常地 Python 包管理工具，有 pip、 venv、pipenv、poetry、pdm 等</p><p>今天来介绍一个更高层次的管理工具，可以直接管理 Python 解释器的版本，同时也可以管理虚拟环境，它就是 pyenv。</p><p>pyenv 的一个典型使用场景就是，比如一个老项目需要使用 Python 2.x ，而另一个新项目需要 Python 3.x 。而 virtualenv 主要是用来管理相同版本 Python 不同项目的包的依赖不同的问题，就无法解决这个问题，这个时候就需要 pyenv。</p><p>有了 pyenv，你可以一键安装、切换到任意你需要的 python 版本，从 2.1.3 -&gt; 3.12-dev（稿前为止最新版本）。</p><p>除了常规的 CPython 之外，它还可以管理其他的 python 和 工具，包括：</p><ul><li>graalpython</li><li>ironpython</li><li>jython</li><li>micropython</li><li>pypy</li><li>miniconda</li><li>anaconda</li><li>pyston</li><li>stackless</li><li>等等</li></ul><p>好家伙，我愿称之为 Python Env Master，而上面每个工具，还有细分的版本，不用担心，pyenv 全部都有收录，可以满足你几乎所有需求了。</p><h3 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h3><p>先安装 pyenv，由于我使用 macOS，使用 brew 可以很方便的安装它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew update<br>brew install pyenv<br></code></pre></td></tr></table></figure><p>安装 pyenv 会安装相当多的依赖包，包括：</p><ul><li><code>pyenv</code>: pyenv 工具自身</li><li><code>pyenv-update</code>: 用来更新 pyenv 的插件</li><li><code>pyenv-doctor</code>: 验证 pyenv 和依赖是否安装的插件</li><li><code>pyenv-which-ext</code>: 用来寻找相同命令的插件</li></ul><p>使用 pyenv help 查看一下帮助命令，如果没有报错，说明安装成功</p><p><img src="https://image.iswbm.com/20221211183415.png"></p><p>另外，除了 pyenv，还要安装一个插件 pyenv-virtualenv，它是专门用来管理 vitual environments 的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install pyenv-virtualenv<br></code></pre></td></tr></table></figure><p>安装好后，还要进行一下初始化。</p><p>为了下次新开终端也可以立马使用 pyenv，可以将下面两条初始化命令写入 <code>.bash_profile</code>或 <code>.zshrc</code>（根据自己实际情况而定）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(pyenv init -)</span>&quot;</span><br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(pyenv virtualenv-init -)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>然后再次执行 source 使之立即执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br><span class="hljs-comment">## 或</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h3><p>环境配置好后，那如何知道有哪些版本可以安装呢？</p><p>可以使用如下命令查询所有可安装的项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv install --list<br></code></pre></td></tr></table></figure><p>比如我现在需要安装的是 python3.8，但我不知道最新的小版本是多少，就可以使用上面命令查询一下</p><p><img src="https://image.iswbm.com/20221211205459.png"></p><p>发现最新的版本是 3.8.16，于是直接使用 install 来安装它，再使用 pyenv versions 就可以看到我们安装的版本了。</p><p><img src="https://image.iswbm.com/20221211183934.png"></p><p>从上面截图可以看到，安装完后并不会自动切换过去，目前还是指向系统自带的 Python，需要手动进行版本的切换，切换方法有如下两种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv global 3.8.16<br><span class="hljs-comment">## 或 </span><br>pyenv <span class="hljs-built_in">local</span> 3.8.16<br></code></pre></td></tr></table></figure><p>那这种有什么区别呢？简单来说：</p><ul><li>global：设置全局的 Python 解释器，不管你在任何路径下都是使用该版本的 Python</li><li>local： 设置的是某特定目录（或项目）的 Python 解释器，只有在该目录下才能用该版本的 Python</li></ul><p>我们使用 pyenv versions 可以观察下指向的 Python 版本，可以发现</p><ul><li>只要进入 wechat-chatgpt 目录，就会使用 <code>.python-version</code>里的解释器</li><li>一旦离开 wechat-chatgpt 目录，就又会使用全局的 Python 解释器</li></ul><p><img src="https://image.iswbm.com/20221211211322.png"></p><p>想要切换回系统自带的 Python ，也是同样道理，将版本换成 system 即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv global system<br></code></pre></td></tr></table></figure><h3 id="3-虚拟环境"><a href="#3-虚拟环境" class="headerlink" title="3. 虚拟环境"></a>3. 虚拟环境</h3><p>pyenv 管理的每一个版本在 <code>~/.pyenv/versions</code> 下都有对应的目录</p><p><img src="https://image.iswbm.com/20221211212217.png"></p><p>当然 pyenv 创建的虚拟环境也是在这下面，只不过我还没有创建过虚拟环境。</p><p>现在使用使用如下命令创建一个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyenv virtualenv 3.8.16 wechat-chatgpt<br></code></pre></td></tr></table></figure><p>可以发现不管在 <code>~/.pyenv/versions</code>目录下还是 <code>pyenv versions</code>都会新增一个环境</p><p><img src="https://image.iswbm.com/20221211212513.png"></p><p>只要在对应的目录下使用 local 指定 Python 版本，就实现了项目与 Python 版本的绑定。实在是太友好啦～</p><p><img src="https://image.iswbm.com/20221211212735.png"></p><p>另外列几个虚拟环境管理的命令</p><ul><li>查看所有虚拟环境：pyenv virtualenvs</li><li>删除指定虚拟环境：pyenv virtualenv-delete</li><li>查看虚拟环境的真实的 Python 环境：pyenv virtualenv-prefix</li></ul><h3 id="4-总结一下-2"><a href="#4-总结一下-2" class="headerlink" title="4. 总结一下"></a>4. 总结一下</h3><p>pyenv 从解释器管理到虚拟环境管理，给了 Python 工程师一站式的体验，对于那些需要维护很多项目并且有些项目依赖了不同的 Python 版本的人来说，请一定在你的电脑上安装 pyenv，因为它实在太方便了。</p><p>目前我发现的唯一的不足，可能就是它只能管理通过 pyenv 安装的解释器，而对于系统上早已存在的 Python 解释器，并不会去扫描纳管，但这问题实在太小，小到可以忽略不计。</p><h1 id="第十三章：绝佳工具"><a href="#第十三章：绝佳工具" class="headerlink" title="第十三章：绝佳工具"></a>第十三章：绝佳工具</h1><h2 id="13-1-【静态检查】mypy-的使用"><a href="#13-1-【静态检查】mypy-的使用" class="headerlink" title="13.1 【静态检查】mypy 的使用"></a>13.1 【静态检查】mypy 的使用</h2><p>Python 3.6以后，允许为参数和函数返回类型添加类型标注（type hinting）。</p><p>这就为程序进行静态类型检查提供了可能，mypy就是一个利用类型注解对python代码进行静态类型检查的工具。</p><p>使用pip安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip3 install mypy</span><br></code></pre></td></tr></table></figure><h3 id="1-有问题的代码"><a href="#1-有问题的代码" class="headerlink" title="1. 有问题的代码"></a>1. 有问题的代码</h3><p>下面的代码在执行时不会报任何错误，但严格来讲是存在问题的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;name&#125; &#123;age&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name=self.name, age=self.age)<br><br><br>stu1 = Stu(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">16.5</span>)<br>stu2 = Stu(<span class="hljs-string">&#x27;小刚&#x27;</span>, <span class="hljs-string">&#x27;17&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(stu1, stu2)<br></code></pre></td></tr></table></figure><p>在创建Stu实例时，age参数应该传入int类型数据。但由于python是动态类型语言，因此，传入float或者字符串都不会引发错误，除非在后续的属性使用中对类型有明确要求。</p><p>这样的代码是不安全的，在程序运行前，可以通过静态类型检查来发现问题，这需要类型标注的帮助</p><h3 id="2-添加类型标注"><a href="#2-添加类型标注" class="headerlink" title="2. 添加类型标注"></a>2. 添加类型标注</h3><p>将上面的代码修改成如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, age: <span class="hljs-built_in">int</span></span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#123;name&#125; &#123;age&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name=self.name, age=self.age)<br><br><br>stu1 = Stu(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">16.5</span>)<br>stu2 = Stu(<span class="hljs-string">&#x27;小刚&#x27;</span>, <span class="hljs-string">&#x27;17&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(stu1, stu2)<br></code></pre></td></tr></table></figure><p>仅仅是添加了类型标注，我所使用的pycharm就已经提示我创建Stu实例时的age参数有问题，这种提示是委婉的，你可以不用理会。</p><p>接下来使用mypy进行静态类型检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mypy demo.py<br>demo.py:10: error: Argument 2 to &quot;Stu&quot; has incompatible type &quot;float&quot;; expected &quot;int&quot;<br>demo.py:11: error: Argument 2 to &quot;Stu&quot; has incompatible type &quot;str&quot;; expected &quot;int&quot;<br>Found 2 errors in 1 file (checked 1 source file)<br></code></pre></td></tr></table></figure><p>mypy准确的找出了两处类型与参数预期不符的情况## 13.2 【代码测试】pytest 的使用</p><blockquote><p>转载自：<a href="http://kuanghy.github.io/2018/05/08/pytest">http://kuanghy.github.io/2018/05/08/pytest</a></p></blockquote><p><code>Pytest</code> 是一个比较成熟且功能完备的 Python 测试框架。其提供完善的在线文档，并有着大量的第三方插件和内置帮助，适用于许多小型或大型项目。Pytest 灵活易学，打印调试和测试执行期间可以捕获标准输出，适合简单的单元测试到复杂的功能测试。还可以执行 nose, unittest 和 doctest 风格的测试用例，甚至 Django 和 trial。支持良好的集成实践， 支持扩展的 xUnit 风格 setup，支持非 python 测试。支持生成测试覆盖率报告，支持 PEP8 兼容的编码风格。</p><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">usage: py<span class="hljs-selector-class">.test</span> <span class="hljs-selector-attr">[options]</span> <span class="hljs-selector-attr">[file_or_dir]</span> <span class="hljs-selector-attr">[file_or_dir]</span> <span class="hljs-selector-attr">[...]</span><br></code></pre></td></tr></table></figure><h4 id="用例查找规则"><a href="#用例查找规则" class="headerlink" title="用例查找规则"></a>用例查找规则</h4><p>如果不带参数运行 pytest，那么其先从配置文件(pytest.ini，tox.ini，setup.cfg)中查找配置项 <code>testpaths</code> 指定的路径中的 test case，如果没有则从当前目录开始查找，否者，命令行参数就用于目录、文件查找。查找的规则如下：</p><ul><li>查找指定目录中以 <code>test</code> 开头的目录</li><li>递归遍历目录，除非目录指定了不同递归</li><li>查找文件名以 <code>test_</code> 开头的文件</li><li>查找以 <code>Test</code> 开头的类(该类不能有 init 方法)</li><li>查找以 <code>test_</code> 开头的函数和方法并进行测试</li></ul><p>如果要从默认的查找规则中忽略查找路径，可以加上 <code>--ingore</code> 参数，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest –ignore=tests/test_foobar.py</span><br></code></pre></td></tr></table></figure><h4 id="调用-pytest"><a href="#调用-pytest" class="headerlink" title="调用 pytest"></a>调用 pytest</h4><ul><li>py.test：</li></ul><p>Pytest 提供直接调用的命令行工具，即 <code>py.test</code>，最新版本 <code>pytest</code> 和 <code>py.test</code> 两个命令行工具都可用</p><ul><li>python -m pytest：</li></ul><p>效果和 <code>py.test</code> 一样, 这种调用方式在多 Python 版本测试的时候是有用的, 例如测试 Python3：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python3 -m pytest […]</span><br></code></pre></td></tr></table></figure><h4 id="部分参数介绍"><a href="#部分参数介绍" class="headerlink" title="部分参数介绍"></a>部分参数介绍</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">py.test <span class="hljs-comment">--version               查看版本</span><br>py.test <span class="hljs-comment">--fixtures, --funcargs  查看可用的 fixtures</span><br>pytest <span class="hljs-comment">--markers                查看可用的 markers</span><br>py.test -h, <span class="hljs-comment">--help              命令行和配置文件帮助</span><br><br><span class="hljs-comment">## 失败后停止</span><br>py.test -x           首次失败后停止执行<br>py.test <span class="hljs-comment">--maxfail=2  两次失败之后停止执行</span><br><br><span class="hljs-comment">## 调试输出</span><br>py.test -l, <span class="hljs-comment">--showlocals  在 traceback 中显示本地变量</span><br>py.test -q, <span class="hljs-comment">--quiet       静默模式输出</span><br>py.test -v, <span class="hljs-comment">--verbose     输出更详细的信息</span><br>py.test -s                捕获输出, 例如显示 print 函数的输出<br>py.test -r <span class="hljs-keyword">char</span>           显示指定测试类型的额外摘要信息<br>py.test <span class="hljs-comment">--tb=style        错误信息输出格式</span><br>    - <span class="hljs-keyword">long</span>    默认的traceback信息格式化形式<br>    - native  标准库格式化形式<br>    - <span class="hljs-keyword">short</span>   更短的格式<br>    - <span class="hljs-built_in">line</span>    每个错误一行<br><br><span class="hljs-comment">## 运行指定 marker 的测试</span><br>pytest -m MARKEXPR<br><br><span class="hljs-comment">## 运行匹配的测试</span><br>py.test -k stringexpr<br><br><span class="hljs-comment">## 只收集并显示可用的测试用例，但不运行测试用例</span><br>py.test <span class="hljs-comment">--collect-only</span><br><br><span class="hljs-comment">## 失败时调用 PDB</span><br>py.test <span class="hljs-comment">--pdb</span><br></code></pre></td></tr></table></figure><h4 id="执行选择用例"><a href="#执行选择用例" class="headerlink" title="执行选择用例"></a>执行选择用例</h4><ul><li>执行单个模块中的全部用例:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">py.test test_mod.py</span><br></code></pre></td></tr></table></figure><ul><li>执行指定路径下的全部用例:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">py.test somepath</span><br></code></pre></td></tr></table></figure><ul><li>执行字符串表达式中的用例:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">py.test -k stringexpr</span><br></code></pre></td></tr></table></figure><p>比如 “MyClass?and not method”，选择 TestMyClass.test_something，排除了TestMyClass.test_method_simple。</p><ul><li>导入 package，使用其文件系统位置来查找和执行用例。执行 pkg 目录下的所有用例:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">py.test –pyargs pkg</span><br></code></pre></td></tr></table></figure><ul><li>运行指定模块中的某个用例，如运行 test_mod.py 模块中的 test_func 测试函数:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest test_mod.py::test_func</span><br></code></pre></td></tr></table></figure><ul><li>运行某个类下的某个用例，如运行 TestClass 类下的 test_method 测试方法:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest test_mod.py::TestClass::test_method</span><br></code></pre></td></tr></table></figure><h3 id="2-断言"><a href="#2-断言" class="headerlink" title="2. 断言"></a>2. 断言</h3><p>通常情况下使用 <code>assert</code> 语句就能对大多数测试进行断言。对于异常断言，可以使用上下文管理器 <code>pytest.raises</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_zero_division</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ZeroDivisionError):<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br><br><span class="hljs-comment">## 还可以捕获异常信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_zero_division</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ZeroDivisionError, message=<span class="hljs-string">&#x27;integer division or modulo by zero&#x27;</span>):<br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>对于警告断言，可以使用上下文管理器 <code>pytest. warns</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> pytest.warns(RuntimeWarning):<br>        warnings.warn(<span class="hljs-string">&quot;my warning&quot;</span>, RuntimeWarning)<br><br><span class="hljs-keyword">with</span> warns(UserWarning, <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;must be 0 or None&#x27;</span>):<br>    warnings.warn(<span class="hljs-string">&quot;value must be 0 or None&quot;</span>, UserWarning)<br><br><span class="hljs-keyword">with</span> warns(UserWarning, <span class="hljs-keyword">match</span>=<span class="hljs-string">r&#x27;must be \d+$&#x27;</span>):<br>    warnings.warn(<span class="hljs-string">&quot;value must be 42&quot;</span>, UserWarning)<br></code></pre></td></tr></table></figure><p>如果仅需断言 <code>DeprecationWarning</code> 或者 <code>PendingDeprecationWarning</code> 警告，可以使用 <code>pytest.deprecated_call</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">api_call_v2</span>():<br>    warnings.warn(<span class="hljs-string">&#x27;use v3 of this api&#x27;</span>, DeprecationWarning)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">200</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-keyword">with</span> pytest.deprecated_call():<br>        <span class="hljs-keyword">assert</span> api_call_v2() == <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>对于自定义类型的 assert 比较断言，可以通过在 <code>conftest.py</code> 文件中实现<code>pytest_assertrepr_compare</code> 函数来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## content of test_foocompare.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>         self.val = val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.val == other.val<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_compare</span>():<br>    f1 = Foo(<span class="hljs-number">1</span>)<br>    f2 = Foo(<span class="hljs-number">2</span>)<br>    f3 = Foo(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">assert</span> f1 == f3<br>    <span class="hljs-keyword">assert</span> f1 == f2<br><br><br><span class="hljs-comment">## content of conftest.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_assertrepr_compare</span>(<span class="hljs-params">op, left, right</span>):<br>    <span class="hljs-keyword">from</span> test_foocompare <span class="hljs-keyword">import</span> Foo<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(left, Foo) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(right, Foo) <span class="hljs-keyword">and</span> op == <span class="hljs-string">&quot;==&quot;</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;Comparing Foo instances:&#x27;</span>, <span class="hljs-string">&#x27;vals: %s != %s&#x27;</span> % (left.val, right.val)]<br></code></pre></td></tr></table></figure><p>如果需要手动设置失败原因，可以使用 <code>pytest.fail</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sys_version</span>():<br>    <span class="hljs-keyword">if</span> sys.version_info[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>:<br>        pytest.fail(<span class="hljs-string">&quot;python2 not supported&quot;</span>)<br></code></pre></td></tr></table></figure><p>使用 <code>pytest.skip</code> 和 <code>pytest.xfail</code> 能够实现跳过测试的功能，skip 表示直接跳过测试，而 xfail 则表示存在预期的失败，但两者的效果差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_skip_and_xfail</span>():<br>    <span class="hljs-keyword">if</span> sys.version_info[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">3</span>:<br>        pytest.skip(<span class="hljs-string">&#x27;only support python3&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- start&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-number">1</span>/<span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        pytest.xfail(<span class="hljs-string">&quot;division by zero: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(e))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- end&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>pytest.importorskip</code> 可以在导入失败的时候跳过测试，还可以要求导入的包要满足特定的版本：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">docutils</span> = pytest.importorskip(<span class="hljs-string">&quot;docutils&quot;</span>)<br><span class="hljs-attr">docutils</span> = pytest.importorskip(<span class="hljs-string">&quot;docutils&quot;</span>, minversion = <span class="hljs-string">&quot;0.3&quot;</span>)<br></code></pre></td></tr></table></figure><p>断言近似相等可以使用 <code>pytest.approx</code>：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">assert</span> <span class="hljs-number">2</span>.<span class="hljs-number">2</span> == pytest.approx(<span class="hljs-number">2</span>.<span class="hljs-number">3</span>)<br><span class="hljs-attribute">assert</span> <span class="hljs-number">2</span>.<span class="hljs-number">2</span> == pytest.approx(<span class="hljs-number">2</span>.<span class="hljs-number">3</span>, <span class="hljs-number">0</span>.<span class="hljs-number">1</span>)<br><span class="hljs-attribute">assert</span> pytest.approx(<span class="hljs-number">2</span>.<span class="hljs-number">3</span>, <span class="hljs-number">0</span>.<span class="hljs-number">1</span>) == <span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="3-conftest-py"><a href="#3-conftest-py" class="headerlink" title="3. conftest.py"></a>3. conftest.py</h3><p>从广义理解，<code>conftest.py</code> 是一个本地的 <code>per-directory</code> 插件，在该文件中可以定义目录特定的 hooks 和 fixtures。<code>py.test</code> 框架会在它测试的项目中寻找 conftest.py 文件，然后在这个文件中寻找针对整个目录的测试选项，比如是否检测并运行 doctest 以及应该使用哪种模式检测测试文件和函数。</p><p>总结起来，<code>conftest.py</code> 文件大致有如下几种功能：</p><ul><li><strong>Fixtures:</strong> 用于给测试用例提供静态的测试数据，其可以被所有的测试用于访问，除非指定了范围</li><li><strong>加载插件:</strong> 用于导入外部插件或模块:</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">pytest_plugins</span> =<span class="hljs-string">&quot;myapp.testsupport.myplugin&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong>定义钩子:</strong> 用于配置钩子(hook)，如 pytest_runtest_setup、pytest_runtest_teardown、pytest_config 等：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_runtest_setup</span>(<span class="hljs-params">item</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;called before `pytest_runtest_call(item)`&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>再比如添加命令行选项的钩子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## content of conftest.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_addoption</span>(<span class="hljs-params">parser</span>):<br>    parser.addoption(<span class="hljs-string">&quot;--full&quot;</span>, action=<span class="hljs-string">&quot;store_ture&quot;</span>,<br>        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;run full test&quot;</span>)<br><br><span class="hljs-comment">## content of test.py</span><br><span class="hljs-meta">@pytest.mark.skipif(<span class="hljs-params"><span class="hljs-keyword">not</span> pytest.config.getoption(<span class="hljs-params"><span class="hljs-string">&quot;--runslow&quot;</span></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func_slow_1</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;当在命令行执行 --runslow 参数时才执行该测试&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;skip slow&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><strong>测试根路径:</strong> 如果将 conftest.py 文件放在项目根路径中，则 pytest 会自己搜索项目根目录下的子模块，并加入到 sys.path 中，这样便可以对项目中的所有模块进行测试，而不用设置 PYTHONPATH 来指定项目模块的位置。</li></ul><p>可以有多个 <code>conftest.py</code> 文件同时存在，其作用范围是目录。例如测试非常复杂时，可以为特定的一组测试创建子目录，并在该目录中创建 conftest.py 文件，并定义一个 futures 或 hooks。就像如下的结构：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">tests<br>├── conftest.<span class="hljs-keyword">py</span><br>├── <span class="hljs-keyword">mod</span><br>│   └── conftest.<span class="hljs-keyword">py</span><br>├── mod2<br>│   └── conftest.<span class="hljs-keyword">py</span><br>└── mod3<br>    └── conftest.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h3 id="4-Fixtures"><a href="#4-Fixtures" class="headerlink" title="4. Fixtures"></a>4. Fixtures</h3><p><code>fixture</code> 是 pytest 特有的功能，它用 pytest.fixture 标识，定义在函数前面。在编写测试函数的时候，可以将此函数名称做为传入参数，pytest 将会以依赖注入方式，将该函数的返回值作为测试函数的传入参数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pytest.fixture(<span class="hljs-attribute">scope</span>=<span class="hljs-string">&#x27;function&#x27;</span>, <span class="hljs-attribute">params</span>=None, <span class="hljs-attribute">autouse</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">ids</span>=None)<br></code></pre></td></tr></table></figure><h4 id="作为参数"><a href="#作为参数" class="headerlink" title="作为参数"></a>作为参数</h4><p><code>fixture</code> 可以作为其他测试函数的参数被使用，前提是其必须返回一个值：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@pytest</span>.fixture()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">hello</span>):<br>    assert hello == <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;fixture should return hello&quot;</span><br></code></pre></td></tr></table></figure><p>一个更加实用的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp</span>():<br>    <span class="hljs-keyword">import</span> smtplib<br>    <span class="hljs-keyword">return</span> smtplib.SMTP(<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">smtp</span>):<br>    response, msg = smtp.ehlo()<br>    <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> <span class="hljs-comment"># for demo purposes</span><br></code></pre></td></tr></table></figure><h4 id="作为-setup"><a href="#作为-setup" class="headerlink" title="作为 setup"></a>作为 setup</h4><p><code>fixture</code> 也可以不返回值，这样可以用于在测试方法运行前运行一段代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@pytest</span>.<span class="hljs-built_in">fixture</span>()  # 默认参数，每个测试方法前调用<br>def <span class="hljs-built_in">before</span>():<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before each test&#x27;</span>)<br><br>def <span class="hljs-built_in">test_1</span>(before):<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test_1()&#x27;</span>)<br><br><span class="hljs-variable">@pytest</span>.mark.<span class="hljs-built_in">usefixtures</span>(<span class="hljs-string">&quot;before&quot;</span>)<br>def <span class="hljs-built_in">test_2</span>():<br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test_2()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这种方式与 setup_method、setup_module 等的用法相同，其实它们也是特殊的 fixture。</p><p>在上例中，有一个测试用了 <code>pytest.mark.usefixtures</code> 装饰器来标记使用哪个 fixture，这中用法表示在开始测试前应用该 fixture 函数但不需要其返回值。使用这种用法时，通过 <code>addfinallizer</code> 注册释放函数，以此来做一些“善后”工作，这类似于 teardown_function、teardown_module 等用法。示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">import</span> smtplib<br>    smtp = smtplib.SMTP(<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fin</span>():<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;teardown smtp&quot;</span>)<br>        smtp.close()<br><br>    request.addfinalizer(fin)<br>    <span class="hljs-keyword">return</span> smtp  <span class="hljs-comment"># provide the fixture value</span><br></code></pre></td></tr></table></figure><h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p><code>fixtrue</code> 可以通过设置 scope 参数来控制其作用域（同时也控制了调用的频率）。如果 <code>scope=&#39;module&#39;</code>，那么 fixture 就是模块级的，这个 fixture 函数只会在每次相同模块加载的时候执行。这样就可以复用一些需要时间进行创建的对象。fixture 提供三种作用域，用于指定 fixture 初始化的规则：</p><ul><li>function：每个测试函数之前执行一次，默认</li><li>module：每个模块加载之前执行一次</li><li>session：每次 session 之前执行一次，即每次测试执行一次</li></ul><h4 id="反向请求"><a href="#反向请求" class="headerlink" title="反向请求"></a>反向请求</h4><p><code>fixture</code> 函数可以通过接受 <code>request</code> 对象来反向获取请求中的测试函数、类或模块上下文。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">import</span> smtplib<br>    server = <span class="hljs-built_in">getattr</span>(request.module, <span class="hljs-string">&quot;smtpserver&quot;</span>, <span class="hljs-string">&quot;smtp.qq.com&quot;</span>)<br>    smtp = smtplib.SMTP(server, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">yield</span> smtp<br>    smtp.close()<br></code></pre></td></tr></table></figure><p>有时需要全面测试多种不同条件下的一个对象，功能是否符合预期。可以通过设置 fixture 的 params 参数，然后通过 request 获取设置的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b, c</span>):<br>        self.a = a<br>        self.b = b<br>        self.c = c<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">echo</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span> self.a, self.b, self.c<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>], [<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>]]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> Foo(*request.param)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_foo</span>(<span class="hljs-params">foo</span>):<br>    <span class="hljs-keyword">assert</span> foo.echo()<br></code></pre></td></tr></table></figure><p>设置 params 参数后，运行 test 时将生成不同的测试 id，可以通过 ids 自定义 id：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>], ids=[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">param_a</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_param_a</span>(<span class="hljs-params">param_a</span>):<br>    <span class="hljs-built_in">print</span> param_a<br></code></pre></td></tr></table></figure><p>运行以上实例会有如下结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">test_fixture<span class="hljs-selector-class">.py</span>::test_param_a<span class="hljs-selector-attr">[a]</span> <span class="hljs-number">1</span><br>PASSED<br>test_fixture<span class="hljs-selector-class">.py</span>::test_param_a<span class="hljs-selector-attr">[b]</span> <span class="hljs-number">2</span><br>PASSED<br>test_fixture<span class="hljs-selector-class">.py</span>::test_param_a<span class="hljs-selector-attr">[c]</span> <span class="hljs-number">4</span><br>PASSED<br>test_fixture<span class="hljs-selector-class">.py</span>::test_param_a<span class="hljs-selector-attr">[d]</span> <span class="hljs-number">8</span><br>PASSED<br></code></pre></td></tr></table></figure><h4 id="自动执行"><a href="#自动执行" class="headerlink" title="自动执行"></a>自动执行</h4><p>有时候需要某些 fixture 在全局自动执行，如某些全局变量的初始化工作，亦或一些全局化的清理或者初始化函数。这时可以通过设置 fixture 的 autouse 参数来让 fixture 自动执行。设置为 autouse&#x3D;True 即可使得函数默认执行。以下例子会在开始测试前清理可能残留的文件，接着将程序目录设置为该目录，：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">work_dir = <span class="hljs-string">&quot;/tmp/app&quot;</span><br>@pytest.fixture(<span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;session&quot;</span>, <span class="hljs-attribute">autouse</span>=<span class="hljs-literal">True</span>)<br>def clean_workdir():<br>    shutil.rmtree(work_dir)<br>    os.mkdir(work_dir)<br>    os.chrdir(work_dir)<br></code></pre></td></tr></table></figure><h3 id="5-setup-x2F-teardown"><a href="#5-setup-x2F-teardown" class="headerlink" title="5. setup&#x2F;teardown"></a>5. setup&#x2F;teardown</h3><p><code>setup/teardown</code> 是指在模块、函数、类开始运行以及结束运行时执行一些动作。比如在一个函数中测试一个数据库应用，测需要在函数开始前连接数据库，在函数运行结束后断开与数据库的连接。setup&#x2F;teardown 是特殊的 fixture，其可以有一下几种实现方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 模块级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_module</span>(<span class="hljs-params">module</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown_module</span>(<span class="hljs-params">module</span>):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment">## 类级别</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_class</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown_class</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment">## 方法级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_method</span>(<span class="hljs-params">self, method</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown_method</span>(<span class="hljs-params">self, method</span>):<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment">## 函数级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_function</span>(<span class="hljs-params">function</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown_function</span>(<span class="hljs-params">function</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>有时候，还希望有全局的 setup 或 teardown，以便在测试开始时做一些准备工作，或者在测试结束之后做一些清理工作。这可以用 hook 来实现：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_sessionstart</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-comment"># setup_stuff</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_sessionfinish</span>(<span class="hljs-params">session, exitstatus</span>):<br>    <span class="hljs-comment"># teardown_stuff</span><br></code></pre></td></tr></table></figure><p>也可以用 fixture 的方式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@fixture(<span class="hljs-params">scope=<span class="hljs-string">&#x27;session&#x27;</span>, autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>():<br>    <span class="hljs-comment"># setup_stuff</span><br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-comment"># teardown_stuff</span><br></code></pre></td></tr></table></figure><h3 id="6-Markers"><a href="#6-Markers" class="headerlink" title="6. Markers"></a>6. Markers</h3><p><code>marker</code> 的作用是，用来标记测试，以便于选择性的执行测试用例。Pytest 提供了一些内建的 marker：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 跳过测试</span><br><span class="hljs-meta">@pytest.mark.skip(<span class="hljs-params">reason=<span class="hljs-literal">None</span></span>)</span><br><br><span class="hljs-comment">## 满足某个条件时跳过该测试</span><br><span class="hljs-meta">@pytest.mark.skipif(<span class="hljs-params">condition</span>)</span><br><br><span class="hljs-comment">## 预期该测试是失败的</span><br><span class="hljs-meta">@pytest.mark.xfail(<span class="hljs-params">condition, reason=<span class="hljs-literal">None</span>, run=<span class="hljs-literal">True</span>, raises=<span class="hljs-literal">None</span>, strict=<span class="hljs-literal">False</span></span>)</span><br><br><span class="hljs-comment">## 参数化测试函数。给测试用例添加参数，供运行时填充到测试中</span><br><span class="hljs-comment">## 如果 parametrize 的参数名称与 fixture 名冲突，则会覆盖掉 fixture</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params">argnames, argvalues</span>)</span><br><br><span class="hljs-comment">## 对给定测试执行给定的 fixtures</span><br><span class="hljs-comment">## 这种用法与直接用 fixture 效果相同</span><br><span class="hljs-comment">## 只不过不需要把 fixture 名称作为参数放在方法声明当中</span><br><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params">fixturename1, fixturename2, ...</span>)</span><br><br><span class="hljs-comment">## 让测试尽早地被执行</span><br><span class="hljs-meta">@pytest.mark.tryfirst</span><br><br><span class="hljs-comment">## 让测试尽量晚执行</span><br><span class="hljs-meta">@pytest.mark.trylast</span><br></code></pre></td></tr></table></figure><p>例如一个使用参数化测试的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params">(<span class="hljs-params"><span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;expected&quot;</span></span>), [</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_increment</span>(<span class="hljs-params">n, expected</span>):<br>     <span class="hljs-keyword">assert</span> n + <span class="hljs-number">1</span> == expected<br></code></pre></td></tr></table></figure><p>除了内建的 markers 外，pytest 还支持没有实现定义的 markers，如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@pytest</span>.mark.old_test<br>def <span class="hljs-built_in">test_one</span>():<br>    assert False<br><br><span class="hljs-variable">@pytest</span>.mark.new_test<br>def <span class="hljs-built_in">test_two</span>():<br>    assert False<br><br><span class="hljs-variable">@pytest</span>.mark.windows_only<br>def <span class="hljs-built_in">test_three</span>():<br>    assert False<br></code></pre></td></tr></table></figure><p>通过使用 <code>-m</code> 参数可以让 pytest 选择性的执行部分测试：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ pytest test.<span class="hljs-keyword">py</span> -<span class="hljs-keyword">m</span> <span class="hljs-string">&#x27;not windows_only&#x27;</span><br>...<br>collected <span class="hljs-number">3</span> <span class="hljs-built_in">items</span> / <span class="hljs-number">1</span> deselected                                                                                                                             <br><br>test_marker.<span class="hljs-keyword">py</span>::test_one FAILED<br></code></pre></td></tr></table></figure><p>更详细的关于 marker 的说明可以参考官方文档：</p><ul><li><a href="https://docs.pytest.org/en/latest/mark.html">https://docs.pytest.org/en/latest/mark.html</a></li><li><a href="https://docs.pytest.org/en/latest/example/markers.html">https://docs.pytest.org/en/latest/example/markers.html</a></li></ul><h3 id="7-第三方插件"><a href="#7-第三方插件" class="headerlink" title="7. 第三方插件"></a>7. 第三方插件</h3><ul><li>pytest-randomly: 测试顺序随机</li><li>pytest-xdist: 分布式测试</li><li>pytest-cov: 生成测试覆盖率报告</li><li>pytest-pep8: 检测代码是否符合 PEP8 规范</li><li>pytest-flakes: 检测代码风格</li><li>pytest-html: 生成 html 报告</li><li>pytest-rerunfailures: 失败重试</li><li>pytest-timeout: 超时测试</li></ul><h3 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h3><ul><li><a href="https://docs.pytest.org/en/latest/example/">https://docs.pytest.org/en/latest/example/</a></li><li><a href="https://docs.pytest.org/en/latest/assert.html">https://docs.pytest.org/en/latest/assert.html</a></li><li><a href="https://docs.pytest.org/en/latest/reference.html">https://docs.pytest.org/en/latest/reference.html</a></li><li><a href="http://doc.pytest.org/en/latest/xunit_setup.html">http://doc.pytest.org/en/latest/xunit_setup.html</a></li><li><a href="https://docs.pytest.org/en/latest/skipping.html">https://docs.pytest.org/en/latest/skipping.html</a></li><li><a href="https://docs.pytest.org/en/latest/fixture.html">https://docs.pytest.org/en/latest/fixture.html</a></li><li><a href="http://senarukana.github.io/2015/05/29/pytest-fixture/">http://senarukana.github.io/2015/05/29/pytest-fixture/</a></li><li><a href="https://docs.pytest.org/en/latest/parametrize.html">https://docs.pytest.org/en/latest/parametrize.html</a></li><li><a href="https://docs.pytest.org/en/latest/plugins.html##">https://docs.pytest.org/en/latest/plugins.html##</a> 13.3 【代码提交】pre-commit hook</li></ul><blockquote><p>转载自：<a href="https://juejin.cn/post/6844903844103585805">https://juejin.cn/post/6844903844103585805</a></p></blockquote><p>代码规范、测试是开发中很重要的一环，重要性无需我多说。我们需要一些自动化工具，来帮助我们更轻松地管理项目。本文推荐几个实用的自动化工具。</p><p>pre-commit 我在之前的一篇文章  <a href="https://juejin.im/post/6844903838382555143">推荐一些维护大型 Python 项目的工具</a>中简要提到过，这里再稍微讲一下。</p><p>pre-commit 用到一个配置文件：<code>.pre-commit-config.yaml</code>，官方文档在<a href="https://pre-commit.com/">这里</a>。这里针对 Python 项目，希望 git precommit hooks 能够实现以下功能：能找出不符合 pep8规范的代码，并且能够自动格式化。这需要用到两个工具：<code>black</code>和<code>flake8</code>，<code>black</code>自动格式化，<code>flake8</code>检测代码不规范的地方。</p><p>整个的 workflow 如下图所示：</p><p><img src="http://image.iswbm.com/20201213224702.png"></p><p>具体的执行步骤如下：</p><ol><li>安装 pre-commit : <code>pip install pre-commit</code></li><li>写<code>.pre-commit-config.yaml</code>配置文件</li><li>用<code>pre-commit install</code>安装git hooks到你的<code>.git/</code>目录</li></ol><p>我们的<code>.pre-commit-config.yaml</code>很简单，如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini">repos:<br>- repo: https://github.com/ambv/black<br>  rev: stable<br>  hooks:<br>    - id: black<br>      language_version: python3.7<br>- repo: https://github.com/pre-commit/pre-commit-hooks<br>  rev: v1.2.3<br>  hooks:<br>    - id: flake8<br></code></pre></td></tr></table></figure><p>然后我们下一次提交 commit 的时候，会先运行<code>black</code>和<code>flake8</code>，检查出哪有不规范的地方，并且能自动帮你格式化。你修改之后重新提交 commit，就能顺利提交了。</p><p>实际操作一下：</p><p>新建一个测试文件：<code>bad_pep8.py</code>：</p><p><img src="http://image.iswbm.com/20201213224716.png"></p><p>有好几处不符合 pep8规范，我们试着 commit 一下：</p><p><img src="http://image.iswbm.com/20201213224726.png"></p><p>可以看到两个 hook 都没有通过，另外 <code>black</code>帮我们把代码格式化了。</p><p><img src="http://image.iswbm.com/20201213224737.png"></p><p>同时<code>flake8</code>提示我们<code>x</code>变量定义了但是没有使用，把这一行删掉，然后重新add 并 commit：</p><p><img src="http://image.iswbm.com/20201213224752.png"></p><p>如果你觉得没有必要强制要求不能定义变量而不使用（从输出可以看出这个规范的编号为F841），可以在项目根目录建一个<code>.flake8</code>配置文件，如下图。更加详细的配置请看<a href="http://flake8.pycqa.org/en/latest/user/configuration.html">官方文档</a>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[flake8]</span><br><span class="hljs-attr">ignore</span> = F841<br></code></pre></td></tr></table></figure><h2 id="13-4-【项目生成】cookiecutter-的使用"><a href="#13-4-【项目生成】cookiecutter-的使用" class="headerlink" title="13.4 【项目生成】cookiecutter 的使用"></a>13.4 【项目生成】cookiecutter 的使用</h2><blockquote><p>转载自：<a href="https://note.qidong.name/2018/10/cookiecutter/">https://note.qidong.name/2018/10/cookiecutter/</a></p></blockquote><p>IDE都会有一套生成新项目的向导（Wizard），通过点点点，就可以得到一个可以运行的某类程序。 这样的程序，具备了推荐的项目结构，配置的基本的编译、打包、测试，尽管功能只是一个<code>helloworld</code>。 这个功能，极大地降低了初学者的进入门槛，也统一了某类项目的文件结构，是一个了不起的进步。 最早使用这类手段的，似乎是Visual Studio。</p><p>令人惋惜的是，Python的IDE——PyCharm并不自带这个功能。 这其中，也有Python项目千变万化的因素。 Python的适用范围太广，从桌面到服务器，从游戏到数据分析，都做一套显然投入太大。 而Python又是一门解释型语言，随便写个文件也能直接执行，似乎没有这个必要。</p><p>然而，我要说，还是有必要的！</p><p>因为Python系缺失一个Wizard，也缺少项目结构的标准，于是出现了<a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>。 这是一个项目生成器，也可称为引擎，因为它只完成了最核心的功能。 真正决定一个项目长什么样的模板，却可以自由定制。 也因此，它能生成任何一种语言的项目。</p><h3 id="1-快速安装-1"><a href="#1-快速安装-1" class="headerlink" title="1. 快速安装"></a>1. 快速安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ pip install cookiecutter<br></code></pre></td></tr></table></figure><p><a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>就是一个已经发布的Python包，因此用Python的手段可以直接安装。</p><p>对于非Python系的程序员来说，也可以使用包管理器的方式安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## For Mac</span><br>$ brew install cookiecutter<br><span class="hljs-comment">## For Debian/Ubuntu</span><br>$ sudo apt install cookiecutter<br></code></pre></td></tr></table></figure><h3 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h3><p>首先，寻找一个合适的<a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>项目。 最主要的方式，就是访问其GitHub主页的<a href="https://github.com/audreyr/cookiecutter/tree/db14e06a1dcc0187beeafde72685c3acef93eb68#a-pantry-full-of-cookiecutters">A Pantry Full of Cookiecutters</a>。</p><p>如果挑选完毕（这里以<a href="https://github.com/audreyr/cookiecutter-pypackage">cookiecutter-pypackage</a>为例），则可直接执行<code>cookiecutter</code>生成项目。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git<br>full_name [Yan QiDong]:<br>email [yanqd0@outlook.com]:<br>github_username [yanqd0]:<br>project_name [Python Boilerplate]: trycookie<br>project_slug [trycookie]:<br>project_short_description [Python Boilerplate contains all the boilerplate you need to create a Python package.]: A description<br>pypi_username [yanqd0]:<br>version [0.1.0]:<br>use_pytest [n]:<br>use_pypi_deployment_with_travis [y]:<br>add_pyup_badge [n]:<br>Select command_line_interface:<br>1 - Click<br>2 - No command-line interface<br>Choose from 1, 2 (1, 2) [1]:<br>create_author_file [y]:<br>Select open_source_license:<br>1 - MIT license<br>2 - BSD license<br>3 - ISC license<br>4 - Apache Software License 2.0<br>5 - GNU General Public License v3<br>6 - Not open <span class="hljs-built_in">source</span><br>Choose from 1, 2, 3, 4, 5, 6 (1, 2, 3, 4, 5, 6) [1]:<br></code></pre></td></tr></table></figure><p>在项目生成过程中，会产生一些提示，需要输入对应信息。 这和各类Wizard的GUI中，填写项目名、包名什么的，是同类操作。 以上是，除了项目名叫<code>trycookie</code>，基本都选默认的一个结果。</p><p>查看项目结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tree -a trycookie<br>trycookie<br>├── .editorconfig<br>├── .github<br>│   └── ISSUE_TEMPLATE.md<br>├── .gitignore<br>├── .travis.yml<br>├── AUTHORS.rst<br>├── CONTRIBUTING.rst<br>├── HISTORY.rst<br>├── LICENSE<br>├── MANIFEST.<span class="hljs-keyword">in</span><br>├── Makefile<br>├── README.rst<br>├── docs<br>│   ├── Makefile<br>│   ├── authors.rst<br>│   ├── conf.py<br>│   ├── contributing.rst<br>│   ├── history.rst<br>│   ├── index.rst<br>│   ├── installation.rst<br>│   ├── make.bat<br>│   ├── readme.rst<br>│   └── usage.rst<br>├── requirements_dev.txt<br>├── setup.cfg<br>├── setup.py<br>├── tests<br>│   ├── __init__.py<br>│   └── test_trycookie.py<br>├── tox.ini<br>└── trycookie<br>    ├── __init__.py<br>    ├── cli.py<br>    └── trycookie.py<br><br>4 directories, 30 files<br></code></pre></td></tr></table></figure><p>如此庞大而复杂的一个项目结构，融合了作者<a href="https://github.com/audreyr">audreyr</a>对一个开源PyPI项目的理解。 虽然未必适用于任何一个人，但对于什么也不懂的菜鸟来说，却无疑是福音。</p><h3 id="3-基本原理"><a href="#3-基本原理" class="headerlink" title="3. 基本原理"></a>3. 基本原理</h3><p><a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>的工作原理，是先下载一个模板项目，然后替换模板项目的某些内容，生成新的项目。 在以上的示例中，<code>https://github.com/audreyr/cookiecutter-pypackage.git</code>就是一个项目的Git链接。 这可以换成任何一个可以用<code>git clone</code>来下载的链接，包括各种私有Git托管平台。</p><p>如果是GitHub，还可以用以下的等效形式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cookiecutter gh:audreyr/cookiecutter-pypackage<br></code></pre></td></tr></table></figure><p><a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>的简短形式，支持以下三种平台。</p><table><thead><tr><th>Platform</th><th>abbreviation</th></tr></thead><tbody><tr><td><a href="https://github.com/">GitHub</a></td><td><code>gh</code></td></tr><tr><td><a href="https://bitbucket.org/">BitBucket</a></td><td><code>bb</code></td></tr><tr><td><a href="https://gitlab.com/">GitLab</a></td><td><code>gl</code></td></tr></tbody></table><p><a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>也支持Mercurial（<code>hg</code>）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cookiecutter hg+ssh://hg@bitbucket.org/audreyr/cookiecutter-pypackage<br></code></pre></td></tr></table></figure><p>使用过模板的项目，默认都已经被下载到<code>~/.cookiecutter</code>目录下。 如果需要再次使用，而又无需更新，可以直接用项目名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cookiecutter cookiecutter-pypackage<br></code></pre></td></tr></table></figure><p>利用这个特点，可以先用各种手段，把模板项目下载到<code>~/.cookiecutter</code>目录下，再来使用。</p><p>参考：<a href="https://cookiecutter.readthedocs.io/en/latest/usage.html">Usage — cookiecutter 1.6.0 documentation</a></p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><p>默认情况下，<code>~/.cookiecutterrc</code>就是配置文件。 它实际上是一个YAML文件。 以下是孤的配置文件示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## vim: set filetype=yaml:</span><br><br><span class="hljs-attr">default_context:</span><br>  <span class="hljs-attr">full_name:</span> <span class="hljs-string">&quot;Yan QiDong&quot;</span><br>  <span class="hljs-attr">email:</span> <span class="hljs-string">&quot;yanqd0@outlook.com&quot;</span><br>  <span class="hljs-attr">github_username:</span> <span class="hljs-string">&quot;yanqd0&quot;</span><br><span class="hljs-attr">cookiecutters_dir:</span> <span class="hljs-string">&quot;~/.cookiecutters/&quot;</span><br><span class="hljs-attr">abbreviations:</span><br>    <span class="hljs-attr">pp:</span> <span class="hljs-string">https://github.com/audreyr/cookiecutter-pypackage.git</span><br>    <span class="hljs-attr">gh:</span> <span class="hljs-string">https://github.com/&#123;0&#125;.git</span><br></code></pre></td></tr></table></figure><p>可配置项中，<code>default_context</code>是设置生成项目时，一些提示信息的默认参数。 <code>cookiecutters_dir</code>则是项目的下载位置，一般默认就好。 <code>abbreviations</code>是自定义简短形式，属于高级定制功能，仅适用于重度用户。 通常，填一填<code>default_context</code>就好。</p><p>如果对<code>~/.cookiecutterrc</code>这个配置文件的名称和位置不满意， 可以通过环境变量<code>COOKIECUTTER_CONFIG</code>， 或者在命令行指定参数<code>--config-file</code>来指定新的配置文件。</p><p>参考：<a href="https://cookiecutter.readthedocs.io/en/latest/advanced/user_config.html">User Config (0.7.0+) — cookiecutter 1.6.0 documentation</a></p><h3 id="5-总结一下-1"><a href="#5-总结一下-1" class="headerlink" title="5. 总结一下"></a>5. 总结一下</h3><p><a href="https://github.com/audreyr/cookiecutter">cookiecutter</a>是一个简单好用的项目生成器引擎，并且已经有很多各种类型的模板。 除了Python项目，还有很多其它语言的项目模板。 它可以极大地省去一个项目初始化的重复劳动，也可以帮助菜鸟程序员成长。</p><p>当然，如果不满意，还是可以自己修改、定制模板的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习杂记</title>
    <link href="/2023/09/03/Python%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0/"/>
    <url>/2023/09/03/Python%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="学习过程中的一些零散问题记录"><a href="#学习过程中的一些零散问题记录" class="headerlink" title="学习过程中的一些零散问题记录"></a>学习过程中的一些零散问题记录</h1><p>[toc]</p><h2 id="0-一些规范"><a href="#0-一些规范" class="headerlink" title="0. 一些规范"></a>0. 一些规范</h2><h3 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h3><ol><li>以单一下划线开头的变量名(_X)不会被from module import*等语句导入</li><li>前后有两个下划线的变量名(<strong>X</strong>)是系统定义的变量名，对解释器有特殊意义</li><li>以两个下划线开头但不以下划线结尾的变量名(__X)是类的本地(私有)变量</li></ol><h3 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;数学运算类&quot;&quot;&quot;</span><br><span class="hljs-built_in">abs</span>(x)                              <span class="hljs-comment"># 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模</span><br><span class="hljs-built_in">complex</span>([real[, imag]])             <span class="hljs-comment"># 创建一个复数</span><br><span class="hljs-built_in">divmod</span>(a, b)                        <span class="hljs-comment"># 分别取商和余数，注意：整型、浮点型都可以</span><br><span class="hljs-built_in">float</span>([x])                          <span class="hljs-comment"># 将一个字符串或数转换为浮点数。如果无参数将返回0.0</span><br><span class="hljs-built_in">int</span>([x[, base]])                    <span class="hljs-comment"># 将一个字符串或浮点数转换为int类型，base表示进制</span><br>long([x[, base]])                   <span class="hljs-comment"># 将一个字符串或浮点数转换为long类型</span><br><span class="hljs-built_in">pow</span>(x, y)                           <span class="hljs-comment"># 返回x的y次幂</span><br><span class="hljs-built_in">range</span>([start], stop[, step])        <span class="hljs-comment"># 产生一个序列，默认从0开始</span><br><span class="hljs-built_in">round</span>(x[, n])                       <span class="hljs-comment"># 四舍五入</span><br><span class="hljs-built_in">sum</span>(iterable[, start])              <span class="hljs-comment"># 对集合求和</span><br><span class="hljs-built_in">oct</span>(x)                              <span class="hljs-comment"># 将一个数字转化为8进制字符串</span><br><span class="hljs-built_in">hex</span>(x)                              <span class="hljs-comment"># 将一个数字转换为16进制字符串</span><br><span class="hljs-built_in">chr</span>(i)                              <span class="hljs-comment"># 返回给定int类型对应的ASCII字符</span><br>unichr(i)                           <span class="hljs-comment"># 返回给定int类型的unicode</span><br><span class="hljs-built_in">ord</span>(c)                              <span class="hljs-comment"># 返回ASCII字符对应的整数</span><br><span class="hljs-built_in">bin</span>(x)                              <span class="hljs-comment"># 将整数x转换为二进制字符串</span><br><span class="hljs-built_in">bool</span>([x])                           <span class="hljs-comment"># 将x转换为Boolean类型</span><br><br><span class="hljs-string">&quot;&quot;&quot;集合类操作&quot;&quot;&quot;</span><br>basestring()                        <span class="hljs-comment"># str和unicode的超类，不能直接调用，可以用作isinstance判断</span><br><span class="hljs-built_in">format</span>(value [, format_spec])       <span class="hljs-comment"># 格式化输出字符串，格式化的参数顺序从0开始，如“I am &#123;0&#125;,I like &#123;1&#125;”</span><br><span class="hljs-built_in">enumerate</span>(sequence[, start=<span class="hljs-number">0</span>])      <span class="hljs-comment"># 返回一个可枚举的对象，注意它有第二个参数</span><br><span class="hljs-built_in">iter</span>(obj[, sentinel])               <span class="hljs-comment"># 生成一个对象的迭代器，第二个参数表示分隔符</span><br><span class="hljs-built_in">max</span>(iterable[, args...][key])       <span class="hljs-comment"># 返回集合中的最大值</span><br><span class="hljs-built_in">min</span>(iterable[, args...][key])       <span class="hljs-comment"># 返回集合中的最小值</span><br><span class="hljs-built_in">dict</span>([arg])                         <span class="hljs-comment"># 创建数据字典</span><br><span class="hljs-built_in">list</span>([iterable])                    <span class="hljs-comment"># 将一个集合类转换为另外一个集合类</span><br><span class="hljs-built_in">set</span>()                               <span class="hljs-comment"># set对象实例化</span><br><span class="hljs-built_in">frozenset</span>([iterable])               <span class="hljs-comment"># 产生一个不可变的set</span><br><span class="hljs-built_in">tuple</span>([iterable])                   <span class="hljs-comment"># 生成一个tuple类型</span><br><span class="hljs-built_in">str</span>([<span class="hljs-built_in">object</span>])                       <span class="hljs-comment"># 转换为string类型</span><br><span class="hljs-built_in">sorted</span>(iterable[, cmp[, key[, reverse]]])             <span class="hljs-comment"># 集合排序</span><br>    L = [(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">4</span>)]<br>    <span class="hljs-built_in">sorted</span>(L, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)       <span class="hljs-comment"># 使用Key参数和reverse参数</span><br>    <span class="hljs-built_in">sorted</span>(L, key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))             <span class="hljs-comment"># 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1]</span><br><br><span class="hljs-string">&quot;&quot;&quot;逻辑判断&quot;&quot;&quot;</span><br><span class="hljs-built_in">all</span>(iterable)                       <span class="hljs-comment"># 集合中的元素都为真的时候为真，特别的，若为空串返回为True</span><br><span class="hljs-built_in">any</span>(iterable)                       <span class="hljs-comment"># 集合中的元素有一个为真的时候为真，特别的，若为空串返回为False</span><br>cmp(x, y)                           <span class="hljs-comment"># 如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数</span><br><br><span class="hljs-string">&quot;&quot;&quot;IO操作&quot;&quot;&quot;</span><br>file(filename [, mode [, bufsize]]) <span class="hljs-comment"># file类型的构造函数。</span><br><span class="hljs-built_in">input</span>([prompt])                     <span class="hljs-comment"># 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入，意思是自行判断类型</span><br><span class="hljs-comment"># 在 Built-in Functions 里有一句话是这样写的：Consider using the raw_input() function for general input from users.</span><br>raw_input([prompt])                 <span class="hljs-comment"># 设置输入，输入都是作为字符串处理,python3.x后已不再使用</span><br><span class="hljs-built_in">open</span>(name[, mode[, buffering]])     <span class="hljs-comment"># 打开文件，与file有什么不同？推荐使用open</span><br><br><span class="hljs-string">&quot;&quot;&quot;其他&quot;&quot;&quot;</span><br><span class="hljs-built_in">callable</span>(<span class="hljs-built_in">object</span>)                    <span class="hljs-comment"># 检查对象object是否可调用</span><br><span class="hljs-built_in">classmethod</span>(func)                   <span class="hljs-comment"># 用来说明这个func是个类方法</span><br><span class="hljs-built_in">staticmethod</span>(func)                  <span class="hljs-comment"># 用来说明这个func为静态方法</span><br><span class="hljs-built_in">dir</span>([<span class="hljs-built_in">object</span>])                       <span class="hljs-comment"># 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。</span><br><span class="hljs-built_in">help</span>(obj)                           <span class="hljs-comment"># 返回obj的帮助信息</span><br><span class="hljs-built_in">eval</span>(expression)                    <span class="hljs-comment"># 计算表达式expression的值，并返回</span><br><span class="hljs-built_in">exec</span>(<span class="hljs-built_in">str</span>)                           <span class="hljs-comment"># 将str作为Python语句执行</span><br>execfile(filename)                  <span class="hljs-comment"># 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。</span><br><span class="hljs-built_in">filter</span>(function, iterable)          <span class="hljs-comment"># 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数</span><br>    <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">range</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))<span class="hljs-comment"># 返回[-3, -2, -1, 1, 2, 3], 没有0</span><br><span class="hljs-built_in">hasattr</span>(<span class="hljs-built_in">object</span>, name)               <span class="hljs-comment"># 判断对象object是否包含名为name的特性</span><br><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">object</span>, name [, defalut])   <span class="hljs-comment"># 获取一个类的属性</span><br><span class="hljs-built_in">setattr</span>(<span class="hljs-built_in">object</span>, name, value)        <span class="hljs-comment"># 设置属性值</span><br><span class="hljs-built_in">delattr</span>(<span class="hljs-built_in">object</span>, name)               <span class="hljs-comment"># 删除object对象名为name的属性</span><br><span class="hljs-built_in">globals</span>()                           <span class="hljs-comment"># 返回一个描述当前全局符号表的字典</span><br><span class="hljs-built_in">hash</span>(<span class="hljs-built_in">object</span>)                        <span class="hljs-comment"># 如果对象object为哈希表类型，返回对象object的哈希值</span><br><span class="hljs-built_in">id</span>(<span class="hljs-built_in">object</span>)                          <span class="hljs-comment"># 返回对象的唯一标识，一串数字</span><br><span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">object</span>, classinfo)       <span class="hljs-comment"># 判断object是否是class的实例</span><br>    <span class="hljs-built_in">isinstance</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>)              <span class="hljs-comment"># 判断是不是int类型</span><br>    <span class="hljs-built_in">isinstance</span>(<span class="hljs-number">1</span>, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>))     <span class="hljs-comment"># isinstance的第二个参数接受一个元组类型</span><br><span class="hljs-built_in">issubclass</span>(<span class="hljs-keyword">class</span>, classinfo)        <span class="hljs-comment"># 判断class是否为classinfo的子类</span><br><span class="hljs-built_in">locals</span>()                            <span class="hljs-comment"># 返回当前的变量列表</span><br><span class="hljs-built_in">map</span>(function, iterable, ...)        <span class="hljs-comment"># 遍历每个元素，执行function操作</span><br>    <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">abs</span>, <span class="hljs-built_in">range</span>(-<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))    <span class="hljs-comment"># 返回[3, 2, 1, 0, 1, 2, 3]</span><br><span class="hljs-built_in">next</span>(iterator[, default])           <span class="hljs-comment"># 类似于iterator.next()</span><br><span class="hljs-built_in">property</span>([fget[, fset[, fdel[, doc]]]])           <span class="hljs-comment"># 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter</span><br>reduce(function, iterable[, initializer])         <span class="hljs-comment"># 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):<span class="hljs-keyword">return</span> x + y <br>    reduce(add, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>))                     <span class="hljs-comment"># 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55)</span><br>    reduce(add, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>), <span class="hljs-number">20</span>)                 <span class="hljs-comment"># 返回75</span><br>reload(module)                      <span class="hljs-comment"># 重新加载模块</span><br><span class="hljs-built_in">repr</span>(<span class="hljs-built_in">object</span>)                        <span class="hljs-comment"># 将一个对象变幻为可打印的格式</span><br><span class="hljs-built_in">slice</span>(start, stop[, step])          <span class="hljs-comment"># 产生分片对象</span><br><span class="hljs-built_in">type</span>(<span class="hljs-built_in">object</span>)                        <span class="hljs-comment"># 返回该object的类型</span><br><span class="hljs-built_in">vars</span>([<span class="hljs-built_in">object</span>])                      <span class="hljs-comment"># 返回对象的变量名、变量值的字典</span><br>    a = Class();                    <span class="hljs-comment"># Class为一个空类</span><br>    a.name = <span class="hljs-string">&#x27;qi&#x27;</span>, a.age = <span class="hljs-number">9</span><br>    <span class="hljs-built_in">vars</span>(a)                         <span class="hljs-comment"># &#123;&#x27;name&#x27;:&#x27;qi&#x27;, &#x27;age&#x27;:9&#125;</span><br><span class="hljs-built_in">zip</span>([iterable, ...])                <span class="hljs-comment"># 返回对应数组</span><br>    <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])) <span class="hljs-comment"># [(1, 4), (2, 5), (3, 6)]</span><br>    a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],  b = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br>    z = <span class="hljs-built_in">zip</span>(a, b)                   <span class="hljs-comment"># 压缩：[(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;)]</span><br>    <span class="hljs-built_in">zip</span>(*z)                         <span class="hljs-comment"># 解压缩：[(1, 2, 3), (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]</span><br>unicode(string, encoding, errors)   <span class="hljs-comment"># 将字符串string转化为unicode形式，string为encoded string。</span><br></code></pre></td></tr></table></figure><h2 id="1-print-函数打印输出时不输出默认的换行符"><a href="#1-print-函数打印输出时不输出默认的换行符" class="headerlink" title="1.print()函数打印输出时不输出默认的换行符"></a>1.print()函数打印输出时不输出默认的换行符</h2><p>在Python中，可以通过在<code>print()</code>函数中设置<code>end</code>参数来控制打印结束时的字符，默认为换行符 <code>\n</code>。如果你想要在打印结束时不换行，可以将<code>end</code>参数设置为空字符串 <code>&#39;&#39;</code>，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This is a test.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mercury">Hello, world!This <span class="hljs-keyword">is</span> a test.<br></code></pre></td></tr></table></figure><p>注意，通过将<code>end</code>参数设置为空字符串，你需要手动控制换行的位置，以确保打印输出的格式符合你的预期。</p><h2 id="2-如何将两个列表组合成一个元组列表"><a href="#2-如何将两个列表组合成一个元组列表" class="headerlink" title="2.如何将两个列表组合成一个元组列表"></a>2.如何将两个列表组合成一个元组列表</h2><p>可以使用<code>zip()</code>函数将两个列表组合成一个元组列表。<code>zip()</code>函数将按索引位置将两个列表中的元素逐个配对，返回一个包含元组的迭代器。然后，你可以将迭代器转换为列表。以下是示例代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">list1 = <span class="hljs-selector-attr">[1, 2, 3]</span><br>list2 = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]</span><br><br>combined_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(list1, list2))<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(combined_list)</span></span><br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[(<span class="hljs-name">1</span>, <span class="hljs-symbol">&#x27;a</span>&#x27;), (<span class="hljs-name">2</span>, <span class="hljs-symbol">&#x27;b</span>&#x27;), (<span class="hljs-name">3</span>, <span class="hljs-symbol">&#x27;c</span>&#x27;)]<br></code></pre></td></tr></table></figure><p>在示例中，<code>zip(list1, list2)</code>将列表<code>list1</code>和<code>list2</code>中的元素逐个配对，得到一个元组的迭代器。然后，通过<code>list()</code>函数将迭代器转换为列表，得到了一个包含元组的列表<code>combined_list</code>。</p><h2 id="3-双for循环遍历如何转为列表解析"><a href="#3-双for循环遍历如何转为列表解析" class="headerlink" title="3.双for循环遍历如何转为列表解析"></a>3.双for循环遍历如何转为列表解析</h2><p>双重循环可以通过嵌套的列表解析来转换。下面是一个示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">result</span> <span class="hljs-operator">=</span> [expression for outer_item in outer_list for inner_item in inner_list]<br></code></pre></td></tr></table></figure><p>其中，<code>expression</code> 是要在循环中计算或执行的表达式，<code>outer_list</code> 和 <code>inner_list</code> 是两个要遍历的列表。</p><p>举个例子，假设有两个列表 <code>list1</code> 和 <code>list2</code>，你想要通过双重循环生成它们的所有组合，可以使用列表解析来实现：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">list1</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-attr">list2</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-attr">combinations</span> = [(x, y) for x in list1 for y in list2]<br></code></pre></td></tr></table></figure><p>这将生成一个包含所有组合的列表 <code>combinations</code>，其中每个元素都是一个二元组 <code>(x, y)</code>，其中 <code>x</code> 是来自 <code>list1</code> 的元素，<code>y</code> 是来自 <code>list2</code> 的元素。</p><p>注意，内层循环在外层循环之后。你可以根据实际需要调整循环的顺序。</p><h2 id="4-多重赋值与顺序赋值的不同"><a href="#4-多重赋值与顺序赋值的不同" class="headerlink" title="4.多重赋值与顺序赋值的不同"></a>4.多重赋值与顺序赋值的不同</h2><p>多重赋值（Multiple Assignment），或者叫作元组赋值（Tuple Assignment）。它允许同时为多个变量赋值，使用逗号分隔多个变量名，并且可以将一个元组、列表或其他可迭代对象的值一次性赋给这些变量。</p><p>在给多个变量赋值时，右侧的表达式会先计算出所有中间结果，并按照从左到右的顺序一次性地赋值给相应的变量。这样可以简洁地交换变量的值，同时也可以将多个变量与多个表达式的结果关联起来。</p><p>下面这两段代码表示的意思是完全不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">m1 = me + m3<br>m2 = m1<br>m3 = m2<br>me = me + m3<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">m1, m2 ,m3 ,me = me+m3, m1, m2,me+m3<br></code></pre></td></tr></table></figure><p>这两段代码的区别在于变量的赋值顺序不同。</p><p>第一段代码中，赋值操作是从上到下按顺序执行的。每个变量的新值都是基于之前变量的旧值计算得到的。具体地：</p><ul><li><code>m1</code> 的新值是 <code>me + m3</code>，即 <code>me</code> 和 <code>m3</code> 的和。</li><li><code>m2</code> 的新值是 <code>m1</code>，即将 <code>m1</code> 的值赋给 <code>m2</code>。</li><li><code>m3</code> 的新值是 <code>m2</code>，即将 <code>m2</code> 的值赋给 <code>m3</code>。</li><li><code>me</code> 的新值是 <code>me + m3</code>，即 <code>me</code> 和 <code>m3</code> 的和。</li></ul><p>第二段代码中，赋值操作是一次性地同时进行的，使用了多重赋值语句。右侧的表达式会先计算出所有中间结果，然后依次赋值给左侧的变量。具体地：</p><ul><li><code>me + m3</code> 的值赋给 <code>m1</code>。</li><li><code>m1</code> 的旧值赋给 <code>m2</code>。</li><li><code>m2</code> 的旧值赋给 <code>m3</code>。</li><li><code>me + m3</code> 的值赋给 <code>me</code>。</li></ul><p>总结起来，第一段代码是逐个赋值的过程，每个变量的新值都是基于之前变量的旧值计算得到的。而第二段代码则是一次性地同时进行多个赋值操作，右侧的表达式会计算出所有中间结果，然后依次赋值给左侧的变量。两段代码的最终结果可能是不同的，取决于初始变量的值和具体的赋值逻辑。</p><h2 id="5-json-load-与json-loads-的区别"><a href="#5-json-load-与json-loads-的区别" class="headerlink" title="5.json.load()与json.loads()的区别"></a>5.json.load()与json.loads()的区别</h2><p><code>json.load()</code> 和 <code>json.loads()</code> 都是 Python 中用于解析 JSON 数据的函数，但它们有一些区别：</p><ul><li><code>json.load()</code> 用于从文件中读取 JSON 数据。它接受一个文件对象作为参数，读取文件内容并将其解析为 JSON 对象或列表。示例：<code>json.load(file_object)</code></li><li><code>json.loads()</code> 用于将字符串解析为 JSON 数据。它接受一个 JSON 字符串作为参数，将其解析为 JSON 对象或列表。示例：<code>json.loads(json_string)</code></li></ul><p>总结来说，<code>json.load()</code> 适用于读取文件中的 JSON 数据，而 <code>json.loads()</code> 适用于将字符串中的 JSON 数据解析为 Python 对象。</p><h2 id="6-让python支持中文目录路径"><a href="#6-让python支持中文目录路径" class="headerlink" title="6.让python支持中文目录路径"></a>6.让python支持中文目录路径</h2><p>要在Python代码中支持中文文件目录，可以使用以下两种方法：</p><ol><li>使用原始字符串（raw string）表示文件路径：在字符串前添加字母 “r”，以告诉Python将其作为原始字符串处理。这将确保Python不会对字符串中的特殊字符进行转义。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data_dir = <span class="hljs-string">r&#x27;E:\Learning\python\LSTM_MODEL\data&#x27;</span><br></code></pre></td></tr></table></figure><ol><li>使用Unicode字符串：在字符串前添加 “u”，以告诉Python将其作为Unicode字符串处理。Unicode字符串可以包含非ASCII字符，包括中文字符。例如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data_dir = <span class="hljs-string">u&#x27;E:\Learning\python\LSTM_MODEL\data&#x27;</span><br></code></pre></td></tr></table></figure><p>使用其中一种方法将文件路径作为字符串表示，即可在Python代码中支持中文文件目录。请注意，如果使用的是非ASCII字符集（如UTF-8），确保代码文件本身以相应的编码保存。</p><h2 id="7-统计字符串中各类字符的数量"><a href="#7-统计字符串中各类字符的数量" class="headerlink" title="7.统计字符串中各类字符的数量"></a>7.统计字符串中各类字符的数量</h2><p>一、正则表达式：</p><p>使用正则表达式可以表示字母、数字、符号和中文。下面是一些常用的正则表达式模式：</p><ul><li>字母：使用 <code>[a-zA-Z]</code> 表示所有的字母。</li><li>数字：使用 <code>\d</code> 表示所有的数字。</li><li>符号：使用 <code>[!@#$%^&amp;*()]</code> 等字符集合来表示不同的符号。例如，<code>[!@#$%^&amp;*()]</code> 表示常见的特殊符号。</li><li>符号：使用 <code>[^\w\s\u4e00-\u9fa5]</code> 用于匹配除了字母、数字、空格和中文以外的其他字符</li><li>中文：使用 <code>[\u4e00-\u9fa5]</code> 表示所有的中文字符。</li></ul><p>下面是一个示例，演示如何使用正则表达式匹配不同类型的字符并统计它们的数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello 123 你好！@#&quot;</span><br><br><span class="hljs-comment"># 匹配字母</span><br>letters = re.findall(<span class="hljs-string">r&#x27;[a-zA-Z]&#x27;</span>, text)<br>letter_count = <span class="hljs-built_in">len</span>(letters)<br><br><span class="hljs-comment"># 匹配数字</span><br>numbers = re.findall(<span class="hljs-string">r&#x27;\d&#x27;</span>, text)<br>number_count = <span class="hljs-built_in">len</span>(numbers)<br><br><span class="hljs-comment"># 匹配符号</span><br>symbols = re.findall(<span class="hljs-string">r&#x27;[!@#$%^&amp;*()]&#x27;</span>, text)<br>symbol_count = <span class="hljs-built_in">len</span>(symbols)<br><br><span class="hljs-comment"># 匹配中文</span><br>chinese_chars = re.findall(<span class="hljs-string">r&#x27;[\u4e00-\u9fa5]&#x27;</span>, text)<br>chinese_count = <span class="hljs-built_in">len</span>(chinese_chars)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字母数量:&quot;</span>, letter_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数字数量:&quot;</span>, number_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;符号数量:&quot;</span>, symbol_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;中文数量:&quot;</span>, chinese_count)<br></code></pre></td></tr></table></figure><p>二、使得字符串的内置方法实现：</p><p>使用字符串的内置方法来判断字符是否为字母、数字或空格，然后进行计数。这里是一个使用 <code>isdigit()</code>、<code>isalpha()</code> 和 <code>isspace()</code> 方法的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_characters</span>(<span class="hljs-params">text</span>):<br>    letter_count = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> char.isalpha())<br>    number_count = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> char.isdigit())<br>    space_count = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> char.isspace())<br>    chinese_count = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;\u4e00&#x27;</span> &lt;= char &lt;= <span class="hljs-string">&#x27;\u9fa5&#x27;</span>)<br>    other_count = <span class="hljs-built_in">len</span>(text) - letter_count - number_count - space_count - chinese_count<br>    <span class="hljs-keyword">return</span> letter_count, number_count, space_count, chinese_count, other_count<br><br>text = <span class="hljs-string">&quot;Hello 123 你好！@# 这是一个示例文本。&quot;</span><br>letter_count, number_count, space_count, chinese_count, other_count = count_characters(text)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字母数量:&quot;</span>, letter_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数字数量:&quot;</span>, number_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;空格数量:&quot;</span>, space_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;中文数量:&quot;</span>, chinese_count)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他符号数量:&quot;</span>, other_count)<br></code></pre></td></tr></table></figure><h2 id="8-集合set的用法"><a href="#8-集合set的用法" class="headerlink" title="8.集合set的用法"></a>8.集合set的用法</h2><p>集合（Set）是Python中的一种无序、可变的数据类型，它用于存储一组不重复的元素。集合中的元素是唯一的，不会重复出现。下面是一些常用的集合操作和方法：</p><ol><li><p>创建集合：可以使用花括号 <code>&#123;&#125;</code> 或 <code>set()</code> 函数来创建集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;  <span class="hljs-comment"># 使用花括号创建集合</span><br>my_set = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 使用set()函数创建集合</span><br></code></pre></td></tr></table></figure></li><li><p>添加元素：使用 <code>add()</code> 方法向集合中添加单个元素，使用 <code>update()</code> 方法向集合中添加多个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>my_set.add(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 添加单个元素</span><br>my_set.update([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])  <span class="hljs-comment"># 添加多个元素</span><br></code></pre></td></tr></table></figure></li><li><p>移除元素：使用 <code>remove()</code> 方法从集合中移除指定元素，如果元素不存在会抛出 <code>KeyError</code> 异常。使用 <code>discard()</code> 方法也可以移除元素，但如果元素不存在不会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>my_set.remove(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 移除元素2</span><br>my_set.discard(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 移除元素4，如果不存在不会抛出异常</span><br></code></pre></td></tr></table></figure></li><li><p>集合操作：可以使用运算符和方法进行集合的交集、并集、差集和对称差集等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">set1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>set2 = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>intersection = set1 &amp; set2  <span class="hljs-comment"># 交集</span><br>union = set1 | set2  <span class="hljs-comment"># 并集</span><br>difference = set1 - set2  <span class="hljs-comment"># 差集</span><br>symmetric_difference = set1 ^ set2  <span class="hljs-comment"># 对称差集</span><br></code></pre></td></tr></table></figure></li><li><p>遍历集合：可以使用循环语句遍历集合中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> my_set:<br>    <span class="hljs-built_in">print</span>(element)<br></code></pre></td></tr></table></figure></li><li><p>其他常用方法：集合还提供了其他一些常用的方法，如 <code>len()</code> 获取集合的元素个数，<code>clear()</code> 清空集合中的元素等。</p></li></ol><p>集合在处理需要唯一元素且顺序不重要的场景中非常有用，例如去除列表中的重复元素、检查两个集合是否有交集等。注意，集合中的元素必须是可哈希的（不可变类型），因此集合本身不能作为集合的元素，但可以包含元组等可哈希的数据类型。</p><h2 id="9-数字集合可以直接进行计算"><a href="#9-数字集合可以直接进行计算" class="headerlink" title="9.数字集合可以直接进行计算"></a>9.数字集合可以直接进行计算</h2><p>数字集合可以直接使用计算函数进行常见的数学运算。Python 提供了许多内置的数学函数和操作符，可以直接应用于数字集合。</p><p>以下是一些常见的数学函数和操作符的示例：</p><ul><li><p>求和：使用内置函数 <code>sum()</code> 可以对数字集合进行求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>total = <span class="hljs-built_in">sum</span>(my_set)<br><span class="hljs-built_in">print</span>(total)  <span class="hljs-comment"># 输出结果: 15</span><br></code></pre></td></tr></table></figure></li><li><p>最大值和最小值：使用内置函数 <code>max()</code> 和 <code>min()</code> 可以找到数字集合中的最大值和最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">15</span>&#125;<br>max_value = <span class="hljs-built_in">max</span>(my_set)<br>min_value = <span class="hljs-built_in">min</span>(my_set)<br><span class="hljs-built_in">print</span>(max_value)  <span class="hljs-comment"># 输出结果: 20</span><br><span class="hljs-built_in">print</span>(min_value)  <span class="hljs-comment"># 输出结果: 5</span><br></code></pre></td></tr></table></figure></li><li><p>平均值：使用 <code>sum()</code> 和 <code>len()</code> 函数可以计算数字集合的平均值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_set = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>average = <span class="hljs-built_in">sum</span>(my_set) / <span class="hljs-built_in">len</span>(my_set)<br><span class="hljs-built_in">print</span>(average)  <span class="hljs-comment"># 输出结果: 3.0</span><br></code></pre></td></tr></table></figure></li></ul><p>除了上述示例中的基本数学函数，还可以使用其他数学函数，如幂函数 <code>pow()</code>、绝对值函数 <code>abs()</code>、四舍五入函数 <code>round()</code> 等，根据具体的需求进行选择和使用。</p><h2 id="10-递归函数的调用"><a href="#10-递归函数的调用" class="headerlink" title="10.递归函数的调用"></a>10.递归函数的调用</h2><p>递归调用是指在函数内部调用自身的过程。通过递归调用，可以解决一些需要重复执行相同操作的问题。</p><p>下面是一个简单的示例，演示了如何使用递归调用来计算阶乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 基线条件，当 n 等于 0 时，直接返回 1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 递归条件，当 n 大于 0 时，调用自身并乘以 n</span><br>        <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 调用函数计算阶乘</span><br>result = factorial(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出结果: 120</span><br></code></pre></td></tr></table></figure><p>在这个示例中，函数 <code>factorial()</code> 通过递归调用自身来计算阶乘。当输入参数 <code>n</code> 等于 0 时，函数返回 1，作为递归的基线条件。当输入参数 <code>n</code> 大于 0 时，函数调用自身并将 <code>n</code> 乘以递归结果，实现了递归条件。</p><p>需要注意的是，使用递归调用时要确保存在合适的终止条件（基线条件），以避免无限递归导致程序崩溃。在编写递归函数时，确保每次递归调用都使问题规模减小，最终达到基线条件，从而实现问题的解决。</p><h2 id="11-pygal世界地图上的国家名称显示为中文"><a href="#11-pygal世界地图上的国家名称显示为中文" class="headerlink" title="11.pygal世界地图上的国家名称显示为中文"></a>11.pygal世界地图上的国家名称显示为中文</h2><p>在 Pygal 中，要将地图上的国家名称显示为中文，可以使用 <code>pygal.style.Style</code> 对象来设置样式，并通过设置 <code>label_font_size</code> 和 <code>major_label_font_size</code> 参数来指定标签和主要标签的字体大小。此外，还可以使用 <code>pygal_config</code> 参数来设置全局配置选项。</p><p>以下是一个示例代码，展示如何将地图上的国家名称显示为中文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygal.maps.world <span class="hljs-keyword">as</span> pygal_maps<br><br><span class="hljs-comment"># 创建地图对象</span><br>world_map = pygal_maps.World(style=pygal_maps.style.Style(label_font_size=<span class="hljs-number">14</span>, major_label_font_size=<span class="hljs-number">16</span>))<br><br><span class="hljs-comment"># 设置地图标题</span><br>world_map.title = <span class="hljs-string">&#x27;世界地图&#x27;</span><br><br><span class="hljs-comment"># 设置国别代码和对应的中文名称</span><br>country_names = &#123;<br>    <span class="hljs-string">&#x27;cn&#x27;</span>: <span class="hljs-string">&#x27;中国&#x27;</span>,<br>    <span class="hljs-string">&#x27;us&#x27;</span>: <span class="hljs-string">&#x27;美国&#x27;</span>,<br>    <span class="hljs-string">&#x27;jp&#x27;</span>: <span class="hljs-string">&#x27;日本&#x27;</span>,<br>    <span class="hljs-comment"># 添加其他国家...</span><br>&#125;<br><br><span class="hljs-comment"># 设置地图数据</span><br>world_map.add(<span class="hljs-string">&#x27;国家&#x27;</span>, country_names)<br><br><span class="hljs-comment"># 渲染地图并保存为SVG文件</span><br>world_map.render_to_file(<span class="hljs-string">&#x27;world_map.svg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个地图对象 <code>world_map</code>，并使用 <code>pygal_maps.style.Style</code> 对象来设置样式，其中 <code>label_font_size</code> 设置为 14，<code>major_label_font_size</code> 设置为 16，以调整标签的字体大小。然后，使用 <code>add()</code> 方法将国别代码和对应的中文名称添加到地图中。最后，使用 <code>render_to_file()</code> 方法将地图渲染为 SVG 文件。</p><p>通过以上方式，你可以将地图上的国家名称显示为中文。请注意，确保你的环境中已安装支持中文的字体，以便能够正确显示中文文本。</p><h2 id="12-字符串"><a href="#12-字符串" class="headerlink" title="12.字符串"></a>12.字符串</h2><h3 id="1-字符串的一些内置方法"><a href="#1-字符串的一些内置方法" class="headerlink" title="1.字符串的一些内置方法"></a>1.字符串的一些内置方法</h3><p>字符串是 Python 中的内置数据类型之一，它有许多内置方法可以用于对字符串进行各种操作。以下是一些常用的字符串内置方法：</p><ol><li><code>len()</code>: 返回字符串的长度。</li><li><code>lower()</code>: 将字符串转换为小写形式。</li><li><code>upper()</code>: 将字符串转换为大写形式。</li><li><code>capitalize()</code>: 将字符串的第一个字符转换为大写，其他字符转换为小写。</li><li><code>title()</code>: 将字符串中每个单词的首字母转换为大写。</li><li><code>strip()</code>: 去除字符串两端的空格或指定的字符。</li><li><code>split()</code>: 将字符串按指定的分隔符拆分成列表。</li><li><code>join()</code>: 将列表中的字符串元素连接成一个字符串。</li><li><code>replace()</code>: 将字符串中指定的子串替换为新的子串。</li><li><code>startswith()</code>: 检查字符串是否以指定的子串开头。</li><li><code>endswith()</code>: 检查字符串是否以指定的子串结尾。</li><li><code>find()</code>: 查找指定的子串在字符串中的位置。</li><li><code>count()</code>: 统计指定的子串在字符串中出现的次数。</li><li><code>isalpha()</code>: 检查字符串是否只包含字母字符。</li><li><code>isdigit()</code>: 检查字符串是否只包含数字字符。</li></ol><p>这只是一些常用的字符串方法，还有更多方法可供使用。你可以查阅 Python 的官方文档或使用 <code>help()</code> 函数来获取关于字符串方法的详细信息和用法示例。</p><h3 id="２-str-maketrans"><a href="#２-str-maketrans" class="headerlink" title="２.str.maketrans()"></a>２.str.maketrans()</h3><p><code>str.maketrans()</code> 是一个字符串方法，用于创建一个字符映射转换表。它接受两个参数：第一个参数是一个包含要替换的字符的字符串，第二个参数是一个包含相应替换字符的字符串。</p><p><code>str.maketrans(x, y, z)</code> 的语法如下：</p><ul><li><code>x</code>：要替换的字符。</li><li><code>y</code>：替换的目标字符。</li><li><code>z</code>：要删除的字符。</li></ul><p>转换表可以用于 <code>str.translate()</code> 方法来执行字符串的字符替换或删除操作。</p><p>下面是一个示例，演示如何使用 <code>str.maketrans()</code> 和 <code>str.translate()</code> 进行字符替换和删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;Hello, World!&quot;</span><br><br><span class="hljs-comment"># 创建一个转换表，将字母 &quot;o&quot; 替换为数字 &quot;0&quot;</span><br>trans_table = <span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>)<br><br><span class="hljs-comment"># 使用转换表进行字符替换</span><br>new_text = text.translate(trans_table)<br><span class="hljs-built_in">print</span>(new_text)  <span class="hljs-comment"># 输出: Hell0, W0rld!</span><br><br><span class="hljs-comment"># 创建一个转换表，删除所有的元音字母</span><br>trans_table = <span class="hljs-built_in">str</span>.maketrans(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;aeiouAEIOU&quot;</span>)<br><br><span class="hljs-comment"># 使用转换表进行字符删除</span><br>new_text = text.translate(trans_table)<br><span class="hljs-built_in">print</span>(new_text)  <span class="hljs-comment"># 输出: Hll, Wrld!</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先使用 <code>str.maketrans()</code> 创建了两个转换表，分别用于将字母 “o” 替换为数字 “0”，以及删除所有的元音字母。然后，我们使用 <code>str.translate()</code> 方法根据转换表进行字符替换和删除操作。</p><h3 id="３-其他内置处理函数"><a href="#３-其他内置处理函数" class="headerlink" title="３. 其他内置处理函数"></a>３. 其他内置处理函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#-- 内置str处理函数：</span><br>    str1 = <span class="hljs-string">&quot;stringobject&quot;</span><br>    str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title()        <span class="hljs-comment"># 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写</span><br>    str1.ljust(width)                       <span class="hljs-comment"># 获取固定长度，左对齐，右边不够用空格补齐</span><br>    str1.rjust(width)                       <span class="hljs-comment"># 获取固定长度，右对齐，左边不够用空格补齐</span><br>    str1.center(width)                      <span class="hljs-comment"># 获取固定长度，中间对齐，两边不够用空格补齐</span><br>    str1.zfill(width)                       <span class="hljs-comment"># 获取固定长度，右对齐，左边不足用0补齐</span><br>    str1.find(<span class="hljs-string">&#x27;t&#x27;</span>,start,end)                <span class="hljs-comment"># 查找字符串，可以指定起始及结束位置搜索</span><br>    str1.rfind(<span class="hljs-string">&#x27;t&#x27;</span>)                         <span class="hljs-comment"># 从右边开始查找字符串</span><br>    str1.count(<span class="hljs-string">&#x27;t&#x27;</span>)                         <span class="hljs-comment"># 查找字符串出现的次数</span><br>    <span class="hljs-comment">#上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1</span><br>    str1.replace(<span class="hljs-string">&#x27;old&#x27;</span>,<span class="hljs-string">&#x27;new&#x27;</span>)               <span class="hljs-comment"># 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new</span><br>    str1.strip();                           <span class="hljs-comment"># 默认删除空白符</span><br>    str1.strip(<span class="hljs-string">&#x27;d&#x27;</span>);                        <span class="hljs-comment"># 删除str1字符串中开头、结尾处，位于 d 删除序列的字符</span><br>    str1.lstrip();<br>    str1.lstrip(<span class="hljs-string">&#x27;d&#x27;</span>);                       <span class="hljs-comment"># 删除str1字符串中开头处，位于 d 删除序列的字符</span><br>    str1.rstrip();<br>    str1.rstrip(<span class="hljs-string">&#x27;d&#x27;</span>)                        <span class="hljs-comment"># 删除str1字符串中结尾处，位于 d 删除序列的字符</span><br>    str1.startswith(<span class="hljs-string">&#x27;start&#x27;</span>)                <span class="hljs-comment"># 是否以start开头</span><br>    str1.endswith(<span class="hljs-string">&#x27;end&#x27;</span>)                    <span class="hljs-comment"># 是否以end结尾</span><br>    str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper()      <span class="hljs-comment"># 判断字符串是否全为字符、数字、小写、大写</span><br></code></pre></td></tr></table></figure><h3 id="4-字符串的格式化"><a href="#4-字符串的格式化" class="headerlink" title="4.字符串的格式化"></a>4.字符串的格式化</h3><p>基于C语言的’print’模型，并且在大多数的现有的语言中使用。通用结构：%[(name)][flag][width].[precision]typecode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;this is %d %s bird&quot;</span> %(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;dead&#x27;</span>)<span class="hljs-comment">#一般的格式化表达式</span><br><span class="hljs-string">&quot;%s---%s---%s&quot;</span> %(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment">#字条串输出：&#x27;42---3.14---[1, 2, 3]&#x27;</span><br> <span class="hljs-comment"># 对齐方式及填充：&quot;1234...  1234...1234  ...001234&quot;</span><br><span class="hljs-string">&quot;%d...%6d...%-6d...%06d&quot;</span> % (<span class="hljs-number">1234</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">1234</span>, <span class="hljs-number">1234</span>)<br>x = <span class="hljs-number">1.23456789</span><br><span class="hljs-string">&quot;%e | %f | %g&quot;</span> % (x, x, x)<span class="hljs-comment"># 对齐方式：&quot;1.234568e+00 | 1.234568 | 1.23457&quot;</span><br><span class="hljs-string">&quot;%6.2f*%-6.2f*%06.2f*%+6.2f&quot;</span> % (x, x, x, x) <span class="hljs-comment"># 对齐方式：&#x27;  1.23*1.23  *001.23* +1.23&#x27;</span><br><span class="hljs-string">&quot;%(name1)d---%(name2)s&quot;</span> % &#123;<span class="hljs-string">&quot;name1&quot;</span>:<span class="hljs-number">23</span>, <span class="hljs-string">&quot;name2&quot;</span>:<span class="hljs-string">&quot;value2&quot;</span>&#125; <span class="hljs-comment"># 基于字典的格式化表达式</span><br><span class="hljs-string">&quot;%(name)s is %(age)d&quot;</span> % <span class="hljs-built_in">vars</span>() <span class="hljs-comment"># vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量</span><br></code></pre></td></tr></table></figure><p>字体串格式化调用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&#123;0&#125;, &#123;1&#125; and &#123;2&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-string">&#x27;ham&#x27;</span>, <span class="hljs-string">&#x27;eggs&#x27;</span>)            <span class="hljs-comment"># 基于位置的调用</span><br><span class="hljs-string">&quot;&#123;motto&#125; and &#123;pork&#125;&quot;</span>.<span class="hljs-built_in">format</span>(motto = <span class="hljs-string">&#x27;spam&#x27;</span>, pork = <span class="hljs-string">&#x27;ham&#x27;</span>)   <span class="hljs-comment"># 基于Key的调用</span><br><span class="hljs-string">&quot;&#123;motto&#125; and &#123;0&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;ham&#x27;</span>, motto = <span class="hljs-string">&#x27;spam&#x27;</span>)             <span class="hljs-comment"># 混合调用</span><br><span class="hljs-comment"># 添加键 属性 偏移量 (import sys)</span><br><span class="hljs-string">&quot;my &#123;1[spam]&#125; runs &#123;0.platform&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sys, &#123;<span class="hljs-string">&#x27;spam&#x27;</span>:<span class="hljs-string">&#x27;laptop&#x27;</span>&#125;)  <span class="hljs-comment"># 基于位置的键和属性</span><br><span class="hljs-comment"># 基于Key的键和属性</span><br><span class="hljs-string">&quot;&#123;config[spam]&#125; &#123;sys.platform&#125;&quot;</span>.<span class="hljs-built_in">format</span>(sys = sys, config = &#123;<span class="hljs-string">&#x27;spam&#x27;</span>:<span class="hljs-string">&#x27;laptop&#x27;</span>&#125;) <br><span class="hljs-string">&quot;first = &#123;0[0]&#125;, second = &#123;0[1]&#125;&quot;</span>.<span class="hljs-built_in">format</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]) <span class="hljs-comment"># 基于位置的偏移量</span><br><span class="hljs-comment"># 具体格式化</span><br><span class="hljs-comment"># 输出&#x27;3.141590e+00, 3.142e+00, 3.14159&#x27;</span><br><span class="hljs-string">&quot;&#123;0:e&#125;, &#123;1:.3e&#125;, &#123;2:g&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.14159</span>, <span class="hljs-number">3.14159</span>, <span class="hljs-number">3.14159</span>) <br><span class="hljs-string">&quot;&#123;fieldname:format_spec&#125;&quot;</span>.<span class="hljs-built_in">format</span>(......)<br></code></pre></td></tr></table></figure><p>说明:</p><blockquote><p>fieldname是指定参数的一个数字或关键字, 后边可跟可选的”.name”或”[index]”成分引用<br>format_spec ::&#x3D;  [[fill]align][sign][#][0][width][,][.precision][type]<br>fill        ::&#x3D;  <any character>              #填充字符<br>align       ::&#x3D;  “&lt;” | “&gt;” | “&#x3D;” | “^”        #对齐方式<br>sign        ::&#x3D;  “+” | “-“ | “ “              #符号说明<br>width       ::&#x3D;  integer                      #字符串宽度<br>precision   ::&#x3D;  integer                      #浮点数精度<br>type        ::&#x3D;  “b” | “c” | “d” | “e” | “E” | “f” | “F” | “g” | “G” | “n” | “o” | “s” | “x” | “X” | “%”</p></blockquote><p>例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;=&#123;0:10&#125; = &#123;1:10&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-number">123.456</span>)    <span class="hljs-comment"># 输出&#x27;=spam       =    123.456&#x27;</span><br><span class="hljs-string">&#x27;=&#123;0:&gt;10&#125;=&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;test&#x27;</span>)                    <span class="hljs-comment"># 输出&#x27;=      test=&#x27;</span><br><span class="hljs-string">&#x27;=&#123;0:&lt;10&#125;=&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;test&#x27;</span>)                    <span class="hljs-comment"># 输出&#x27;=test      =&#x27;</span><br><span class="hljs-string">&#x27;=&#123;0:^10&#125;=&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;test&#x27;</span>)                    <span class="hljs-comment"># 输出&#x27;=   test   =&#x27;</span><br><span class="hljs-string">&#x27;&#123;0:X&#125;, &#123;1:o&#125;, &#123;2:b&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)   <span class="hljs-comment"># 输出&#x27;FF, 377, 11111111&#x27;</span><br><span class="hljs-string">&#x27;My name is &#123;0:&#123;1&#125;&#125;.&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;Fred&#x27;</span>, <span class="hljs-number">8</span>)       <span class="hljs-comment"># 输出&#x27;My name is Fred    .&#x27;  动态指定参数</span><br></code></pre></td></tr></table></figure><h3 id="4-textwrap"><a href="#4-textwrap" class="headerlink" title="4.textwrap"></a>4.textwrap</h3><p><code>textwrap</code> 模块是 Python 标准库中的一个模块，它提供了一些用于格式化和包装文本的函数和类。主要用于将长文本按照指定的宽度进行自动换行和格式化，以适应给定的输出区域。</p><p>以下是一些常用的 <code>textwrap</code> 模块函数和类：</p><ol><li><code>textwrap.wrap(text, width)</code>：将文本按照指定的宽度进行分割，返回一个列表，每个元素表示一行文本。</li><li><code>textwrap.fill(text, width)</code>：将文本按照指定的宽度进行自动换行，并返回一个格式化后的文本字符串。</li><li><code>textwrap.shorten(text, width, placeholder=&#39;...&#39;)</code>：将文本缩短至指定的宽度，超出部分用指定的占位符替代。</li><li><code>textwrap.dedent(text)</code>：去除文本块中的公共缩进。</li><li><code>textwrap.indent(text, prefix)</code>：在文本块的每一行前添加指定的前缀。</li><li><code>textwrap.TextWrapper</code> 类：提供了更多高级的文本包装和格式化选项，可以定制换行、缩进、对齐等参数。</li></ol><p>以下是一个示例，展示了如何使用 <code>textwrap</code> 模块来格式化文本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> textwrap<br><br>text = <span class="hljs-string">&quot;This is a long piece of text that needs to be wrapped properly to fit within the specified width.&quot;</span><br><br><span class="hljs-comment"># 使用 textwrap.wrap 进行文本分割</span><br>wrapped_lines = textwrap.wrap(text, width=<span class="hljs-number">30</span>)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> wrapped_lines:<br>    <span class="hljs-built_in">print</span>(line)<br><br><span class="hljs-comment"># 使用 textwrap.fill 进行文本换行和格式化</span><br>formatted_text = textwrap.fill(text, width=<span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(formatted_text)<br></code></pre></td></tr></table></figure><p>你可以根据需要在输出中查看不同的格式化结果。请注意，<code>textwrap</code> 模块提供了更多的选项和功能，可以根据具体需求进行定制。</p><h2 id="13-列表的一些内置方法"><a href="#13-列表的一些内置方法" class="headerlink" title="13.列表的一些内置方法"></a>13.列表的一些内置方法</h2><p>列表是 Python 中的内置数据类型之一，它提供了丰富的内置方法来操作和处理列表。以下是一些常用的列表内置方法：</p><ol><li><code>append()</code>: 在列表末尾添加一个元素。</li><li><code>extend()</code>: 将一个列表的元素追加到另一个列表中。</li><li><code>insert()</code>: 在指定位置插入一个元素。</li><li><code>remove()</code>: 移除列表中指定的元素。</li><li><code>pop()</code>: 移除并返回列表中指定位置的元素。</li><li><code>index()</code>: 返回指定元素在列表中的索引位置。</li><li><code>count()</code>: 统计指定元素在列表中出现的次数。</li><li><code>sort()</code>: 对列表进行排序。</li><li><code>reverse()</code>: 反转列表中的元素顺序。</li><li><code>copy()</code>: 创建一个列表的副本。</li><li><code>clear()</code>: 清空列表中的所有元素。</li><li><code>len()</code>: 返回列表的长度。</li></ol><p>这只是一些常用的列表方法，还有更多方法可供使用。你可以查阅 Python 的官方文档或使用 <code>help()</code> 函数来获取关于列表方法的详细信息和用法示例。</p><h2 id="14-列表切片"><a href="#14-列表切片" class="headerlink" title="14.列表切片"></a>14.列表切片</h2><p>列表切片是一种常用的操作，可以通过切片来获取列表中的部分元素，创建新的列表或对原列表进行修改。以下是一些常见的列表切片的内置方法：</p><ol><li>切片操作：使用冒号（<code>:</code>）来表示切片操作，可以指定起始位置、终止位置和步长。示例：<code>list[start:stop:step]</code>。</li><li><code>list[start:stop]</code>：获取从起始位置到终止位置的元素（不包括终止位置）。</li><li><code>list[start:]</code>：获取从起始位置到列表末尾的元素。</li><li><code>list[:stop]</code>：获取从列表开头到终止位置的元素（不包括终止位置）。</li><li><code>list[:]</code>：获取整个列表的副本。</li><li><code>list[start:stop:step]</code>：指定步长来获取指定间隔的元素。</li></ol><p>除了切片操作，还有一些其他常见的列表方法：</p><ol><li><code>list.append(item)</code>：将元素添加到列表的末尾。</li><li><code>list.extend(iterable)</code>：将可迭代对象中的元素添加到列表的末尾。</li><li><code>list.insert(index, item)</code>：在指定索引位置插入元素。</li><li><code>list.remove(item)</code>：从列表中删除指定的元素。</li><li><code>list.pop(index)</code>：删除并返回指定索引位置的元素。</li><li><code>list.index(item)</code>：返回指定元素在列表中的索引。</li><li><code>list.count(item)</code>：返回指定元素在列表中出现的次数。</li><li><code>list.sort()</code>：对列表进行排序。</li><li><code>list.reverse()</code>：反转列表中的元素顺序。</li></ol><h2 id="15-使用pyecharts画中国、省、市地图"><a href="#15-使用pyecharts画中国、省、市地图" class="headerlink" title="15.使用pyecharts画中国、省、市地图"></a>15.使用pyecharts画中国、省、市地图</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! -*- coding:utf-8 -*-</span><br><br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment">#设置两组数据列表，一组为省份，一组为城市</span><br>province = <span class="hljs-string">&#x27;安徽省,北京市,重庆市,福建省,甘肃省,广东省,广西壮族自治区,贵州省,海南省,河北省,黑龙江省,河南省,湖北省,湖南省,内蒙古自治区,江苏省,江西省,吉林省,辽宁省,宁夏回族自治区,青海省,山东省,山西省,陕西省,上海市,四川省,天津市,西藏自治区,新疆维吾尔自治区,云南省,浙江省,台湾省&#x27;</span><br>province = province.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><br><span class="hljs-comment"># print(province)</span><br><span class="hljs-comment">#将省份转换为[[&#x27;省1&#x27;,值1],[&#x27;省2&#x27;,值2]....]这种格式，并存储到province_data列表中</span><br>province_data = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> province:<br>    temp = []<br>    temp.append(x)<br>    temp.append(random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>))<br>    province_data.append(temp)<br><br><span class="hljs-comment">#另一种幅值方法</span><br>cities_data = [<br>    [<span class="hljs-string">&#x27;福州市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;厦门市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;泉州市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;莆田市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;漳州市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;龙岩市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;三明市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;南平市&#x27;</span>,<span class="hljs-number">0</span>],<br>    [<span class="hljs-string">&#x27;宁德市&#x27;</span>,<span class="hljs-number">0</span>]<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_filling</span>(<span class="hljs-params">array</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;给数据数据填充随机数&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>            i[<span class="hljs-number">1</span>] = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">#调用data_filling函数给cities_data赋随机值</span><br>data_filling(cities_data)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;生成一个中国地图&quot;&quot;&quot;</span><br>    (<br>        Map(init_opts=opts.InitOpts(height=<span class="hljs-string">&quot;860px&quot;</span>, width=<span class="hljs-string">&quot;1800px&quot;</span>))<br>        .add(<br>            series_name=<span class="hljs-string">&#x27;全国&#x27;</span>,<br>            data_pair=province_data,<br>            maptype=<span class="hljs-string">&quot;china&quot;</span>,<br>            <span class="hljs-comment">#默认是否选中</span><br>            <span class="hljs-comment"># is_selected=False,</span><br>            <span class="hljs-comment"># 是否启用鼠标滚轮缩放和拖动平移，默认为True</span><br>            is_roam=<span class="hljs-literal">True</span>,<br>            <span class="hljs-comment"># 是否显示图形标记，默认为True</span><br>            is_map_symbol_show=<span class="hljs-literal">False</span>,<br>            <span class="hljs-comment"># 局部关闭标签显示</span><br>            label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">False</span>),<br>            <span class="hljs-comment"># 图元样式配置</span><br>            <span class="hljs-comment"># itemstyle_opts=&#123;</span><br>            <span class="hljs-comment">#     # 常规显示</span><br>            <span class="hljs-comment">#     &quot;normal&quot;: &#123;&quot;areaColor&quot;: &quot;white&quot;, &quot;borderColor&quot;: &quot;red&quot;&#125;,</span><br>            <span class="hljs-comment">#     # 强调颜色</span><br>            <span class="hljs-comment">#     &quot;emphasis&quot;: &#123;&quot;areaColor&quot;: &quot;rgba(0,0,0,1)&quot;&#125;</span><br>            <span class="hljs-comment"># &#125;</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&#x27;福建省&#x27;</span>,<br>            data_pair=cities_data,<br>            maptype=<span class="hljs-string">&quot;china-cities&quot;</span>,<br>            <span class="hljs-comment">#默认是否选中</span><br>            <span class="hljs-comment"># is_selected=False</span><br>        )<br>        <span class="hljs-comment">#设置标题</span><br>        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="hljs-string">&#x27;中国地图&#x27;</span>),<br>                         <span class="hljs-comment">#设置分段显示</span><br>                         visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>,is_piecewise=<span class="hljs-literal">False</span>)<br>                         )<br>        <span class="hljs-comment"># 系列配置项</span><br>        <span class="hljs-comment"># 关闭标签名称显示</span><br>        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">False</span>))<br>        <span class="hljs-comment">#生成本地html文件</span><br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br>create_china_map()<br></code></pre></td></tr></table></figure><p>其中maptype可选择：</p><ul><li><code>china</code>：全国地图，最小单元的省份</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081044518.webp"></p><ul><li><code>省份名称</code>：显示指定省份地图（如福建）显示的为福建地图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081044082.webp"></p><ul><li><code>市名</code>：显示的为指定市地图，如（宁德）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081048134.webp"></p><ul><li><code>china-cities</code>：显示的为中国地图，按城市划分</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081044833.webp"></p><ul><li><code>worrld</code>：世界地图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081046154.webp"></p><h2 id="16-字典"><a href="#16-字典" class="headerlink" title="16. 字典"></a>16. 字典</h2><h3 id="1-对字典根据关键字进行排序"><a href="#1-对字典根据关键字进行排序" class="headerlink" title="1.对字典根据关键字进行排序"></a>1.对字典根据关键字进行排序</h3><p>要对字典列表根据关键字进行排序，可以使用 <code>itemgetter()</code> 函数配合 <code>sorted()</code> 函数来实现。</p><p><code>itemgetter()</code> 函数可以用于获取字典中的特定键的值，它接受一个键作为参数，并返回一个函数，该函数用于获取给定键的值。<code>sorted()</code> 函数可以接受一个可迭代对象和一个关键字参数 <code>key</code>，用于指定排序的依据。</p><p>下面是一个示例，演示如何对字典列表根据关键字进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br><br><span class="hljs-comment"># 假设有一个字典列表</span><br>data = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;]<br><br><span class="hljs-comment"># 按照 &#x27;name&#x27; 关键字进行排序</span><br>sorted_data = <span class="hljs-built_in">sorted</span>(data, key=itemgetter(<span class="hljs-string">&#x27;name&#x27;</span>))<br><span class="hljs-built_in">print</span>(sorted_data)<br><br><span class="hljs-comment"># 按照 &#x27;age&#x27; 关键字进行排序</span><br>sorted_data = <span class="hljs-built_in">sorted</span>(data, key=itemgetter(<span class="hljs-string">&#x27;age&#x27;</span>))<br><span class="hljs-built_in">print</span>(sorted_data)<br></code></pre></td></tr></table></figure><p>可以加上<code>resverse=True</code>实现倒序</p><h3 id="2-常用字典常量和操作"><a href="#2-常用字典常量和操作" class="headerlink" title="2. 常用字典常量和操作"></a>2. 常用字典常量和操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">D = &#123;&#125;<br>D = &#123;<span class="hljs-string">&#x27;spam&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;tol&#x27;</span>:&#123;<span class="hljs-string">&#x27;ham&#x27;</span>:<span class="hljs-number">1</span>&#125;&#125;                   <span class="hljs-comment"># 嵌套字典</span><br>D = <span class="hljs-built_in">dict</span>.fromkeys([<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], <span class="hljs-number">8</span>)                  <span class="hljs-comment"># &#123;&#x27;s&#x27;: 8, &#x27;d&#x27;: 8&#125;</span><br>D = <span class="hljs-built_in">dict</span>(name = <span class="hljs-string">&#x27;tom&#x27;</span>, age = <span class="hljs-number">12</span>)                  <span class="hljs-comment"># &#123;&#x27;age&#x27;: 12, &#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br>D = <span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tom&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">12</span>)])          <span class="hljs-comment"># &#123;&#x27;age&#x27;: 12, &#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br>D = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>], [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>]))       <span class="hljs-comment"># &#123;&#x27;age&#x27;: 12, &#x27;name&#x27;: &#x27;tom&#x27;&#125;</span><br>D.keys(); D.values(); D.items()                   <span class="hljs-comment"># 字典键、值以及键值对</span><br>D.get(key, default)                               <span class="hljs-comment"># get函数</span><br>D.update(D_other)                                 <span class="hljs-comment"># 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据</span><br>D.pop(key, [D])                                   <span class="hljs-comment"># 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常</span><br>D.popitem()                                       <span class="hljs-comment"># pop字典中随机的一项（一个键值对）</span><br>D.setdefault(k[, d])                              <span class="hljs-comment"># 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。</span><br><span class="hljs-keyword">del</span> D                                             <span class="hljs-comment"># 删除字典</span><br><span class="hljs-keyword">del</span> D[<span class="hljs-string">&#x27;key&#x27;</span>]                                      <span class="hljs-comment"># 删除字典的某一项</span><br><span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> D:   <span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> D:                   <span class="hljs-comment"># 测试字典键是否存在</span><br><span class="hljs-comment"># 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象</span><br><span class="hljs-comment"># 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。</span><br><span class="hljs-comment"># 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象</span><br>D[(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)] = <span class="hljs-number">2</span>      <br></code></pre></td></tr></table></figure><p>字典解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">D = &#123;k:<span class="hljs-number">8</span> <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]&#125;                     <span class="hljs-comment"># &#123;&#x27;s&#x27;: 8, &#x27;d&#x27;: 8&#125;</span><br>D = &#123;k:v <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>([<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>], [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">12</span>])&#125;       <span class="hljs-comment"># &#123;&#x27;age&#x27;: 12, &#x27;name&#x27;: tom&#125;</span><br></code></pre></td></tr></table></figure><p>字典的特殊方法__missing__：当查找找不到key时，会执行该方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dict</span>(<span class="hljs-title class_ inherited__">dict</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__missing__</span>(<span class="hljs-params">self, key</span>):<br>        self[key] = []<br>        <span class="hljs-keyword">return</span> self[key]<br>dct = <span class="hljs-built_in">dict</span>()<br>dct[<span class="hljs-string">&quot;foo&quot;</span>].append(<span class="hljs-number">1</span>)    <span class="hljs-comment"># 这有点类似于collections.defalutdict</span><br>dct[<span class="hljs-string">&quot;foo&quot;</span>]              <span class="hljs-comment"># [1]</span><br></code></pre></td></tr></table></figure><h2 id="17-打印输出文字设置颜色"><a href="#17-打印输出文字设置颜色" class="headerlink" title="17.打印输出文字设置颜色"></a>17.打印输出文字设置颜色</h2><p>在标准输出中，Python 没有直接支持设置文本颜色的功能。然而，你可以通过使用 ANSI 转义序列来实现在终端中设置文本颜色。</p><p>下面是一个示例，展示了如何使用 ANSI 转义序列设置输出文本的颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ANSI 转义序列设置文本颜色</span><br>BLACK = <span class="hljs-string">&quot;\033[0;30m&quot;</span><br>RED = <span class="hljs-string">&quot;\033[0;31m&quot;</span><br>GREEN = <span class="hljs-string">&quot;\033[0;32m&quot;</span><br>YELLOW = <span class="hljs-string">&quot;\033[0;33m&quot;</span><br>BLUE = <span class="hljs-string">&quot;\033[0;34m&quot;</span><br>MAGENTA = <span class="hljs-string">&quot;\033[0;35m&quot;</span><br>CYAN = <span class="hljs-string">&quot;\033[0;36m&quot;</span><br>WHITE = <span class="hljs-string">&quot;\033[0;37m&quot;</span><br>RESET = <span class="hljs-string">&quot;\033[0m&quot;</span><br><br><span class="hljs-comment"># 示例输出</span><br><span class="hljs-built_in">print</span>(RED + <span class="hljs-string">&quot;这是红色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(GREEN + <span class="hljs-string">&quot;这是绿色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(YELLOW + <span class="hljs-string">&quot;这是黄色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(BLUE + <span class="hljs-string">&quot;这是蓝色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(MAGENTA + <span class="hljs-string">&quot;这是品红色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(CYAN + <span class="hljs-string">&quot;这是青色文本&quot;</span> + RESET)<br><span class="hljs-built_in">print</span>(WHITE + <span class="hljs-string">&quot;这是白色文本&quot;</span> + RESET)<br></code></pre></td></tr></table></figure><p>上述代码使用 ANSI 转义序列设置了不同颜色的文本，并通过 <code>print</code> 函数打印到终端。输出结果将根据设置的颜色显示不同的文本颜色。要恢复默认的文本颜色，可以使用 <code>RESET</code> 序列。</p><p>请注意，ANSI 转义序列的可用性和效果可能因终端类型和操作系统而异。在某些情况下，它可能无法在某些终端或操作系统上正常工作。</p><h2 id="18-变量作用域"><a href="#18-变量作用域" class="headerlink" title="18.变量作用域"></a>18.变量作用域</h2><p>变量作用域是指在程序中定义的变量所能被访问的范围或可见性。它决定了变量在程序的哪些部分可以被引用或修改。</p><p>在Python中，有以下几种变量作用域：</p><ol><li>全局作用域（Global Scope）：在整个程序中都可以访问的变量称为全局变量，它在程序的任何地方都是可见的。</li><li>局部作用域（Local Scope）：在函数内部定义的变量称为局部变量，它只能在函数内部被访问。</li><li>嵌套作用域（Enclosing Scope）：在嵌套的函数中，内部函数可以访问外部函数中定义的变量。</li></ol><p>变量的作用域规则如下：</p><ul><li>在函数内部，可以访问该函数内部定义的变量、外部函数中定义的变量和全局变量。</li><li>在函数外部，只能访问全局变量。</li><li>如果在函数内部使用了与外部作用域相同名称的变量，会创建一个新的局部变量，覆盖外部作用域中的变量。</li><li>在嵌套函数中，内部函数可以访问外部函数的变量，但不能修改它们（除非使用 <code>nonlocal</code> 关键字）。</li></ul><p>了解变量作用域对于正确理解和使用变量非常重要，它可以帮助避免命名冲突、提高代码的可读性和可维护性。</p><h2 id="19-lambda创建匿名函数"><a href="#19-lambda创建匿名函数" class="headerlink" title="19.lambda创建匿名函数"></a>19.lambda创建匿名函数</h2><p>使用 lambda 表达式可以创建匿名函数。Lambda 表达式是一种快速定义简单函数的方式，它可以接受任意数量的参数，并返回一个表达式的结果。</p><p>下面是使用 lambda 表达式创建函数的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个接受两个参数并返回它们之和的 lambda 函数</span><br>addition = <span class="hljs-keyword">lambda</span> x, y: x + y<br><br><span class="hljs-comment"># 调用 lambda 函数并打印结果</span><br><span class="hljs-built_in">print</span>(addition(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 输出: 8</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>addition</code> 是一个 lambda 函数，它接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。可以直接调用 <code>addition(3, 5)</code> 来执行 lambda 函数，并打印结果。</p><p>Lambda 表达式通常用于需要定义简单函数且不需要命名的场景。它可以在需要函数的地方直接使用，也可以作为参数传递给其他函数。需要注意的是，lambda 表达式不能包含复杂的语句块，只能包含一个表达式，并且返回该表达式的结果。</p><h2 id="20-tkinter画图形"><a href="#20-tkinter画图形" class="headerlink" title="20.tkinter画图形"></a>20.tkinter画图形</h2><p><code>tkinter</code> 是 Python 的标准图形用户界面（GUI）库，它提供了一组用于创建图形界面的工具和组件。<code>tkinter</code> 是 Python 的内置库，因此在安装 Python 后，无需额外安装即可使用它。</p><p><code>tkinter</code> 基于 Tcl&#x2F;Tk 工具包，它提供了一种简单和直观的方式来创建窗口、按钮、文本框、标签等各种图形界面组件，并通过编写事件处理程序来响应用户的交互操作。</p><p>通过 <code>tkinter</code>，您可以创建各种类型的桌面应用程序，包括简单的工具、图形化配置界面、数据可视化应用等。</p><p>以下是一个简单的 <code>tkinter</code> 示例，创建一个窗口并显示一个标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><br><span class="hljs-comment"># 创建主窗口</span><br>window = tk.Tk()<br><br><span class="hljs-comment"># 创建标签</span><br>label = tk.Label(window, text=<span class="hljs-string">&quot;Hello, tkinter!&quot;</span>)<br>label.pack()<br><br><span class="hljs-comment"># 运行主循环</span><br>window.mainloop()<br></code></pre></td></tr></table></figure><p>这段代码创建了一个主窗口，并在窗口中显示了一个标签。<code>Tk()</code> 函数用于创建主窗口对象，<code>Label</code> 函数用于创建标签对象，<code>pack()</code> 方法用于将标签放置到主窗口中，<code>mainloop()</code> 方法用于启动主循环，使窗口保持显示状态。</p><p>下面这个例子是画一个圆形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><br><span class="hljs-comment"># 创建主窗口</span><br>window = tk.Tk()<br><br><span class="hljs-comment"># 创建画布</span><br>canvas = tk.Canvas(window, width=<span class="hljs-number">400</span>, height=<span class="hljs-number">400</span>)<br>canvas.pack()<br><br><span class="hljs-comment"># 绘制圆形</span><br>circle = canvas.create_oval(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>, fill=<span class="hljs-string">&quot;red&quot;</span>)<br><br><span class="hljs-comment"># 运行主循环</span><br>window.mainloop()<br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个主窗口，并在窗口中创建了一个画布。然后，使用 <code>create_oval()</code> 方法在画布上绘制了一个圆形。<code>create_oval()</code> 方法接受四个参数，分别是圆形的左上角和右下角坐标。我们将圆形的左上角坐标设为 (100, 100)，右下角坐标设为 (300, 300)，这样圆形的直径就是 200 像素。最后，我们使用 <code>fill</code> 参数指定了圆形的填充颜色。</p><p>您可以根据需要调整圆形的位置、大小和颜色。通过 <code>Canvas</code> 组件的其他方法和属性，还可以绘制线条、矩形、多边形等其他图形，并实现更复杂的绘图效果。</p><h2 id="21-map-函数的使用"><a href="#21-map-函数的使用" class="headerlink" title="21.map()函数的使用"></a>21.map()函数的使用</h2><p><code>map()</code>函数是Python中的一个内置函数，用于将一个函数应用于一个或多个可迭代对象（例如列表、元组）的对应元素上，返回一个迭代器。</p><p><code>map()</code>函数的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(function, iterable1, iterable2, ...)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>function</code>是一个函数，可以是内置函数、自定义函数或匿名函数（lambda表达式）。</li><li><code>iterable1, iterable2, ...</code>是一个或多个可迭代对象，可以是列表、元组等。</li></ul><p><code>map()</code>函数将<code>function</code>应用于每个<code>iterable</code>中对应位置的元素，并返回一个迭代器，其中包含了应用了函数后的结果。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用匿名函数对两个列表的元素进行相加</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>result = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x + y, a, b)<br><span class="hljs-comment"># 输出结果为迭代器对象：&lt;map object at 0x000001&gt;</span><br><span class="hljs-built_in">print</span>(result)<br><br><span class="hljs-comment"># 将迭代器转换为列表</span><br>result_list = <span class="hljs-built_in">list</span>(result)<br><span class="hljs-comment"># 输出结果为列表：[5, 7, 9]</span><br><span class="hljs-built_in">print</span>(result_list)<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>map()</code>函数将匿名函数 <code>lambda x, y: x + y</code> 应用于列表 <code>a</code> 和 <code>b</code> 的对应元素上，返回一个迭代器。通过将迭代器转换为列表，我们可以获取应用函数后的结果列表。在本例中，结果列表为 <code>[5, 7, 9]</code>，即对应位置元素相加的结果。</p><h2 id="22-旋转列表"><a href="#22-旋转列表" class="headerlink" title="22.旋转列表"></a>22.旋转列表</h2><p><code>deque.rotate</code> 是 <code>collections</code> 模块中 <code>deque</code> 类提供的一个方法，用于循环移动双向队列中的元素。</p><p>语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">deque.rotate(n)<br></code></pre></td></tr></table></figure><p>其中，<code>deque</code> 是一个双向队列对象，<code>n</code> 是要旋转的元素数量。当 <code>n</code> 为正数时，元素向右移动；当 <code>n</code> 为负数时，元素向左移动。</p><p>具体操作如下：</p><ul><li>当 <code>n</code> 的绝对值小于等于队列长度时，元素按照指定的数量进行循环移动。</li><li>当 <code>n</code> 的绝对值大于队列长度时，元素会循环移动多个周期，效果与取模运算类似。</li></ul><p>下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>queue = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>queue.rotate(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 向右循环移动2个元素</span><br><br><span class="hljs-built_in">print</span>(queue)  <span class="hljs-comment"># 输出: deque([4, 5, 1, 2, 3])</span><br></code></pre></td></tr></table></figure><p>在上述例子中，初始队列为 <code>[1, 2, 3, 4, 5]</code>，通过 <code>queue.rotate(2)</code> 将队列中的元素向右循环移动了 2 个位置，得到的结果为 <code>[4, 5, 1, 2, 3]</code>。</p><h2 id="23-if-name-x3D-x3D-‘main‘"><a href="#23-if-name-x3D-x3D-‘main‘" class="headerlink" title="23.if name &#x3D;&#x3D; ‘main‘"></a>23.if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘</h2><p><code>if __name__ == &#39;__main__&#39;:</code> 是 Python 中常用的条件语句，用于判断当前模块是否作为主程序运行。</p><p>当一个 Python 文件被直接运行时，即通过命令行或脚本执行时，<code>__name__</code> 属性的值会被设置为 <code>&#39;__main__&#39;</code>。而当一个模块被导入到其他文件中时，<code>__name__</code> 属性的值为模块的名称。</p><p>因此，<code>if __name__ == &#39;__main__&#39;:</code> 的作用是用于判断当前模块是否作为主程序运行。当条件成立时，即当前模块作为主程序运行时，可以执行一些特定的代码块，通常用于测试、调试或执行特定的任务。</p><p>例如，假设有一个名为 <code>example.py</code> 的模块文件，其中包含如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, foo!&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, bar!&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    foo()<br>    bar()<br></code></pre></td></tr></table></figure><p>当直接运行 <code>example.py</code> 文件时，输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">Hello, foo!<br>Hello, bar!<br></code></pre></td></tr></table></figure><p>而当该模块被导入到其他文件中时，<code>foo()</code> 和 <code>bar()</code> 函数不会自动执行，因为 <code>__name__</code> 属性的值不为 <code>&#39;__main__&#39;</code>。</p><h2 id="24-进制转换"><a href="#24-进制转换" class="headerlink" title="24.进制转换"></a>24.进制转换</h2><p>二进制（Binary）、八进制（Octal）、十进制（Decimal）和十六进制（Hexadecimal）是不同的数制系统，用于表示数值。</p><ul><li>二进制：使用 0 和 1 表示数字，以 <code>0b</code> 或 <code>0B</code> 前缀开头，如 0b010101。在计算机中，二进制是最基本的数制，因为计算机以位（0 和 1）表示信息。在 Python 中，可以使用 <code>0b</code> 或 <code>0B</code> 前缀来表示二进制数，例如 <code>0b10</code> 表示二进制的 10，其十进制值为 2。</li><li>八进制：使用 0-7 的数字表示，以 <code>0o</code> 或 <code>0O</code> 前缀开头，如 0o1234567。八进制是以 3 位二进制为一个单位进行表示，每个八进制位对应于 3 个二进制位。在 Python 中，可以使用 <code>0o</code> 或 <code>0O</code> 前缀来表示八进制数，例如 <code>0o10</code> 表示八进制的 10，其十进制值为 8。</li><li>十进制：使用 0-9 的数字表示，不需要前缀，如 0123456789。十进制是我们常用的十个数字的表示方式，是我们日常生活中最常见的数值表示法。</li><li>十六进制：使用 0-9 和 A-F 的数字和字母表示，以 <code>0x</code> 或 <code>0X</code> 前缀开头，如 0x123456789ABCDEF。十六进制是以 4 位二进制为一个单位进行表示，每个十六进制位对应于 4 个二进制位。在 Python 中，可以使用 <code>0x</code> 或 <code>0X</code> 前缀来表示十六进制数，例如 <code>0x10</code> 表示十六进制的 10，其十进制值为 16。</li></ul><p>不同进制的数值表示法在计算机科学和编程中具有不同的应用场景。例如，二进制常用于处理位运算和存储二进制数据，八进制和十六进制常用于表示内存地址或颜色值。</p><p>Python 提供了内置函数 <code>bin()</code>、<code>oct()</code>、<code>int()</code> 和 <code>hex()</code> 来在不同进制之间进行转换。</p><p>以下是一些示例代码片段，展示了在不同进制之间进行转换的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 十进制转二进制</span><br>decimal = <span class="hljs-number">10</span><br>binary = <span class="hljs-built_in">bin</span>(decimal)<br><span class="hljs-built_in">print</span>(binary)  <span class="hljs-comment"># 输出: 0b1010</span><br><br><span class="hljs-comment"># 十进制转八进制</span><br>decimal = <span class="hljs-number">10</span><br>octal = <span class="hljs-built_in">oct</span>(decimal)<br><span class="hljs-built_in">print</span>(octal)  <span class="hljs-comment"># 输出: 0o12</span><br><br><span class="hljs-comment"># 十进制转十六进制</span><br>decimal = <span class="hljs-number">16</span><br>hexadecimal = <span class="hljs-built_in">hex</span>(decimal)<br><span class="hljs-built_in">print</span>(hexadecimal)  <span class="hljs-comment"># 输出: 0x10</span><br><br><span class="hljs-comment"># 二进制转十进制</span><br>binary = <span class="hljs-string">&#x27;0b1010&#x27;</span><br>decimal = <span class="hljs-built_in">int</span>(binary,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(decimal)    <span class="hljs-comment">#输出：10</span><br><br><span class="hljs-comment"># 八进制转十进制</span><br>octal = <span class="hljs-string">&#x27;0o12&#x27;</span><br>decimal = <span class="hljs-built_in">int</span>(octal,<span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span>(decimal)  <span class="hljs-comment">#输出：10</span><br><br><span class="hljs-comment">#十六进制转十进制</span><br>hexadecimal = <span class="hljs-string">&#x27;0xff&#x27;</span><br>decimal = <span class="hljs-built_in">int</span>(hexadecimal,<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(decimal)  <span class="hljs-comment">#输出：255</span><br></code></pre></td></tr></table></figure><h2 id="25-结构体变量传递"><a href="#25-结构体变量传递" class="headerlink" title="25.结构体变量传递"></a>25.结构体变量传递</h2><p>在Python中，可以使用<code>collections.namedtuple</code>创建一个具有命名字段的结构体。它创建一个新的元组子类，并为每个字段分配一个名称，使得可以通过名称访问结构体的字段。</p><p>下面是一个示例代码，展示了如何创建结构体并进行变量传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br><span class="hljs-comment"># 创建结构体</span><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>])<br><br><span class="hljs-comment"># 创建结构体变量</span><br>person1 = Person(name=<span class="hljs-string">&#x27;Alice&#x27;</span>, age=<span class="hljs-number">25</span>, gender=<span class="hljs-string">&#x27;Female&#x27;</span>)<br><br><span class="hljs-comment"># 传递结构体变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_person_info</span>(<span class="hljs-params">person</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Name: <span class="hljs-subst">&#123;person.name&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Age: <span class="hljs-subst">&#123;person.age&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gender: <span class="hljs-subst">&#123;person.gender&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 调用函数打印结构体变量的信息</span><br>print_person_info(person1)<br></code></pre></td></tr></table></figure><p>通过定义结构体，我们可以创建具有指定字段的结构体变量，并将其传递给其他函数或方法进行处理。在函数内部，可以通过结构体变量的字段名来访问和操作结构体的数据。</p><h2 id="26-生成器函数（generator-）"><a href="#26-生成器函数（generator-）" class="headerlink" title="26.生成器函数（generator()）"></a>26.生成器函数（generator()）</h2><p>生成器函数是一种特殊的函数，它使用关键字 <code>yield</code> 来产生一个值序列。与普通函数不同的是，生成器函数在执行过程中可以暂停并保存当前的状态，然后在下一次调用时从暂停的地方继续执行，返回一个值，并再次暂停。这样可以节省内存并实现惰性计算。</p><p>生成器函数的定义方式与普通函数相似，但使用 <code>yield</code> 关键字来产生值，而不是使用 <code>return</code> 关键字。每次调用生成器函数时，会返回一个生成器对象，通过调用生成器对象的 <code>__next__()</code> 或 <code>next()</code> 方法可以逐个获取生成器函数中的值。</p><p>以下是一个简单的生成器函数的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 调用生成器函数，获取生成器对象</span><br>gen = my_generator()<br><br><span class="hljs-comment"># 使用生成器对象的 __next__() 或 next() 方法逐个获取生成器函数中的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出: 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出: 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 输出: 3</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>my_generator()</code> 是一个生成器函数，使用 <code>yield</code> 语句产生了三个值：1、2 和 3。通过调用生成器函数 <code>my_generator()</code> 获取生成器对象 <code>gen</code>，然后使用 <code>next()</code> 函数或生成器对象的 <code>__next__()</code> 方法逐个获取生成器函数中的值，并将其打印出来。</p><p>生成器函数还可以接收参数，用于控制生成器函数的行为和产生不同的值序列。生成器函数可以使用循环、条件语句和其他的控制结构来动态地生成值，具有很高的灵活性和可扩展性。</p><p>需要注意的是，当生成器函数的代码执行完毕或遇到 <code>return</code> 语句时，会抛出 <code>StopIteration</code> 异常来表示生成器已经遍历完毕。因此，在使用 <code>next()</code> 函数或生成器对象的 <code>__next__()</code> 方法获取生成器对象的值时，需要注意捕获 <code>StopIteration</code> 异常以避免程序异常退出。</p><h2 id="27-高阶函数"><a href="#27-高阶函数" class="headerlink" title="27.高阶函数"></a>27.高阶函数</h2><p>高阶函数是指可以接受函数作为参数或将函数作为返回值的函数。在Python中，函数是一等公民，因此可以像其他对象一样被传递给函数，这就是高阶函数的特性之一。</p><p>以下是一些常见的高阶函数的示例：</p><ol><li><code>map()</code> 函数：接受一个函数和一个可迭代对象，将函数应用于可迭代对象的每个元素，并返回一个新的可迭代对象。示例：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>squares = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x ** <span class="hljs-number">2</span>, numbers)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squares))  <span class="hljs-comment"># 输出: [1, 4, 9, 16, 25]</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>filter()</code> 函数：接受一个函数和一个可迭代对象，根据函数的返回值对可迭代对象进行过滤，并返回一个新的可迭代对象。示例：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>even_numbers = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, numbers)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(even_numbers))  <span class="hljs-comment"># 输出: [2, 4]</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>reduce()</code> 函数：接受一个函数和一个可迭代对象，将函数应用于可迭代对象的前两个元素，然后将结果与下一个元素继续应用函数，直到遍历完所有元素并返回最终结果。示例：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>product = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, numbers)<br><span class="hljs-built_in">print</span>(product)  <span class="hljs-comment"># 输出: 120 (1 * 2 * 3 * 4 * 5)</span><br></code></pre></td></tr></table></figure><ol start="4"><li><code>sorted()</code> 函数：接受一个可迭代对象，并根据指定的排序规则对其进行排序，并返回一个新的列表。可以通过传递 <code>key</code> 参数来指定排序规则所依据的函数。示例：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>sorted_numbers = <span class="hljs-built_in">sorted</span>(numbers)<br><span class="hljs-built_in">print</span>(sorted_numbers)  <span class="hljs-comment"># 输出: [1, 2, 3, 4, 5]</span><br><br>words = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>, <span class="hljs-string">&#x27;date&#x27;</span>]<br>sorted_words = <span class="hljs-built_in">sorted</span>(words, key=<span class="hljs-built_in">len</span>)<br><span class="hljs-built_in">print</span>(sorted_words)  <span class="hljs-comment"># 输出: [&#x27;date&#x27;, &#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br></code></pre></td></tr></table></figure><p>这些只是高阶函数的一些示例，Python中还有其他许多内置的高阶函数和库中提供的高阶函数。通过使用高阶函数，可以简化代码、提高代码的可读性和灵活性，并充分发挥函数作为一等公民的优势。</p><h2 id="28-装饰器（Decorator）"><a href="#28-装饰器（Decorator）" class="headerlink" title="28.装饰器（Decorator）"></a>28.装饰器（Decorator）</h2><p>代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。装饰器是一种特殊的Python函数，用于修改其他函数的行为。装饰器可以在不修改原函数代码的情况下添加额外的功能或行为。</p><p>装饰器的使用方式是通过在被装饰函数的定义之前使用 <code>@装饰器函数名</code> 的语法来应用装饰器。</p><p>下面是一个简单的装饰器示例，用于记录函数的执行时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timing_decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        start_time = time.time()<br>        result = func(*args, **kwargs)<br>        end_time = time.time()<br>        execution_time = end_time - start_time<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数 <span class="hljs-subst">&#123;func.__name__&#125;</span> 的执行时间为 <span class="hljs-subst">&#123;execution_time&#125;</span> 秒&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@timing_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>():<br>    <span class="hljs-comment"># 函数的具体实现</span><br>    <span class="hljs-keyword">pass</span><br><br>my_function()<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>timing_decorator</code> 是一个装饰器函数，它接受一个函数作为参数，并返回一个新的函数 <code>wrapper</code>。<code>wrapper</code> 函数在被装饰的函数执行前后添加了计时的逻辑，并打印出执行时间。</p><p>通过在 <code>my_function</code> 函数的定义之前使用 <code>@timing_decorator</code>，我们将 <code>my_function</code> 函数应用了装饰器。当我们调用 <code>my_function</code> 时，实际上是调用了被装饰后的 <code>wrapper</code> 函数，从而实现了计时的功能。</p><p>装饰器的使用使得我们可以在不修改原函数代码的情况下，灵活地添加额外的功能或行为，提高代码的可复用性和可维护性。在实际开发中，装饰器常用于日志记录、性能分析、权限控制等方面。</p><h2 id="29-非公开函数或变量"><a href="#29-非公开函数或变量" class="headerlink" title="29.非公开函数或变量"></a>29.非公开函数或变量</h2><p>非公开函数或变量是指在Python中使用下划线（_）作为前缀命名的函数或变量。这种命名约定表示这些函数或变量是供内部使用的，不应该被外部代码直接访问或调用。</p><p>非公开函数和变量的命名约定是一种约定俗成的规范，并不会强制限制对它们的访问。在Python中，它们仍然是可以被访问和使用的，只是开发者之间通过命名约定来暗示它们的用途和意图，建议不要在外部代码中直接使用。</p><p>以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_internal_function</span>():<br>    <span class="hljs-comment"># 非公开函数，供内部使用</span><br>    <span class="hljs-keyword">pass</span><br><br>public_variable = <span class="hljs-number">42</span>  <span class="hljs-comment"># 公开变量</span><br><br>_internal_variable = <span class="hljs-number">10</span>  <span class="hljs-comment"># 非公开变量</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>_internal_function</code> 是一个非公开函数，<code>_internal_variable</code> 是一个非公开变量。虽然它们可以在外部访问，但是根据命名约定，开发者应该将它们视为供内部使用的实体，避免在外部代码中直接使用。</p><p>请注意，Python并不强制限制对非公开函数或变量的访问权限，这只是一种约定俗成的规范。在编写代码时，开发者应该尊重这种约定，遵循良好的编程实践，以提高代码的可维护性和可读性。</p><h2 id="30-正则表达式"><a href="#30-正则表达式" class="headerlink" title="30.正则表达式"></a>30.正则表达式</h2><p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：</p><ul><li><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</li><li><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</li><li><code>&#39;\w\w\d&#39;</code>可以匹配<code>&#39;py3&#39;</code>；</li></ul><ul><li><code>.</code>可以匹配任意字符，所以：<ul><li><code>&#39;py.&#39;</code>可以匹配<code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code>等等。</li></ul></li></ul><p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>&#123;n&#125;</code>表示n个字符，用<code>&#123;n,m&#125;</code>表示n-m个字符：</p><p>来看一个复杂的例子：<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code>。</p><p>我们来从左到右解读一下：</p><ol><li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li><li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39; &#39;</code>等；</li><li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li></ol><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d&#123;3&#125;\-\d&#123;3,8&#125;</code>。</p><p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p><p><strong>进阶</strong></p><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;Py3000&#39;</code>等等；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul><p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p><p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p><p>你可能注意到了，<code>^py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。de</p><h3 id="1-re-sub"><a href="#1-re-sub" class="headerlink" title="1.re.sub()"></a>1.re.sub()</h3><p><code>re.sub()</code> 是 Python 中用于替换字符串中的匹配项的函数。它使用正则表达式模式匹配字符串中的特定模式，并将其替换为指定的内容。</p><p><code>re.sub(pattern, repl, string, count=0, flags=0)</code> 的语法如下：</p><ul><li><code>pattern</code>：要匹配的正则表达式模式。</li><li><code>repl</code>：用于替换匹配项的字符串或替换函数。</li><li><code>string</code>：要进行替换操作的原始字符串。</li><li><code>count</code>：可选参数，指定替换的最大次数。默认为 0，表示替换所有匹配项。</li><li><code>flags</code>：可选参数，用于指定正则表达式的匹配模式。</li></ul><p>下面是一个示例，演示如何使用 <code>re.sub()</code> 进行字符串替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br>text = <span class="hljs-string">&quot;Hello, world! How are you?&quot;</span><br><br><span class="hljs-comment"># 将字符串中的 &quot;world&quot; 替换为 &quot;Python&quot;</span><br>new_text = re.sub(<span class="hljs-string">r&quot;world&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>, text)<br><br><span class="hljs-built_in">print</span>(new_text)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>re.sub()</code> 将字符串中的 “world” 替换为 “Python”。函数将匹配到的第一个 “world” 替换为 “Python”，并返回替换后的新字符串。</p><h2 id="31-intertools"><a href="#31-intertools" class="headerlink" title="31.intertools"></a>31.intertools</h2><p><code>itertools</code> 模块提供了许多用于迭代和组合的工具函数。以下是一些常用的 <code>itertools</code> 方法：</p><ol><li><p><code>count(start=0, step=1)</code>：生成一个无限递增的迭代器，从 <code>start</code> 开始，以 <code>step</code> 为步长。</p></li><li><p><code>cycle(iterable)</code>：对可迭代对象进行无限循环。</p></li><li><p><code>repeat(elem, times=None)</code>：生成一个无限重复 <code>elem</code> 的迭代器，如果指定了 <code>times</code> 参数，则重复指定次数。</p></li><li><p><code>chain(*iterables)</code>：将多个可迭代对象连接成一个迭代器。</p></li><li><p><code>zip_longest(*iterables, fillvalue=None)</code>：将多个可迭代对象的元素逐个配对，使用 <code>fillvalue</code> 填充缺失的值。</p></li><li><p><code>combinations(iterable, r)</code>：生成可迭代对象中长度为 <code>r</code> 的所有组合。</p></li><li><p><code>permutations(iterable, r=None)</code>：生成可迭代对象中长度为 <code>r</code> 的所有排列。</p></li><li><p><code>product(*iterables, repeat=1)</code>：生成多个可迭代对象的笛卡尔积。</p></li><li><p><code>groupby(iterable, key=None)</code>：将可迭代对象中相邻且相等的元素分组。</p></li><li><p><code>accumulate(iterable, func=operator.add)</code>：对可迭代对象进行累积计算。</p></li><li><p><code>starmap(function, iterable)</code>：将函数应用于可迭代对象中的每个元素。</p></li><li><p><code>tee(iterable, n=2)</code>：生成多个独立的迭代器副本。</p></li><li><p><code>islice(iterable, start, stop, step=None)</code>：对可迭代对象进行切片操作。</p></li><li><p><code>dropwhile(predicate, iterable)</code>：跳过满足条件的元素，然后迭代剩余的元素。</p></li><li><p><code>takewhile(predicate, iterable)</code>：迭代满足条件的元素，然后停止。</p><p>等等</p></li></ol><h3 id="1-groupby"><a href="#1-groupby" class="headerlink" title="1.groupby()"></a>1.groupby()</h3><p><code>groupby()</code> 是 Python 中 <code>itertools</code> 模块中的一个函数，它用于对可迭代对象进行分组操作。它根据指定的键函数对可迭代对象中的元素进行分组，并返回一个迭代器，每个分组都是一个元组，包含一个键和相应的元素迭代器。</p><p><code>groupby(iterable, key=None)</code> 的语法如下：</p><ul><li><code>iterable</code>：要分组的可迭代对象。</li><li><code>key</code>：可选参数，用于指定分组的键函数。默认情况下，它是 None，表示按照元素的原始值进行分组。</li></ul><p>下面是一个示例，演示如何使用 <code>groupby()</code> 对列表进行分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> groupby<br><br><span class="hljs-comment"># 示例列表</span><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-comment"># 根据元素的值进行分组</span><br>groups = groupby(numbers)<br><br><span class="hljs-comment"># 遍历分组并打印结果</span><br><span class="hljs-keyword">for</span> key, group <span class="hljs-keyword">in</span> groups:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Key: <span class="hljs-subst">&#123;key&#125;</span>, Group: <span class="hljs-subst">&#123;<span class="hljs-built_in">list</span>(group)&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Key: <span class="hljs-number">1</span>, Group: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>Key: <span class="hljs-number">2</span>, Group: [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<br>Key: <span class="hljs-number">3</span>, Group: [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>]<br>Key: <span class="hljs-number">4</span>, Group: [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]<br>Key: <span class="hljs-number">5</span>, Group: [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>groupby()</code> 对列表 <code>numbers</code> 进行分组。由于未指定键函数，因此默认按照元素的原始值进行分组。然后，我们遍历每个分组并打印键和对应的元素列表。</p><p>请注意，<code>groupby()</code> 返回的是一个迭代器，因此需要通过遍历来访问分组结果。</p><h3 id="2-combinations-和-combinations-with-replacement"><a href="#2-combinations-和-combinations-with-replacement" class="headerlink" title="2.combinations 和 combinations_with_replacement"></a>2.combinations 和 combinations_with_replacement</h3><p><code>combinations</code> 和 <code>combinations_with_replacement</code> 都是 Python 标准库中 <code>itertools</code> 模块提供的用于生成组合的函数，它们的区别在于生成的组合方式不同：</p><ol><li><code>combinations(iterable, r)</code>： 这个函数生成给定可迭代对象中长度为 <code>r</code> 的所有可能组合，但不考虑元素的顺序。换句话说，它生成的组合中的元素不重复，且顺序不同的组合算作不同。</li><li><code>combinations_with_replacement(iterable, r)</code>： 这个函数也生成给定可迭代对象中长度为 <code>r</code> 的所有可能组合，但允许元素重复。换句话说，它生成的组合中的元素可以重复出现，且顺序不同的组合算作不同。</li></ol><p>下面是一个示例，说明这两个函数的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations, combinations_with_replacement<br><br>data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 使用 combinations 生成组合（元素不重复，顺序不同的组合）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Combinations:&quot;</span>)<br><span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data) + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> comb <span class="hljs-keyword">in</span> combinations(data, r):<br>        <span class="hljs-built_in">print</span>(comb)<br><br><span class="hljs-comment"># 使用 combinations_with_replacement 生成组合（元素可以重复，顺序不同的组合）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nCombinations with Replacement:&quot;</span>)<br><span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data) + <span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> comb <span class="hljs-keyword">in</span> combinations_with_replacement(data, r):<br>        <span class="hljs-built_in">print</span>(comb)<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们通过两种方式生成了给定数据 <code>[1, 2, 3]</code> 的组合。你可以运行这段代码，观察输出结果，更好地理解这两个函数的区别。</p><h3 id="3-product"><a href="#3-product" class="headerlink" title="3.product()"></a>3.product()</h3><p><code>itertools.product</code> 是 Python 标准库中的一个函数，用于生成多个可迭代对象的笛卡尔积。它会返回所有可能的元组组合，其中每个元组的一个元素来自于每个输入的可迭代对象。通常用于生成多个集合、列表等的所有可能组合。</p><p>以下是 <code>itertools.product</code> 的基本使用方法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> product<br><br><span class="hljs-comment"># 生成两个可迭代对象的所有组合</span><br>colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>sizes = [<span class="hljs-string">&#x27;small&#x27;</span>, <span class="hljs-string">&#x27;medium&#x27;</span>, <span class="hljs-string">&#x27;large&#x27;</span>]<br><br><span class="hljs-comment"># 生成颜色和尺寸的所有组合</span><br>color_size_combinations = <span class="hljs-built_in">list</span>(product(colors, sizes))<br><span class="hljs-built_in">print</span>(color_size_combinations)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>), (<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;medium&#x27;</span>), (<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;large&#x27;</span>), (<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>), (<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;medium&#x27;</span>), (<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;large&#x27;</span>), (<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>), (<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;medium&#x27;</span>), (<span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;large&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>product(colors, sizes)</code> 生成了所有颜色和尺寸的组合。</p><p>你可以将 <code>itertools.product</code> 用于多个可迭代对象，生成这些可迭代对象的笛卡尔积。这在处理组合问题时非常有用，比如在找到多个数组的所有可能组合时。</p><h3 id="4-permutations"><a href="#4-permutations" class="headerlink" title="4.permutations()"></a>4.permutations()</h3><p><code>permutations()</code>函数是Python中<code>itertools</code>模块提供的一个函数，用于生成指定序列的所有可能排列。它返回一个迭代器，可以用于获取序列的不同排列组合。</p><p>以下是<code>permutations()</code>函数的基本使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations<br><br><span class="hljs-comment"># 创建一个序列</span><br>sequence = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 获取序列的所有排列</span><br>perm = permutations(sequence)<br><br><span class="hljs-comment"># 将排列转换为列表</span><br>perm_list = <span class="hljs-built_in">list</span>(perm)<br><br><span class="hljs-comment"># 打印所有排列</span><br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> perm_list:<br>    <span class="hljs-built_in">print</span>(p)<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先导入<code>permutations</code>函数，然后创建一个包含整数1、2和3的序列。接下来，我们使用<code>permutations()</code>函数生成这个序列的所有排列。最后，我们将排列转换为一个列表，并打印出所有的排列组合。</p><p>输出结果将显示所有可能的排列，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="5-permutations-与product-的区别"><a href="#5-permutations-与product-的区别" class="headerlink" title="5.permutations()与product()的区别"></a>5.permutations()与product()的区别</h3><p><code>permutations()</code>和<code>product()</code>是Python中<code>itertools</code>模块提供的两个函数，用于生成序列的不同组合，但它们之间有一些关键区别：</p><ol><li><strong>排列 vs. 组合：</strong><ul><li><code>permutations(iterable, r)</code>: 生成指定长度 <code>r</code> 的排列，包括了所有元素的不同顺序排列。如果不指定 <code>r</code>，则默认为序列的长度。每个元素仅在结果中出现一次。</li><li><code>product(*iterables, repeat=1)</code>: 生成笛卡尔积，包括了多个可迭代对象中所有可能的组合，可以包含重复的元素。</li></ul></li><li><strong>结果类型：</strong><ul><li><code>permutations()</code>返回的结果是一个排列的迭代器，其中每个排列是一个元组。</li><li><code>product()</code>返回的结果是笛卡尔积的迭代器，其中每个组合是一个元组。</li></ul></li><li><strong>使用场景：</strong><ul><li><code>permutations()</code>通常用于生成不同元素的排列，例如生成字母的不同排列。</li><li><code>product()</code>通常用于生成多个可迭代对象的所有组合，可能包含相同元素的组合。</li></ul></li></ol><p>下面是两个函数的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> permutations, product<br><br><span class="hljs-comment"># 生成排列</span><br>perm = permutations([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">2</span>)<br>perm_list = <span class="hljs-built_in">list</span>(perm)<br><span class="hljs-built_in">print</span>(perm_list)  <span class="hljs-comment"># 输出: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]</span><br><br><span class="hljs-comment"># 生成笛卡尔积</span><br>prod = product([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>])<br>prod_list = <span class="hljs-built_in">list</span>(prod)<br><span class="hljs-built_in">print</span>(prod_list)  <span class="hljs-comment"># 输出: [(1, &#x27;a&#x27;), (1, &#x27;b&#x27;), (2, &#x27;a&#x27;), (2, &#x27;b&#x27;)]</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>permutations()</code>生成了包含2个元素的排列，而<code>product()</code>生成了两个可迭代对象的笛卡尔积。</p><h2 id="32数字相关"><a href="#32数字相关" class="headerlink" title="32数字相关"></a>32数字相关</h2><h3 id="1-decimal模块"><a href="#1-decimal模块" class="headerlink" title="1. decimal模块"></a>1. decimal模块</h3><p><code>decimal</code>模块是Python中用于高精度数学运算的模块。它提供了一种Decimal数据类型，可以用于执行浮点数运算，并且具有固定的精度，避免了浮点数运算中的精度损失问题。</p><p>在Python中，通常使用<code>float</code>类型来表示浮点数，但是由于浮点数的存储方式是二进制表示，导致在进行一些简单的算术运算时可能会出现精度丢失。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span><br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出为 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>而使用<code>decimal</code>模块，可以避免这种精度问题，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br>x = Decimal(<span class="hljs-string">&#x27;0.1&#x27;</span>) + Decimal(<span class="hljs-string">&#x27;0.2&#x27;</span>)<br><span class="hljs-built_in">print</span>(x)  <span class="hljs-comment"># 输出为 0.3</span><br></code></pre></td></tr></table></figure><p><code>decimal</code>模块的主要特点包括：</p><ol><li>支持大量的数学函数，例如sin、cos、exp等。</li><li>可以设置固定的精度（小数位数）。</li><li>可以进行高精度的运算，避免浮点数运算精度问题。</li><li>支持各种数值格式的输入和输出，如字符串、整数等。</li></ol><p>以下是一个使用<code>decimal</code>模块的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br><span class="hljs-comment"># 设置精度为2位小数</span><br>Decimal.getcontext().prec = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 高精度计算</span><br>x = Decimal(<span class="hljs-string">&#x27;1.1&#x27;</span>)<br>y = Decimal(<span class="hljs-string">&#x27;2.2&#x27;</span>)<br>result = x + y<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出为 3.3</span><br></code></pre></td></tr></table></figure><p>请注意，由于<code>decimal</code>模块提供了高精度的计算，它比普通的浮点数运算更消耗计算资源。因此，在实际应用中，建议根据实际需求来选择使用<code>decimal</code>模块还是普通的浮点数。如果需要更高的精度和准确性，可以考虑使用<code>decimal</code>模块。</p><h3 id="2-Fraction模块"><a href="#2-Fraction模块" class="headerlink" title="2. Fraction模块"></a>2. Fraction模块</h3><p><code>Fraction</code>模块是Python中用于处理有理数（分数）的模块。它提供了<code>Fraction</code>类，可以用于表示和操作有理数，避免了浮点数运算中的精度损失问题，并且保持精确的数值。</p><p>在Python中，通常使用<code>float</code>类型来表示浮点数，但由于浮点数的存储方式是二进制表示，进行简单的算术运算可能会出现精度丢失问题。而使用<code>Fraction</code>模块可以避免这种精度问题，以及得到更准确的结果。</p><p><code>Fraction</code>模块的主要特点包括：</p><ol><li>可以表示有理数，如分数，例如 1&#x2F;3、2&#x2F;5 等。</li><li>可以进行有理数之间的算术运算，如加法、减法、乘法、除法等。</li><li>支持各种数值格式的输入和输出，如字符串、整数等。</li></ol><p>以下是一个使用<code>Fraction</code>模块的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fractions <span class="hljs-keyword">import</span> Fraction<br><br><span class="hljs-comment"># 创建分数对象</span><br>frac1 = Fraction(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>frac2 = Fraction(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 进行加法运算</span><br>result = frac1 + frac2<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出为 11/15</span><br></code></pre></td></tr></table></figure><p>与<code>decimal</code>模块不同，<code>Fraction</code>模块提供了精确的有理数计算，而不是高精度的十进制计算。因此，如果需要进行精确的分数运算，<code>Fraction</code>模块是一个很好的选择。</p><p>需要注意的是，<code>Fraction</code>模块仅适用于有理数，无法处理无理数（例如π和√2）。如果需要处理无理数，可以考虑使用<code>decimal</code>模块或其他数学计算库。</p><h2 id="33文件"><a href="#33文件" class="headerlink" title="33文件"></a>33文件</h2><h3 id="1-文件的基本操作"><a href="#1-文件的基本操作" class="headerlink" title="1.文件的基本操作"></a>1.文件的基本操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">output = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;C:\spam&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)          <span class="hljs-comment"># 打开输出文件，用于写</span><br><span class="hljs-built_in">input</span> = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)               <span class="hljs-comment"># 打开输入文件，用于读。打开的方式可以为&#x27;w&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;wb&#x27;, &#x27;rb&#x27;, &#x27;ab&#x27;等</span><br>fp.read([size])                         <span class="hljs-comment"># size为读取的长度，以byte为单位</span><br>fp.readline([size])                     <span class="hljs-comment"># 读一行，如果定义了size，有可能返回的只是一行的一部分</span><br>fp.readlines([size])                    <span class="hljs-comment"># 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。</span><br>fp.readable()                           <span class="hljs-comment"># 是否可读</span><br>fp.write(<span class="hljs-built_in">str</span>)                           <span class="hljs-comment"># 把str写到文件中，write()并不会在str后加上一个换行符</span><br>fp.writelines(seq)                      <span class="hljs-comment"># 把seq的内容全部写到文件中(多行一次性写入)</span><br>fp.writeable()                          <span class="hljs-comment"># 是否可写</span><br>fp.close()                              <span class="hljs-comment"># 关闭文件。</span><br>fp.flush()                              <span class="hljs-comment"># 把缓冲区的内容写入硬盘</span><br>fp.fileno()                             <span class="hljs-comment"># 返回一个长整型的”文件标签“</span><br>fp.isatty()                             <span class="hljs-comment"># 文件是否是一个终端设备文件（unix系统中的）</span><br>fp.tell()                               <span class="hljs-comment"># 返回文件操作标记的当前位置，以文件的开头为原点</span><br>fp.<span class="hljs-built_in">next</span>()                               <span class="hljs-comment"># 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span><br>fp.seek(offset[,whence])                <span class="hljs-comment"># 将文件打开操作标记移到offset的位置。whence为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。</span><br>fp.seekable()                           <span class="hljs-comment"># 是否可以seek</span><br>fp.truncate([size])                     <span class="hljs-comment"># 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>): <br>    <span class="hljs-built_in">print</span>(line)                         <span class="hljs-comment"># 使用for语句，比较适用于打开比较大的文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    <span class="hljs-built_in">print</span>(file.readline())              <span class="hljs-comment"># 使用with语句，可以保证文件关闭</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    lines = file.readlines()            <span class="hljs-comment"># 一次读入文件所有行，并关闭文件</span><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f.txt&#x27;</span>, encoding = <span class="hljs-string">&#x27;latin-1&#x27;</span>)     <span class="hljs-comment"># Python3.x Unicode文本文件</span><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;f.bin&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)                     <span class="hljs-comment"># Python3.x 二进制bytes文件</span><br><span class="hljs-comment"># 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等</span><br></code></pre></td></tr></table></figure><h2 id="34collections"><a href="#34collections" class="headerlink" title="34collections"></a>34collections</h2><p><code>collections</code> 是 Python 中的一个模块，提供了一些额外的数据类型和数据结构，用于在处理数据时扩展标准数据类型的功能。以下是一些常见的 <code>collections</code> 类型和它们的主要功能：</p><ol><li><code>Counter</code>：用于计数可迭代对象中元素的出现次数，并返回一个字典，其中键是元素，值是计数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-comment"># 创建一个计数器对象</span><br>counter = Counter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 访问元素的计数</span><br><span class="hljs-built_in">print</span>(counter[<span class="hljs-number">2</span>])  <span class="hljs-comment"># 输出 2</span><br></code></pre></td></tr></table></figure><ol start="2"><li><code>defaultdict</code>：是字典的一个子类，允许为字典的值指定默认数据类型。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-comment"># 创建一个默认字典，值的默认类型为 int</span><br>my_dict = defaultdict(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># 如果访问不存在的键，会自动初始化为默认值</span><br>my_dict[<span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>  <span class="hljs-comment"># 等同于 my_dict[&#x27;a&#x27;] = my_dict[&#x27;a&#x27;] + 1</span><br><br><span class="hljs-built_in">print</span>(my_dict[<span class="hljs-string">&#x27;a&#x27;</span>])  <span class="hljs-comment"># 输出 1</span><br><span class="hljs-built_in">print</span>(my_dict[<span class="hljs-string">&#x27;b&#x27;</span>])  <span class="hljs-comment"># 输出 0，因为 &#x27;b&#x27; 不存在于字典中</span><br></code></pre></td></tr></table></figure><ol start="3"><li><code>deque</code>：是双端队列的实现，提供了高效的插入和删除操作，适合用于队列和栈。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br><span class="hljs-comment"># 创建一个双端队列</span><br>my_deque = deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># 在左侧添加元素</span><br>my_deque.appendleft(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 在右侧添加元素</span><br>my_deque.append(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 弹出左侧元素</span><br>left_element = my_deque.popleft()<br><br><span class="hljs-built_in">print</span>(my_deque)        <span class="hljs-comment"># 输出 deque([0, 1, 2, 3, 4])</span><br><span class="hljs-built_in">print</span>(left_element)    <span class="hljs-comment"># 输出 0</span><br></code></pre></td></tr></table></figure><ol start="4"><li><code>namedtuple</code>：用于创建带字段名的元组，可提高代码的可读性。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br><span class="hljs-comment"># 创建一个名为 &#x27;Person&#x27; 的命名元组，包含 &#x27;name&#x27; 和 &#x27;age&#x27; 两个字段</span><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>])<br><br><span class="hljs-comment"># 创建一个 Person 对象</span><br>person = Person(name=<span class="hljs-string">&#x27;Alice&#x27;</span>, age=<span class="hljs-number">30</span>)<br><br><span class="hljs-built_in">print</span>(person.name)  <span class="hljs-comment"># 输出 &#x27;Alice&#x27;</span><br><span class="hljs-built_in">print</span>(person.age)   <span class="hljs-comment"># 输出 30</span><br></code></pre></td></tr></table></figure><ul><li><p><em>classmethod</em> somenamedtuple.<strong>_make</strong>(<em>iterable</em>)，类方法从存在的序列或迭代实例创建一个新实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">t = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>]<br>Point._make(t)<br>Point(x=<span class="hljs-number">11</span>, y=<span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="35MATH"><a href="#35MATH" class="headerlink" title="35MATH"></a>35MATH</h2><h3 id="1-三角函数-计算正弦、余弦、正切、余切"><a href="#1-三角函数-计算正弦、余弦、正切、余切" class="headerlink" title="1.三角函数-计算正弦、余弦、正切、余切"></a>1.三角函数-计算正弦、余弦、正切、余切</h3><p>在 Python 中，你可以使用 <code>math</code> 模块来进行正弦（sine）、余弦（cosine）、正切（tangent）和余切（cotangent）等数学运算。以下是它们的基本用法：</p><p>首先，确保你已经导入了 <code>math</code> 模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br></code></pre></td></tr></table></figure><p>然后，你可以使用以下函数进行这些运算：</p><ol><li><p>正弦（sine）：<code>math.sin(x)</code></p><p>正弦函数返回给定角度 <code>x</code> 的正弦值，其中 <code>x</code> 应该以弧度为单位。如果你有角度而不是弧度，你可以使用 <code>math.radians()</code> 函数将角度转换为弧度。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>angle_in_radians = math.radians(<span class="hljs-number">30</span>)  <span class="hljs-comment"># 将角度转换为弧度</span><br>sine_value = math.sin(angle_in_radians)<br><span class="hljs-built_in">print</span>(sine_value)<br></code></pre></td></tr></table></figure></li><li><p>余弦（cosine）：<code>math.cos(x)</code></p><p>余弦函数返回给定角度 <code>x</code> 的余弦值，也需要以弧度为单位的输入。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>angle_in_radians = math.radians(<span class="hljs-number">45</span>)  <span class="hljs-comment"># 将角度转换为弧度</span><br>cosine_value = math.cos(angle_in_radians)<br><span class="hljs-built_in">print</span>(cosine_value)<br></code></pre></td></tr></table></figure></li><li><p>正切（tangent）：<code>math.tan(x)</code></p><p>正切函数返回给定角度 <code>x</code> 的正切值，同样需要以弧度为单位的输入。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>angle_in_radians = math.radians(<span class="hljs-number">60</span>)  <span class="hljs-comment"># 将角度转换为弧度</span><br>tangent_value = math.tan(angle_in_radians)<br><span class="hljs-built_in">print</span>(tangent_value)<br></code></pre></td></tr></table></figure></li><li><p>余切（cotangent）：<code>1 / math.tan(x)</code></p><p>余切函数返回给定角度 <code>x</code> 的余切值，可以通过 <code>1 / math.tan(x)</code> 来计算。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>angle_in_radians = math.radians(<span class="hljs-number">75</span>)  <span class="hljs-comment"># 将角度转换为弧度</span><br>cotangent_value = <span class="hljs-number">1</span> / math.tan(angle_in_radians)<br><span class="hljs-built_in">print</span>(cotangent_value)<br></code></pre></td></tr></table></figure></li></ol><p>请注意，这些函数都要求输入的角度是以弧度为单位的，因此在进行计算之前，你可能需要使用 <code>math.radians()</code> 函数将角度转换为弧度。这些函数返回浮点数值，表示对应的三角函数值。</p><h3 id="2-三角函数–根据正弦、余弦、正切、余切计算角度"><a href="#2-三角函数–根据正弦、余弦、正切、余切计算角度" class="headerlink" title="2.三角函数–根据正弦、余弦、正切、余切计算角度"></a>2.三角函数–根据正弦、余弦、正切、余切计算角度</h3><p><code>math</code> 模块中的正弦、余弦、正切和余切等函数用于计算三角形中的角度，通常是通过已知边长和角度来解决三角形的问题。这些函数可以帮助你计算三角形的角度，但需要具备足够的已知信息来进行计算。</p><p>以下是一些常见的用法示例：</p><ol><li><p><strong>计算角的正弦值（Sine）：</strong></p><p>如果你知道一个三角形的某个角的正弦值以及对边的长度，你可以使用反正弦函数 <code>math.asin()</code> 来计算这个角度。例如，如果你知道正弦值为 <code>0.5</code>，对边长度为 <code>5</code>，你可以这样计算角度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>sine_value = <span class="hljs-number">0.5</span><br>opposite_side_length = <span class="hljs-number">5</span><br><br>angle_in_radians = math.asin(sine_value)<br>angle_in_degrees = math.degrees(angle_in_radians)<br><span class="hljs-built_in">print</span>(angle_in_degrees)<br></code></pre></td></tr></table></figure></li><li><p><strong>计算角的余弦值（Cosine）：</strong></p><p>类似地，如果你知道一个角的余弦值以及邻边的长度，你可以使用反余弦函数 <code>math.acos()</code> 来计算这个角度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>cosine_value = <span class="hljs-number">0.866</span>  <span class="hljs-comment"># 余弦值</span><br>adjacent_side_length = <span class="hljs-number">5</span><br><br>angle_in_radians = math.acos(cosine_value)<br>angle_in_degrees = math.degrees(angle_in_radians)<br><span class="hljs-built_in">print</span>(angle_in_degrees)<br></code></pre></td></tr></table></figure></li><li><p><strong>计算角的正切值（Tangent）：</strong></p><p>如果你知道一个角的正切值以及对边的长度，你可以使用反正切函数 <code>math.atan()</code> 来计算这个角度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>tangent_value = <span class="hljs-number">1.732</span>  <span class="hljs-comment"># 正切值</span><br>opposite_side_length = <span class="hljs-number">5</span><br><br>angle_in_radians = math.atan(tangent_value)<br>angle_in_degrees = math.degrees(angle_in_radians)<br><span class="hljs-built_in">print</span>(angle_in_degrees)<br></code></pre></td></tr></table></figure></li><li><p><strong>计算角的余切值（Cotangent）：</strong></p><p>类似地，如果你知道一个角的余切值以及邻边的长度，你可以计算角度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>cotangent_value = <span class="hljs-number">2.0</span>  <span class="hljs-comment"># 余切值</span><br>adjacent_side_length = <span class="hljs-number">5</span><br><br>angle_in_radians = math.atan(<span class="hljs-number">1</span> / cotangent_value)<br>angle_in_degrees = math.degrees(angle_in_radians)<br><span class="hljs-built_in">print</span>(angle_in_degrees)<br></code></pre></td></tr></table></figure></li></ol><p>上述示例假设你已知某个角的三角函数值以及相关边的长度。通常，要计算一个三角形的角，你需要已知至少一个角的三角函数值和相关边的长度，或者你需要其他相关信息，如其他已知角度或边长。然后，你可以使用这些函数来解决问题。</p><h3 id="3-三角函数-知道边求角度"><a href="#3-三角函数-知道边求角度" class="headerlink" title="3.三角函数-知道边求角度"></a>3.三角函数-知道边求角度</h3><p>如果你已知三角形的三条边的长度，你可以使用三角函数的反函数来计算对应的角度。以下是计算三角形角度的一般步骤：</p><ol><li>确保你有三角形的三个边的长度。</li><li>使用余弦定理计算任一角的余弦值。</li><li>使用反余弦函数 <code>math.acos()</code> 来计算该角的弧度值。</li><li>可选：将弧度值转换为度数。</li></ol><p>这里是一个示例，假设你已知三角形的三边长度 <code>a</code>、<code>b</code> 和 <code>c</code>，并且你想计算对应于边 <code>a</code> 的角度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-comment"># 已知边长</span><br>a = <span class="hljs-number">5.0</span><br>b = <span class="hljs-number">4.0</span><br>c = <span class="hljs-number">3.0</span><br><br><span class="hljs-comment"># 使用余弦定理计算角A的余弦值</span><br>cos_A = (b**<span class="hljs-number">2</span> - c**<span class="hljs-number">2</span> - a**<span class="hljs-number">2</span>) / (-<span class="hljs-number">2</span> * b * c)<br><br><span class="hljs-comment"># 使用反余弦函数计算弧度值</span><br>angle_A_radians = math.acos(cos_A)<br><br><span class="hljs-comment"># 将弧度值转换为度数</span><br>angle_A_degrees = math.degrees(angle_A_radians)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Angle A (degrees):&quot;</span>, angle_A_degrees)<br></code></pre></td></tr></table></figure><p>这个示例中，我们使用余弦定理计算了角 A 的余弦值，然后使用反余弦函数 <code>math.acos()</code> 计算了角 A 的弧度值，最后将弧度值转换为度数。</p><p>请注意，如果你想计算其他角的度数，可以通过类似的方式计算。根据需要，你可以替换 <code>a</code>、<code>b</code> 和 <code>c</code> 的值，以计算其他角的度数。</p><h2 id="36-Numpy"><a href="#36-Numpy" class="headerlink" title="36. Numpy"></a>36. Numpy</h2><p>NumPy (Numerical Python) 是一个Python库，用于处理和执行科学计算和数值运算。它提供了一个强大的多维数组对象（通常称为NumPy数组或ndarray）和许多用于操作这些数组的函数。NumPy是数据科学和机器学习领域的核心工具之一，它可以用于执行各种数学、统计和数据处理任务。</p><p>以下是一些常见的NumPy功能和用法：</p><ol><li><p><strong>创建NumPy数组</strong>：使用 <code>numpy.array()</code> 函数可以从Python列表或元组创建NumPy数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br></code></pre></td></tr></table></figure></li><li><p><strong>数组操作</strong>：NumPy提供了各种操作数组的函数，包括索引、切片、重塑、合并和分割等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片操作</span><br>subset = arr[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br><br><span class="hljs-comment"># 数组合并</span><br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>result = np.concatenate((arr1, arr2))<br></code></pre></td></tr></table></figure></li><li><p><strong>数学运算</strong>：NumPy支持向量化操作，可以对整个数组执行数学运算，而不需要显式循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>b = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br>result = a + b  <span class="hljs-comment"># 数组加法</span><br></code></pre></td></tr></table></figure></li><li><p><strong>统计和线性代数</strong>：NumPy包括许多统计函数和线性代数操作，如均值、方差、矩阵乘法等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">mean = np.mean(arr)<br>dot_product = np.dot(arr1, arr2)<br></code></pre></td></tr></table></figure></li><li><p><strong>随机数生成</strong>：NumPy提供了生成随机数的函数，可以用于模拟、实验和统计分析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>random_numbers = np.random.rand(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 生成5个随机数</span><br></code></pre></td></tr></table></figure></li><li><p><strong>广播</strong>：NumPy允许不同形状的数组进行运算，通过广播机制自动扩展数组的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>b = <span class="hljs-number">2</span><br><br>result = a * b  <span class="hljs-comment"># 数组与标量相乘，广播b到与a相同的形状</span><br></code></pre></td></tr></table></figure></li><li><p><strong>文件输入&#x2F;输出</strong>：NumPy支持读取和写入数组数据到磁盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.save(<span class="hljs-string">&#x27;data.npy&#x27;</span>, arr)  <span class="hljs-comment"># 保存数组到文件</span><br>loaded_arr = np.load(<span class="hljs-string">&#x27;data.npy&#x27;</span>)  <span class="hljs-comment"># 从文件加载数组</span><br></code></pre></td></tr></table></figure></li></ol><p>这只是NumPy的一些功能和用法的概述。NumPy在数据科学、数值计算、机器学习等领域具有广泛的应用，因为它提供了高效的数据结构和操作，以及丰富的数学和统计函数。</p><h3 id="1-inner与outer"><a href="#1-inner与outer" class="headerlink" title="1. inner与outer"></a>1. inner与outer</h3><p><code>numpy.inner()</code> 和 <code>numpy.outer()</code> 是 NumPy 中用于进行向量和矩阵运算的两个不同的函数，它们有不同的用途和行为：</p><ol><li><p>**<code>numpy.inner()</code>**：</p><p><code>numpy.inner(a, b)</code> 函数计算两个数组的内积（dot product）。对于一维数组，这是标准的点积运算。对于多维数组，它会将最后一个轴上的元素相乘并求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>b = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br>result = np.inner(a, b)  <span class="hljs-comment"># 结果为 1*4 + 2*5 + 3*6 = 32</span><br></code></pre></td></tr></table></figure><p>对于多维数组，<code>numpy.inner()</code> 会按照特定的规则进行内积运算。</p></li><li><p>**<code>numpy.outer()</code>**：</p><p><code>numpy.outer(a, b)</code> 函数计算两个数组的外积（outer product）。外积是将第一个数组的每个元素与第二个数组的每个元素相乘而得到的矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>b = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br>result = np.outer(a, b)<br></code></pre></td></tr></table></figure><p>这将生成一个2D矩阵，其元素是两个输入数组中的元素相乘的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">array([[ <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>],<br>       [ <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>],<br>       [<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>]])<br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>numpy.inner()</code> 用于计算两个数组的内积，结果是一个标量或者按一定规则计算多维数组的内积。</li><li><code>numpy.outer()</code> 用于计算两个数组的外积，结果是一个矩阵，其中的元素是两个输入数组中的元素相乘的结果。</li></ul><h3 id="2-numpy-poly"><a href="#2-numpy-poly" class="headerlink" title="2. numpy.poly"></a>2. numpy.poly</h3><p><code>numpy.poly</code> 是 NumPy 中的一个模块，用于处理多项式的系数和操作多项式。它提供了多种用于创建、操作和分析多项式的函数。</p><p>以下是一些 <code>numpy.poly</code> 模块中常用的函数和用法：</p><ol><li><p>**<code>numpy.poly1d</code>**：</p><p><code>numpy.poly1d(c)</code> 创建一个一维多项式，其中 <code>c</code> 是多项式的系数列表。这个函数可以将系数转换为多项式对象，从而可以进行多项式的操作。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">import numpy as np<br><br>coefficients = [1, 2, 3]  <span class="hljs-comment"># 多项式系数</span><br>poly = np.poly1d(coefficients)<br><br><span class="hljs-comment"># 使用多项式对象进行多项式运算</span><br>result = poly(2)  <span class="hljs-comment"># 计算多项式在 x=2 处的值</span><br></code></pre></td></tr></table></figure></li><li><p>**<code>numpy.polyadd</code>**：</p><p><code>numpy.polyadd(p1, p2)</code> 计算两个多项式 <code>p1</code> 和 <code>p2</code> 的和。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-attribute">p1</span> = np.poly1d([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">p2</span> = np.poly1d([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-attribute">result</span> = np.polyadd(p1, p2)  # 计算 p1 + p2<br></code></pre></td></tr></table></figure></li><li><p>**<code>numpy.polysub</code>**：</p><p><code>numpy.polysub(p1, p2)</code> 计算两个多项式 <code>p1</code> 和 <code>p2</code> 的差。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-attribute">p1</span> = np.poly1d([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">p2</span> = np.poly1d([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-attribute">result</span> = np.polysub(p1, p2)  # 计算 p1 - p2<br></code></pre></td></tr></table></figure></li><li><p>**<code>numpy.polymul</code>**：</p><p><code>numpy.polymul(p1, p2)</code> 计算两个多项式 <code>p1</code> 和 <code>p2</code> 的乘积。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-attribute">p1</span> = np.poly1d([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-attribute">p2</span> = np.poly1d([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-attribute">result</span> = np.polymul(p1, p2)  # 计算 p1 * p2<br></code></pre></td></tr></table></figure></li><li><p>**<code>numpy.polydiv</code>**：</p><p><code>numpy.polydiv(p1, p2)</code> 计算多项式 <code>p1</code> 除以多项式 <code>p2</code> 的商和余数。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">import numpy as <span class="hljs-built_in">np</span><br><br>p1 = <span class="hljs-built_in">np</span>.poly1d([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>p2 = <span class="hljs-built_in">np</span>.poly1d([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-built_in">quotient</span>, <span class="hljs-built_in">remainder</span> = <span class="hljs-built_in">np</span>.polydiv(p1, p2)<br></code></pre></td></tr></table></figure></li></ol><p>这些是 <code>numpy.poly</code> 模块中的一些常用函数，用于处理多项式。多项式在科学计算、工程和数据分析中经常用到，这些函数使得多项式的创建和操作变得更加方便。</p><h3 id="3-nump-roots"><a href="#3-nump-roots" class="headerlink" title="3. nump.roots"></a>3. nump.roots</h3><p><code>numpy.roots</code> 是 NumPy 中的一个函数，用于计算多项式的根（或零点）。给定一个多项式的系数，<code>numpy.roots</code> 可以返回该多项式的根。根是使多项式等于零的值。</p><p>以下是 <code>numpy.roots</code> 函数的用法示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义多项式的系数（从高次到低次）</span><br>coefficients = [<span class="hljs-number">1</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">11</span>, <span class="hljs-number">-6</span>]<br><br><span class="hljs-comment"># 计算多项式的根</span><br>roots = np.roots(coefficients)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;多项式的根：&quot;</span>, roots)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个多项式的系数 <code>[1, -6, 11, -6]</code>，这对应于多项式 <code>x^3 - 6x^2 + 11x - 6</code>。然后，我们使用 <code>np.roots()</code> 计算了这个多项式的根。运行这段代码会得到多项式的根：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">多项式的根： <span class="hljs-selector-attr">[3. 2. 1.]</span><br></code></pre></td></tr></table></figure><p>这表示多项式有三个根，分别是 3、2 和 1。</p><p>注意，多项式的次数由系数的数量确定。对于一个 n 次多项式，将需要 n+1 个系数。多项式的根可以是实数或复数，具体取决于多项式的系数。</p><h3 id="4-numpy-polyint"><a href="#4-numpy-polyint" class="headerlink" title="4.numpy.polyint"></a>4.numpy.polyint</h3><p><code>numpy.polyint</code> 是 NumPy 中的一个函数，用于对多项式进行不定积分。它接受一个多项式的系数作为输入，并返回其不定积分（即原函数）的系数。</p><p>以下是 <code>numpy.polyint</code> 函数的用法示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义多项式的系数（从高次到低次）</span><br>coefficients = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 计算多项式的不定积分</span><br>integral_coefficients = np.polyint(coefficients)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;多项式的不定积分系数：&quot;</span>, integral_coefficients)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个多项式的系数 <code>[1, 2, 3]</code>，这对应于多项式 <code>x^2 + 2x + 3</code>。然后，我们使用 <code>np.polyint()</code> 计算了这个多项式的不定积分的系数。运行这段代码会得到多项式的不定积分的系数：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">多项式的不定积分系数： <span class="hljs-string">[0.33333333 1.         3.         0.        ]</span><br></code></pre></td></tr></table></figure><p>这个结果表示多项式的不定积分系数为 <code>[0.33333333, 1, 3, 0]</code>，这对应于不定积分的多项式 <code>0.33333333x^3 + x^2 + 3x + C</code>，其中 <code>C</code> 是积分常数。</p><p><code>numpy.polyint</code> 可以帮助你计算多项式的不定积分，这在数学和工程计算中经常用到。</p><h3 id="5-numpy-polyder"><a href="#5-numpy-polyder" class="headerlink" title="5.numpy.polyder"></a>5.numpy.polyder</h3><p><code>numpy.polyder</code> 是 NumPy 中的一个函数，用于计算多项式的导数。给定一个多项式的系数，<code>numpy.polyder</code> 可以返回其导数的系数。</p><p>以下是 <code>numpy.polyder</code> 函数的用法示例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义多项式的系数（从高次到低次）</span><br>coefficients = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 计算多项式的导数</span><br>derivative_coefficients = np.polyder(coefficients)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;多项式的导数系数：&quot;</span>, derivative_coefficients)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个多项式的系数 <code>[3, 2, 1]</code>，这对应于多项式 <code>3x^2 + 2x + 1</code>。然后，我们使用 <code>np.polyder()</code> 计算了这个多项式的导数的系数。运行这段代码会得到多项式的导数的系数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">多项式的导数系数： <span class="hljs-selector-attr">[6 2]</span><br></code></pre></td></tr></table></figure><p>这个结果表示多项式的导数系数为 <code>[6, 2]</code>，这对应于多项式的一阶导数 <code>6x + 2</code>。</p><p><code>numpy.polyder</code> 可以帮助你计算多项式的导数，这在微积分和工程计算中经常用到。</p><h3 id="6-numpy-polyval"><a href="#6-numpy-polyval" class="headerlink" title="6.numpy.polyval"></a>6.numpy.polyval</h3><p><code>numpy.polyval</code> 是 NumPy 中的一个函数，用于计算多项式函数在给定点的值。它接受两个参数：多项式的系数和点的值，并返回多项式在给定点的函数值。</p><p>以下是 <code>numpy.polyval</code> 函数的用法示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义多项式的系数（从高次到低次）</span><br>coefficients = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br><span class="hljs-comment"># 计算多项式在 x=2 处的值</span><br>x = <span class="hljs-number">2</span><br>result = np.polyval(coefficients, x)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;多项式在 x=<span class="hljs-subst">&#123;x&#125;</span> 处的值：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个多项式的系数 <code>[1, 2, 3]</code>，这对应于多项式 <code>x^2 + 2x + 3</code>。然后，我们使用 <code>np.polyval()</code> 计算了这个多项式在 x&#x3D;2 处的值。运行这段代码会得到多项式在给定点的值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">多项式在 <span class="hljs-attribute">x</span>=2 处的值：11<br></code></pre></td></tr></table></figure><p>这表示多项式在 x&#x3D;2 处的值为 11。</p><p><code>numpy.polyval</code> 对于计算多项式函数在特定点的值非常方便，这在数学和工程计算中经常用到。</p><h3 id="7-numpy-polyfit"><a href="#7-numpy-polyfit" class="headerlink" title="7.numpy.polyfit"></a>7.numpy.polyfit</h3><p><code>numpy.polyfit</code> 是 NumPy 中的一个函数，用于拟合多项式到一组数据点。它接受输入数据点的 x 坐标、y 坐标以及所需的多项式的次数，然后返回多项式的系数，这些系数可以用于描述拟合的多项式函数。</p><p>以下是 <code>numpy.polyfit</code> 函数的用法示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<br><br><span class="hljs-comment"># 输入数据点</span><br><span class="hljs-attribute">x</span> = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-attribute">y</span> = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>])<br><br><span class="hljs-comment"># 使用 numpy.polyfit 进行多项式拟合</span><br><span class="hljs-attribute">degree</span> = <span class="hljs-number">2</span>  # 拟合多项式的次数<br><span class="hljs-attribute">coefficients</span> = np.polyfit(x, y, degree)<br><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;拟合多项式的系数：&quot;</span>, coefficients)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们有一组数据点 <code>(x, y)</code>，并希望用一个二次多项式来拟合这些数据点。我们通过设置 <code>degree</code> 变量为 2 来指定拟合多项式的次数。然后，我们使用 <code>np.polyfit()</code> 函数进行拟合，它返回了拟合多项式的系数。运行这段代码会得到拟合多项式的系数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">拟合多项式的系数： <span class="hljs-selector-attr">[ 1.  -1.   1.]</span><br></code></pre></td></tr></table></figure><p>这表示拟合的多项式为 <code>1*x^2 - 1*x + 1</code>。</p><p>您可以根据数据和所需的拟合多项式的次数来使用 <code>numpy.polyfit</code> 来拟合数据并得到多项式的系数。这在数据分析、曲线拟合等领域非常有用。</p><h3 id="8-numpy-concatenate"><a href="#8-numpy-concatenate" class="headerlink" title="8.numpy.concatenate"></a>8.numpy.concatenate</h3><p><code>numpy.concatenate</code> 是 NumPy 中用于连接（拼接）数组的函数。它允许您将两个或多个数组沿指定的轴连接在一起，创建一个新的数组。</p><p>以下是 <code>numpy.concatenate</code> 函数的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建两个数组</span><br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br><span class="hljs-comment"># 使用 numpy.concatenate 连接数组</span><br>result = np.concatenate((arr1, arr2))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;连接后的数组：&quot;</span>, result)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了两个NumPy数组 <code>arr1</code> 和 <code>arr2</code>，然后使用 <code>np.concatenate()</code> 函数将它们连接在一起。默认情况下，<code>np.concatenate()</code> 将数组沿着第一个轴（轴索引为0）连接。</p><p>运行这段代码会得到连接后的数组：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">连接后的数组： [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5 6]<br></code></pre></td></tr></table></figure><p>您还可以指定连接的轴，以便在不同的方向上连接数组。例如，您可以将它们连接在行方向（轴0）或列方向（轴1）上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在行方向上连接数组</span><br>result_row = np.concatenate((arr1, arr2), axis=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 在列方向上连接数组</span><br>result_col = np.concatenate((arr1, arr2), axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><code>numpy.concatenate</code> 是一个非常有用的函数，可以在数据处理中用于合并不同的数据集或数组。您可以通过指定轴来控制连接的方向。</p><h2 id="37-Calendar模块"><a href="#37-Calendar模块" class="headerlink" title="37. Calendar模块"></a>37. Calendar模块</h2><p>在Python中，有一个名为<code>calendar</code>的标准库模块，用于处理日期和日历信息。<code>calendar</code>模块提供了各种函数和类，可以用于生成、格式化和操作日历信息。</p><p>以下是一些<code>calendar</code>模块中常用的功能和类：</p><ol><li><p>**<code>calendar.month(year, month)</code>**：</p><p>这个函数用于生成指定年份和月份的日历。它返回一个多行字符串，表示指定月份的日历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br>year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">8</span><br><br>cal = calendar.month(year, month)<br><span class="hljs-built_in">print</span>(cal)<br></code></pre></td></tr></table></figure><p>这会生成并打印出2023年8月的日历。</p></li><li><p>**<code>calendar.month_name</code> 和 <code>calendar.day_name</code>**：</p><p>这两个变量是字符串列表，分别包含了月份名称和星期几的名称。例如，<code>calendar.month_name[1]</code> 返回 “January”，<code>calendar.day_name[3]</code> 返回 “Wednesday”。</p></li><li><p><strong><code>calendar.TextCalendar</code> 类</strong>：</p><p>这是一个类，用于生成文本日历。您可以使用它来生成指定年份和月份的日历，并以文本形式输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br>year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">8</span><br><br>cal = calendar.TextCalendar(calendar.SUNDAY)<br><span class="hljs-built_in">print</span>(cal.formatmonth(year, month))<br></code></pre></td></tr></table></figure><p>这会生成并打印出2023年8月的文本日历。</p></li><li><p><strong><code>calendar.HTMLCalendar</code> 类</strong>：</p><p>这是一个类，用于生成HTML格式的日历。它与<code>TextCalendar</code>类类似，但生成的日历以HTML表格的形式呈现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br>year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">8</span><br><br>cal = calendar.HTMLCalendar(calendar.SUNDAY)<br><span class="hljs-built_in">print</span>(cal.formatmonth(year, month))<br></code></pre></td></tr></table></figure><p>这会生成并打印出2023年8月的HTML日历。</p></li></ol><p><code>calendar</code>模块还包括其他函数和类，用于处理日期、计算日期差异、确定星期几等。这些功能使得在Python中处理日期和日历信息变得相对容易。根据具体需求，您可以选择适合您应用程序的方法和类。</p><h3 id="1-给定日期计算周几"><a href="#1-给定日期计算周几" class="headerlink" title="1.给定日期计算周几"></a>1.给定日期计算周几</h3><p><code>calendar</code> 模块可以帮助您计算星期几，特别是给定日期的星期几。要计算星期几，您可以使用 <code>calendar.weekday(year, month, day)</code> 函数，它返回一个整数，其中0代表星期一，1代表星期二，以此类推，6代表星期日。</p><p>以下是如何使用 <code>calendar</code> 模块计算给定日期的星期几的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br><span class="hljs-comment"># 指定日期</span><br>year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">8</span><br>day = <span class="hljs-number">27</span>  <span class="hljs-comment"># 日期</span><br><br><span class="hljs-comment"># 使用 calendar.weekday() 计算星期几</span><br>weekday_index = calendar.weekday(year, month, day)<br><br><span class="hljs-comment"># 根据索引获取星期几的名称</span><br>weekdays = [<span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>, <span class="hljs-string">&quot;Sunday&quot;</span>]<br>weekday_name = weekdays[weekday_index]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;year&#125;</span>-<span class="hljs-subst">&#123;month:02d&#125;</span>-<span class="hljs-subst">&#123;day:02d&#125;</span> 是 <span class="hljs-subst">&#123;weekday_name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先指定了一个日期（2023年8月27日），然后使用 <code>calendar.weekday()</code> 函数计算星期几的索引。接着，我们创建了一个包含星期几名称的列表 <code>weekdays</code>，并根据索引获取了星期几的名称。</p><p>运行这段代码会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023-08-27 是 Sunday<br></code></pre></td></tr></table></figure><p>这表示2023年8月27日是星期日。您可以根据需要更改日期来计算不同日期的星期几。</p><h2 id="38-HTML-Parser"><a href="#38-HTML-Parser" class="headerlink" title="38.HTML Parser"></a>38.HTML Parser</h2><p><code>HTMLParser</code> 是 Python 标准库中的一个模块，用于解析HTML文档。它是一个基于事件的解析器，允许您在解析HTML文档时注册回调函数来处理不同的HTML标记和事件。</p><p>要使用 <code>HTMLParser</code>，您需要导入它并创建一个自定义的子类，该子类重写了 <code>HTMLParser</code> 中的方法，以处理HTML文档中的不同部分。以下是一个简单的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParser<br><br><span class="hljs-comment"># 创建一个自定义的HTML解析器子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHTMLParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_starttag</span>(<span class="hljs-params">self, tag, attrs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;开始标记: <span class="hljs-subst">&#123;tag&#125;</span>, 属性: <span class="hljs-subst">&#123;attrs&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_endtag</span>(<span class="hljs-params">self, tag</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结束标记: <span class="hljs-subst">&#123;tag&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># HTML文档示例</span><br>html_doc = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">    &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">    &lt;h1&gt;欢迎使用HTMLParser&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;p&gt;这是一个示例HTML文档。&lt;/p&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 创建解析器对象</span><br>parser = MyHTMLParser()<br><br><span class="hljs-comment"># 解析HTML文档</span><br>parser.feed(html_doc)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先导入了 <code>HTMLParser</code> 模块，并创建了一个名为 <code>MyHTMLParser</code> 的自定义子类，该子类继承了 <code>HTMLParser</code>。然后，我们在子类中重写了 <code>handle_starttag</code>、<code>handle_endtag</code> 和 <code>handle_data</code> 方法，以分别处理开始标记、结束标记和数据。</p><p>接着，我们创建了一个HTML文档的示例，并使用 <code>MyHTMLParser</code> 解析器对象来解析该文档。当解析器遇到HTML标记或文本数据时，将调用相应的回调函数来处理它们，然后我们在这些回调函数中打印了相应的信息。</p><p>运行这段代码会输出HTML文档中的标记和数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">开始标记: html, 属性: []<br>开始标记: head, 属性: []<br>开始标记: title, 属性: []<br>数据: 示例页面<br>结束标记: title<br>结束标记: head<br>开始标记: body, 属性: []<br>开始标记: h1, 属性: []<br>数据: 欢迎使用HTMLParser<br>结束标记: h1<br>开始标记: p, 属性: []<br>数据: 这是一个示例HTML文档。<br>结束标记: p<br>结束标记: body<br>结束标记: html<br></code></pre></td></tr></table></figure><p>这个示例演示了如何使用 <code>HTMLParser</code> 解析HTML文档并处理其中的标记和数据。您可以根据需要进一步扩展 <code>MyHTMLParser</code> 类来执行特定的操作，例如提取链接、获取文本内容等。</p><h3 id="1-handle-data"><a href="#1-handle-data" class="headerlink" title="1. handle_data"></a>1. handle_data</h3><p><code>handle_data</code> 是 <code>HTMLParser</code> 模块中的一个方法，用于处理HTML文档中的文本数据。当解析器遇到文本数据时，它会调用 <code>handle_data</code> 方法，并将文本数据作为参数传递给该方法。</p><p>以下是 <code>handle_data</code> 方法的基本用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParser<br><br><span class="hljs-comment"># 创建一个自定义的HTML解析器子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHTMLParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_data</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-keyword">if</span> data.strip():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文本数据: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># HTML文档示例</span><br>html_doc = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">    &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">    &lt;h1&gt;欢迎使用HTMLParser&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;p&gt;这是一个示例HTML文档。&lt;/p&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 创建解析器对象</span><br>parser = MyHTMLParser()<br><br><span class="hljs-comment"># 解析HTML文档</span><br>parser.feed(html_doc)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个自定义的HTML解析器子类 <code>MyHTMLParser</code>，并重写了 <code>handle_data</code> 方法。当解析器遇到HTML文档中的文本数据时，将调用此方法，并将文本数据作为参数传递给它。</p><p>在示例中，我们的解析器对象 <code>parser</code> 解析了一个包含HTML文本的示例文档。当文本数据被解析时，<code>handle_data</code> 方法会被调用，我们在该方法中打印了文本数据。</p><p>运行这段代码会输出文档中的文本数据：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">文本数据: 示例页面</span><br><span class="hljs-section">文本数据: 欢迎使用HTMLParser</span><br><span class="hljs-section">文本数据: 这是一个示例HTML文档。</span><br></code></pre></td></tr></table></figure><p>这个示例演示了如何使用 <code>handle_data</code> 方法来处理HTML文档中的文本数据。您可以在 <code>handle_data</code> 方法中执行特定的操作，例如对文本数据进行处理、提取或分析，具体取决于您的需求。</p><h3 id="2-handle-comment"><a href="#2-handle-comment" class="headerlink" title="2.handle_comment"></a>2.handle_comment</h3><p><code>handle_comment</code> 是 <code>HTMLParser</code> 模块中的一个方法，用于处理HTML文档中的注释内容。HTML注释是一种特殊的文本标记，通常用于在HTML文档中添加注释或说明性信息，这些注释对于浏览器渲染页面时通常是不可见的。</p><p>当 <code>HTMLParser</code> 解析HTML文档时遇到注释时，它会调用 <code>handle_comment</code> 方法，并将注释内容作为参数传递给该方法。</p><p>以下是一个示例，演示如何使用 <code>handle_comment</code> 方法来处理HTML文档中的注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> html.parser <span class="hljs-keyword">import</span> HTMLParser<br><br><span class="hljs-comment"># 创建一个自定义的HTML解析器子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHTMLParser</span>(<span class="hljs-title class_ inherited__">HTMLParser</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_comment</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;注释内容: <span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># HTML文档示例</span><br>html_doc = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">&lt;head&gt;</span><br><span class="hljs-string">    &lt;title&gt;示例页面&lt;/title&gt;</span><br><span class="hljs-string">&lt;/head&gt;</span><br><span class="hljs-string">&lt;body&gt;</span><br><span class="hljs-string">    &lt;h1&gt;欢迎使用HTMLParser&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;!-- 这是一个示例注释 --&gt;</span><br><span class="hljs-string">    &lt;p&gt;这是一个示例HTML文档。&lt;/p&gt;</span><br><span class="hljs-string">    &lt;!-- 这是另一个示例注释 --&gt;</span><br><span class="hljs-string">&lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 创建解析器对象</span><br>parser = MyHTMLParser()<br><br><span class="hljs-comment"># 解析HTML文档</span><br>parser.feed(html_doc)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个自定义的HTML解析器子类 <code>MyHTMLParser</code>，并重写了 <code>handle_comment</code> 方法。当解析器遇到HTML文档中的注释时，<code>handle_comment</code> 方法会被调用，并将注释内容作为参数传递给它。</p><p>运行这段代码会输出HTML文档中的注释内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">注释内容: 这是一个示例注释</span><br><span class="hljs-section">注释内容: 这是另一个示例注释</span><br></code></pre></td></tr></table></figure><p>这个示例演示了如何使用 <code>handle_comment</code> 方法来处理HTML文档中的注释。您可以在 <code>handle_comment</code> 方法中执行特定的操作，例如记录注释或提取注释中的信息，具体取决于您的需求。</p><h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h3 id="1-二维码-myqr"><a href="#1-二维码-myqr" class="headerlink" title="1.二维码(myqr)"></a>1.二维码(myqr)</h3><p><code>MyQR</code> 是一个用于生成二维码的 Python 库，它提供了许多功能，可以用于生成不同类型的二维码，包括包含链接、文本、名片等多种类型的二维码。以下是关于如何使用 <code>MyQR</code> 的详细介绍：</p><ol><li><p>安装 MyQR：</p><p>首先，您需要安装 <code>MyQR</code> 库。您可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install myqr<br></code></pre></td></tr></table></figure></li><li><p>生成包含链接的二维码：</p><p>下面是一个示例，演示如何生成包含链接的二维码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MyQR <span class="hljs-keyword">import</span> myqr<br><br><span class="hljs-comment"># 设置参数</span><br>url = <span class="hljs-string">&quot;https://www.example.com&quot;</span>  <span class="hljs-comment"># 替换为您的链接</span><br>output_file = <span class="hljs-string">&quot;example_qrcode.png&quot;</span>  <span class="hljs-comment"># 输出的二维码文件名</span><br><br><span class="hljs-comment"># 生成二维码</span><br>myqr.run(url, save_name=output_file)<br></code></pre></td></tr></table></figure></li><li><p>生成包含文本的二维码：</p><p>您可以使用 <code>myqr.run()</code> 函数生成包含文本的二维码。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MyQR <span class="hljs-keyword">import</span> myqr<br><br><span class="hljs-comment"># 设置参数</span><br>text = <span class="hljs-string">&quot;Hello, World!&quot;</span>  <span class="hljs-comment"># 替换为您的文本</span><br>output_file = <span class="hljs-string">&quot;text_qrcode.png&quot;</span>  <span class="hljs-comment"># 输出的二维码文件名</span><br><br><span class="hljs-comment"># 生成文本二维码</span><br>myqr.run(words=text, save_name=output_file)<br></code></pre></td></tr></table></figure></li><li><p>生成名片二维码：</p><p><code>MyQR</code> 也支持生成包含名片信息的二维码，用于联系信息共享。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> MyQR <span class="hljs-keyword">import</span> myqr<br><br><span class="hljs-comment"># 设置名片信息</span><br>name = <span class="hljs-string">&quot;John Doe&quot;</span><br>title = <span class="hljs-string">&quot;Software Engineer&quot;</span><br>phone = <span class="hljs-string">&quot;123-456-7890&quot;</span><br>email = <span class="hljs-string">&quot;john.doe@example.com&quot;</span><br><br><span class="hljs-comment"># 输出的名片文件名</span><br>output_file = <span class="hljs-string">&quot;business_card_qrcode.png&quot;</span><br><br><span class="hljs-comment"># 生成名片二维码</span><br>myqr.run(<br>    <span class="hljs-string">f&quot;BEGIN:VCARD\nVERSION:3.0\nFN:<span class="hljs-subst">&#123;name&#125;</span>\nORG:<span class="hljs-subst">&#123;title&#125;</span>\nTEL:<span class="hljs-subst">&#123;phone&#125;</span>\nEMAIL:<span class="hljs-subst">&#123;email&#125;</span>\nEND:VCARD&quot;</span>,<br>    save_name=output_file<br>)<br></code></pre></td></tr></table></figure></li><li><p>更多选项：</p><p><code>MyQR</code> 还提供了许多其他选项，用于自定义生成的二维码的外观，包括颜色、形状、边距等。您可以在生成二维码时使用这些选项来满足您的需求。</p><p>您可以查看 <code>MyQR</code> 的官方文档以了解更多详细信息和选项：<a href="https://github.com/sylnsfar/qrcode">MyQR 官方文档</a>。</p></li></ol><p>这些示例涵盖了一些常见的用法，但 <code>MyQR</code> 还具有更多功能和选项，可以根据您的具体需求生成不同类型和样式的二维码。希望这个介绍能帮助您入门使用 <code>MyQR</code> 库。</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python新手做题练习网站</title>
    <link href="/2023/06/20/Python%E6%96%B0%E6%89%8B%E5%81%9A%E9%A2%98%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99/"/>
    <url>/2023/06/20/Python%E6%96%B0%E6%89%8B%E5%81%9A%E9%A2%98%E7%BB%83%E4%B9%A0%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>程序员宝藏库</strong>：<a href="https://xie.infoq.cn/link?target=https://gitee.com/sharetech_lee/CS-Books-Store">https://gitee.com/sharetech_lee&#x2F;CS-Books-Store</a>  </p></blockquote><p><strong>转载自：<a href="https://xie.infoq.cn/article/8eb064c63079a48372a8e19f6">Python新手太需要了，这5个做题练习网站爱了！_Jackpop_InfoQ写作社区</a></strong></p><p>学习编程语言，练习必不可少，在练习和做题的过程中能够查漏补缺，清楚自己在理论学习过程中的不足和薄弱点，加深对于 Python 的理解和认识。</p><p>关于 Python 入门学习，我之前写过很多高赞的回答，这里不多赘述，感兴趣的可以看一下我之前的回答：</p><p>请问自学 Python 有必要买课程吗？1.8 万赞同 · 314 评论回答</p><p><img src="https://static001.geekbang.org/infoq/36/36084de9c0bcb45f0cdfd71899398fbb.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>今天就着重的给大家推荐一些适合「新手」练习的 Python 做题网站。</p><p>请注意，这里强调的是「<strong>新手</strong>」，所以，上来就推 leetcode、牛客、codewar 的同学就省省吧，别把新手引导入坑了。</p><p>上述这些网站主要面向的是求职面试刷题使用，更加偏重<strong>算法与数据结构</strong>，使用这些网站的前提是你已经非常熟练一门编程语言，能够轻松通过编程语言实现自己的算法和过程，压根不适合新手练习 Python！！！</p><p>下面，就来给大家推荐 5 个真正适合 Python 新手练习做题的网站。</p><p><a href="https://xie.infoq.cn/link?target=https://www.learnpython.org/en/Welcome">1. LearnPython</a>  </p><hr><p>LearnPython 是 DataCamp 基于经典 Python 入门教程推出的一款免费在校学习和练习 Python 的网站。</p><p>它具有 2 方面的特点：</p><ul><li><p>理论与实践结合</p></li><li><p>交互式编码挑战</p></li></ul><p><img src="https://static001.geekbang.org/infoq/3f/3f780e249d8d97ab69501e17266dad15.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>首先从知识体系方面，它覆盖基础（循环、条件、函数、列表、字典、类等等）、数据科学（Numpy、Pandas）、进阶（生成器、匿名函数、异常等）3 大模块构成。</p><p><img src="https://static001.geekbang.org/infoq/1f/1fe2a6cb991e0a6219c94c6898dd4a73.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>在每个模块内它会将理论和练习有机的结合到一起，每讲解一一部分内容，会提供一些练习题，同时还会提供一个交互式的编码框，在这里可以直接编码、执行、获取结果，达到及时练习的效果。</p><p><a href="https://xie.infoq.cn/link?target=https://github.com/Yixiaohan/show-me-the-code">2. Python练习册</a>  </p><hr><p>Python 练习册是一个 Github 上免费开源的项目，目前已经 12.6K+颗 Star，受欢迎程度可见一斑。</p><p><img src="https://static001.geekbang.org/infoq/b4/b4954a68bcb9cee571b50f38893abd73.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>它每天提供一个小程序，它提供的练习题都是围绕加深 Python 认识和理解展开，例如，</p><ul><li><p>使用 Python 如何生成 200 个激活码？</p></li><li><p>任一个英文的纯文本文件，统计其中的单词出现的个数。</p></li><li><p>…</p></li></ul><p>这些都是 Python 中非常基础的操作，可能通过十几行甚至几行代码就可以实现。</p><p>但是，不要小看这些练习题，这些练习的都是日常工作中经常会用到的用法和操作。</p><p><a href="https://xie.infoq.cn/link?target=https://www.dataquest.io/blog/python-practice/">3. PythonPractice</a>  </p><hr><p>PythonPractice 是由 DATAQUEST 汇总整理的 74 个有助于提升 Python 水平的问题。</p><p>这 74 个问题可以说是覆盖了 Python 应用过程中高频用到的场景和用法，例如，正则表达式、日期和时间、面向对象、字典、NumPy、Matplotlib 绘图等等。</p><p><img src="https://static001.geekbang.org/infoq/2e/2ee067c3158014413ebb70d5e02bf136.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>在每个问题下面，它会先简单介绍一下理论知识，然后抛出一些问题，例如：</p><ul><li><p>如何使用线图可视化时间序列数据？</p></li><li><p>什么是相关性以及如何使用散点图将它们可视化？</p></li><li><p>如何使用条形图和直方图可视化频率分布？</p></li><li><p>如何使用 pandas 库加快我们的探索性数据可视化工作流程？</p></li><li><p>如何使用 Seaborn 的关系图可视化多个变量？</p></li></ul><p><img src="https://static001.geekbang.org/infoq/e3/e3a9180332d3a041bd6b640f65c79375.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>然后，它还会提供一个在线的编辑界面，这样你就不需要再费劲去配置开发环境，也不用把时间和精力浪费在琢磨开发环境上。可以直接在线编程实现，执行验证结果。</p><p><a href="https://xie.infoq.cn/link?target=http://aosabook.org/en/500L/">4. 500 line or less</a>  </p><hr><p>顾名思义，500 行以内完成一项练习，是一个非常经典的 Python 练习平台。</p><p>只不过，它面向的是更加偏向实践和高阶的练习。</p><p><img src="https://static001.geekbang.org/infoq/bf/bf0bd0662ec59d35f26664fbcb8554b5.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>它会涉及到一些项目端到端的全部环节，包括，模型设计、开发、测试等不同环节。</p><p>如果对 Python 已经有一定熟练程度，这个资源可以进一步提升对 Python 应用的认识高度。</p><p><a href="https://xie.infoq.cn/link?target=https://pynative.com/python-exercises-with-solutions/">5. PYnative</a>  </p><hr><p>PYnative 是一款面向 Python 开发人员的免费编码练习平台，练习涵盖 Python 基础知识、数据结构和数据分析。 截至目前，该页面包含 18 个模块的练习。</p><p><img src="https://static001.geekbang.org/infoq/15/15adaa8fb3dabf593ca4ac6d92fd5c66.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p><strong>这些 Python 练习包括什么？</strong></p><p>每个练习都包含需要练习和解决的特定 Python 主题问题，这些免费练习以 Python 作业的形式提供，解决不同程序和挑战的练习。</p><p>所有练习都在 Python 3 上进行了测试。</p><p>每个练习有 10-20 个问题，每个问题都提供了解决方案。</p><p><img src="https://static001.geekbang.org/infoq/76/760c5d6cb575b2a5b32ea08866df1194.jpeg?x-oss-process=image/resize,p_80/auto-orient,1"></p><p>当然，它同样提供了在线编辑器，可以让初学者能够用于实现并解决这些问题。</p><p><a href="https://xie.infoq.cn/link?target=https://www.the5fire.com/category/python%25E5%25AE%259E%25E6%2588%2598/">6. the5fire</a>  </p><hr><p>the5fie 是一个技术博客，它经常会更新一些 Python 实战的问题和实现，例如：</p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-practice-1.html">python项目练习一：即时标记</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-reportlab.html">python项目练习二：画幅好画</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-pro-powerfullxml.html">python项目练习三：万能的XML</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-pro4-newsagent.html">python项目练习四：新闻聚合</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project5-socketchat.html">python项目练习五：虚拟茶话会</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project6-cgi.html">python项目练习六：使用CGI进行远程编辑</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project7-board.html">python项目练习七：自定义公告板</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project8-xml-rpc.html">python项目练习八：使用XML-RPC进行远程文件共享</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project9-p2p-gui.html">python项目练习九：文件共享2-GUI版本</a>  </p><p><a href="https://xie.infoq.cn/link?target=https://link.zhihu.com/?target=https%253A//www.the5fire.com/python-project10-diy-game.html">python项目练习十：DIY街机游戏</a>  </p><p>这里面涉及的面比较广，也比较灵活，抽空可以看一下，可以找到一些比较新鲜实用的应用场景拿来练习。</p><p>最后，内容创作不易，如果觉得有帮助就点赞支持一下吧！</p><p>建议大家有空可以多浏览 Github，有很多好用的开源免费工具。但是，目前 Github 上项目多如牛毛，而且刷榜现在也非常严重，想要找到优质的项目变得越来越难。这里，给大家推荐 Github 上一个非常不错的项目《<strong>DevWeekly</strong>》，这个项目每周都会精挑细选一些优质的开源项目，涵盖 C++、JAVA、JavaScript、Python、Go 等不同编程语言。此外，还有一些开源工具、优秀的技术文章，建议大家看一下：</p><p><a href="https://xie.infoq.cn/link?target=https://gitee.com/sharetech_lee/DevWeekly">https://gitee.com/sharetech_lee&#x2F;DevWeekly</a>  </p><blockquote><p>hello，大家好，我是 Jackpop，重点大学本科毕业后保送到哈工大计算数学专业读研，有多年国内头部互联网、IT 公司工作经验，先后从事过计算机视觉、推荐系统、后端、数据等相关工作。如果同学们在<strong>升学考研、职业规划、高考志愿、简历优化、技术学习</strong>等方面有困惑，欢迎大家前来咨询！</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web应用程序-记Python学习</title>
    <link href="/2023/06/13/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%AE%B0Python%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/06/13/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E8%AE%B0Python%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>Python提供了一组开发Web应用程序的卓越工具。Django是一个<strong>Web框架</strong>——一套用于帮助开发交互式网站的工具。</p><h2 id="1-建立项目"><a href="#1-建立项目" class="headerlink" title="1.建立项目"></a>1.建立项目</h2><h3 id="1-1-建立虚拟环境"><a href="#1-1-建立虚拟环境" class="headerlink" title="1.1 建立虚拟环境"></a>1.1 建立虚拟环境</h3><p>要使用Django，首先需要建立一个虚拟工作环境。虚拟环境是系统的一个位置，你可以在其中安装包，并将其与其他Python包隔离。将项目的库与其他项目分离是有益的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m venv ll_env<br></code></pre></td></tr></table></figure><h3 id="1-2安装virtualenv"><a href="#1-2安装virtualenv" class="headerlink" title="1.2安装virtualenv"></a>1.2安装virtualenv</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install virtualenv<br></code></pre></td></tr></table></figure><h3 id="1-3激活虚拟环境"><a href="#1-3激活虚拟环境" class="headerlink" title="1.3激活虚拟环境"></a>1.3激活虚拟环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">source ll_env/<span class="hljs-built_in">bin</span>/activate<br></code></pre></td></tr></table></figure><p>这个命令运行ll_env&#x2F;bin中的脚本activate。环境处于活动状态时，环境名将包含在括号内，在这种情况下，你可以在环境中安装包，并使用已安装的包。你在ll_env中安装的包仅在该环境处于活动状态时才可用。</p><p>要停止使用虚拟环境，可以执行命令deactivate:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">deactivate<br></code></pre></td></tr></table></figure><h3 id="1-4安装Django"><a href="#1-4安装Django" class="headerlink" title="1.4安装Django"></a>1.4安装Django</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install Django<br></code></pre></td></tr></table></figure><h3 id="1-5在Django中创建项目"><a href="#1-5在Django中创建项目" class="headerlink" title="1.5在Django中创建项目"></a>1.5在Django中创建项目</h3><p>在依然处于活动的虚拟环境的情况下（ll_env包含在括号内），执行如下命令来新建一个项目:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">django-admin startproject learning_log .<br></code></pre></td></tr></table></figure><h3 id="1-6创建数据库"><a href="#1-6创建数据库" class="headerlink" title="1.6创建数据库"></a>1.6创建数据库</h3><p>Django将大部分与项目相关的信息都存储在数据库中，因此我们需要创建一个供Django使用的数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py migrate<br></code></pre></td></tr></table></figure><p>我们将修改数据库称为迁移数据库。首次执行命令migrate时，将让Django确保数据库与项目的当前状态匹配。在使用SQLite（后面将更详细地介绍）的新项目中首次执行这个命令时，Django将新建一个数据库。Django指出它将创建必要的数据库表，用于存储我们将在这个项目（Synchronize unmigrated apps，同步未迁移的应用程序）中使用的信息，再确保数据库结构与当前代码（Apply all migrations，应用所有的迁移）匹配.</p><h3 id="1-7查看项目"><a href="#1-7查看项目" class="headerlink" title="1.7查看项目"></a>1.7查看项目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py runserver<br></code></pre></td></tr></table></figure><p>Django启动一个服务器，让你能够查看系统中的项目，了解它们的工作情况。当你在浏览器中输入URL以请求网页时，该Django服务器将进行响应：生成合适的网页，并将其发送给浏览器.</p><h2 id="2创建应用程序"><a href="#2创建应用程序" class="headerlink" title="2创建应用程序"></a>2创建应用程序</h2><p>Django项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。在前面打开的终端窗口中应该还运行着runserver。请再打开一个终端窗口（或标签页），并切换到manage.py所在的目录。激活该虚拟环境，再执行命令startapp国：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">source ll_env/<span class="hljs-built_in">bin</span>/activate<br>prython manage.py startapp learning_logs<br></code></pre></td></tr></table></figure><p>命令startapp <em>appname</em>让Django建立创建应用程序所需的基础设施。如果现在查看项目目录，将看到其中新增了一个文件夹learning_logs，打开这个文件夹，其中最重要的文件是models.py、admin.py和views.py。我们将使用models.py来定义我们要在应用程序中管理的数据。</p><h3 id="2-1定义模型"><a href="#2-1定义模型" class="headerlink" title="2.1定义模型"></a>2.1定义模型</h3><p>在<code>models.py</code>中定义模型，模型告诉Django如何处理应用程序中存储的数据。在代码层面，模型就是一个类，就像前面讨论的每个类一样，包含属性和方法。</p><h3 id="2-2激活模型"><a href="#2-2激活模型" class="headerlink" title="2.2激活模型"></a>2.2激活模型</h3><p>要使用模型，必须让Django将应用程序包含到项目中。为此，打开<code>settings.py</code>将创建的应用程序回下到<code>INSTALLED_APPS</code>元组中。</p><p>接下来，需要让Django修改数据库，使其能够存储与模型相关的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py makemigrations learning_logs<br></code></pre></td></tr></table></figure><p>命令makemigrations让Django确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据.</p><p>下面来应用这种迁移，让Django替我们修改数据库:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py migrate<br></code></pre></td></tr></table></figure><h3 id="2-3Django管理网站"><a href="#2-3Django管理网站" class="headerlink" title="2.3Django管理网站"></a>2.3Django管理网站</h3><ol><li>创建超级用户</li></ol><p>Django允许你创建具备所有权限的用户——超级用户，执行下面的命令并按提示完成超级用户的创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">python manage.py createsuperuser<br><br>Username (leave blank to use <span class="hljs-string">&#x27;ehmatthes&#x27;</span>): ll_admin<br>Email address:<br>Password: <br>Password (again): <br>Superuser created successfully. <br></code></pre></td></tr></table></figure><ol start="2"><li>向管理网站注册模型</li></ol><p>Django自动在管理网站中添加了一些模型，如User和Group，但对于我们创建的模型，必须手工进行注册。在<code>admin.py</code>文件中导入新增的模型，再使用<code>admin.site.register()</code>让Django通过管理网站管理我们的模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">article_detail</span>(<span class="hljs-params">request, <span class="hljs-built_in">id</span></span>):<br>    article = ArticlePost.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-built_in">id</span>)<br>    <span class="hljs-comment"># 将markdown语法渲染成html样式</span><br>    article.body = markdown.markdown(article.body,<br>        extensions=[<br>        <span class="hljs-comment"># 包含 缩写、表格等常用扩展</span><br>        <span class="hljs-string">&#x27;markdown.extensions.extra&#x27;</span>,<br>        <span class="hljs-comment"># 语法高亮扩展</span><br>        <span class="hljs-string">&#x27;markdown.extensions.codehilite&#x27;</span>,<br>        ])<br>    context = &#123; <span class="hljs-string">&#x27;article&#x27;</span>: article &#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;article/detail.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python画国旗-五星红旗</title>
    <link href="/2023/06/12/python%E7%94%BB%E5%9B%BD%E6%97%97-%E4%BA%94%E6%98%9F%E7%BA%A2%E6%97%97/"/>
    <url>/2023/06/12/python%E7%94%BB%E5%9B%BD%E6%97%97-%E4%BA%94%E6%98%9F%E7%BA%A2%E6%97%97/</url>
    
    <content type="html"><![CDATA[<h1 id="如何用python绘制一面国旗"><a href="#如何用python绘制一面国旗" class="headerlink" title="如何用python绘制一面国旗"></a>如何用python绘制一面国旗</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>了解一些国旗的一些基本知识：</strong></p><blockquote><h3 id="旗帜图案"><a href="#旗帜图案" class="headerlink" title="旗帜图案"></a>旗帜图案</h3><p>1、五星红旗制作标准是：先将旗面划分为4个等分长方形，再将左上方长方形划分长宽15×10个方格。大五角星的中心位于该长方形上5下5、左5右10之处。大五角星外接圆的直径为6单位长度。</p><p>2、四颗小五角星的中心点，第一颗位于上2下8、左10右5，第二颗位于上4下6、左12右3，第三颗位于上7下3、左12右3，第四颗位于上9下1、左10右5之处。</p><p>3、每颗小五角星外接圆的直径均为2单位长度。四颗小五角星均有一角尖正对大五角星的中心点。</p><p>4、根据《中华人民共和国国旗法》第四条规定，制作国旗的企业由省、自治区和直辖市的人民政府指定。国旗的长宽之比为3:2。</p><h3 id="尺寸规格"><a href="#尺寸规格" class="headerlink" title="尺寸规格"></a>尺寸规格</h3><p>根据1949年9月28日中国人民政治协商会议第一届全体会议主席团公布的《国旗制法说明》，中华人民共和国国旗之通用尺度定为如下五种，各界酌情选用：</p><p>甲、长288公分，高192公分。</p><p>乙、长240公分，高160公分。</p><p>丙、长192公分，高128公分。</p><p>丁、长144公分，高96公分。</p><p>戊、长96公分，高64公分</p></blockquote><p>可以根据墨线法绘制国旗，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306121600075.webp"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-生成一个空白窗口"><a href="#1-生成一个空白窗口" class="headerlink" title="1.生成一个空白窗口"></a>1.生成一个空白窗口</h3><p>利用<code>tkinter</code>及<code>math</code>库实现，tkinter实现可视化界面，math主要用于计算坐标点；定义窗口的长跟宽，并生成一个窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> math<br><br>width = <span class="hljs-number">660</span><br>height = <span class="hljs-number">440</span><br><br>window = tk.Tk()<br>canvas = tk.Canvas(width=width, height=height)<br>canvas.pack()<br>window.title(<span class="hljs-string">&quot;五星红旗&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-画出红旗底面"><a href="#2-画出红旗底面" class="headerlink" title="2.画出红旗底面"></a>2.画出红旗底面</h3><p>生成一个红色背景的矩形，宽、高与窗口相同是为了便于后续计算中心点坐标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_rectangle</span>(<span class="hljs-params">width,height</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的长、宽画出旗面&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 确定中心点坐标</span><br>    x = width / <span class="hljs-number">2</span><br>    y = height / <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 画出红旗的矩形</span><br>    canvas.create_rectangle(x-(width/<span class="hljs-number">2</span>),y-(height/<span class="hljs-number">2</span>),x+(width/<span class="hljs-number">2</span>),y+(height/<span class="hljs-number">2</span>),outline=<span class="hljs-string">&#x27;red&#x27;</span>,fill=<span class="hljs-string">&#x27;red&#x27;</span>)<br><br>draw_rectangle(width,height)<br></code></pre></td></tr></table></figure><h3 id="3-计算五角星中心点坐标"><a href="#3-计算五角星中心点坐标" class="headerlink" title="3.计算五角星中心点坐标"></a>3.计算五角星中心点坐标</h3><blockquote><p>五星红旗制作标准是：先将旗面划分为4个等分长方形，再将左上方长方形划分长宽15×10个方格。大五角星的中心位于该长方形上5下5、左5右10之处。大五角星外接圆的直径为6单位长度。</p><p>四颗小五角星的中心点，第一颗位于上2下8、左10右5，第二颗位于上4下6、左12右3，第三颗位于上7下3、左12右3，第四颗位于上9下1、左10右5之处。</p></blockquote><p>通过下面的函数可以，根据输入的宽、高值返回指定五角星的中心点及外接圆半径值。<code>star_type</code>中的0-4分别表示大五角星及从上到到下的4颗小五角星；将宽平均分为30份、高平均分为20份，完成五角星坐标中心坐标计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_coordinates</span>(<span class="hljs-params">width,height,star_type=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的宽、高，返回一组坐标</span><br><span class="hljs-string">    star_type中的0表示返回的为大五角星的中心点坐标，</span><br><span class="hljs-string">    1-4分别为从上到下的4颗小五角星坐标</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 反回中心点坐标及半径</span><br>    <span class="hljs-keyword">if</span> star_type == <span class="hljs-number">0</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">10</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">5</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">1</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">5</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">8</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">2</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">3</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">6</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">3</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">3</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">3</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">4</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">5</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">1</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br></code></pre></td></tr></table></figure><h3 id="4-计算五角星的5个顶点坐标"><a href="#4-计算五角星的5个顶点坐标" class="headerlink" title="4.计算五角星的5个顶点坐标"></a>4.计算五角星的5个顶点坐标</h3><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306121611641.webp"></p><p>根据正五角星的数学特性，∠OEL&#x3D;18°，∠GEL&#x3D;36°，∠EOL&#x3D;72°，OE为外切圆半径就是radius，那么根据数学公式：</p><blockquote><p>sin18° &#x3D; OL &#x2F; OE  &#x3D;&gt;  OL &#x3D; sin18° * OE  或者 cos72° &#x3D;OL&#x2F;OE &#x3D;&gt; OL&#x3D;cos72° *OE<br>cos18° &#x3D; EL &#x2F; OE  &#x3D;&gt;  EL &#x3D; cos18° * OE 或者 sin72° &#x3D; EL&#x2F;OE &#x3D;&gt; EL&#x3D;sin72° *OE<br>tan36° &#x3D; GL &#x2F; EL  &#x3D;&gt;  GL &#x3D; tan36° * EL</p></blockquote><p>所以各个点的坐标计算公式如下：</p><blockquote><p>左上点</p><p>​        center_x-r*math.sin(2*math.pi&#x2F;5),<br>​        center_y-r*math.cos(2*math.pi&#x2F;5)</p><p>右上点</p><p>​        center_x+r*math.sin(2*math.pi&#x2F;5),<br>​        center_y-r*math.cos(2*math.pi&#x2F;5)</p><p>左下点</p><p>​        center_x-r*math.sin(math.pi&#x2F;5),<br>​        center_y+r*math.cos(math.pi&#x2F;5)</p><p>顶点</p><p>​        center_x,<br>​        center_y-r</p><p>右下点</p><p>​        center_x+r*math.sin(math.pi&#x2F;5),<br>​        center_y+r*math.cos(math.pi&#x2F;5)</p></blockquote><p>完整的函数可以按如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_star</span>(<span class="hljs-params">x,y,star_type=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的长、宽及返回五角星的5个点坐标&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 确定中心点坐标及半径</span><br>    tem = get_coordinates(x,y,star_type)<br>    center_x = tem[<span class="hljs-number">0</span>]<br>    center_y = tem[<span class="hljs-number">1</span>]<br>    r = tem[<span class="hljs-number">2</span>]<br><br>    points=[<br>        <span class="hljs-comment"># 左上点</span><br>        (center_x-r*math.sin(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>),<br>        center_y-r*math.cos(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 右上点</span><br>        (center_x+r*math.sin(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>),<br>        center_y-r*math.cos(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 左下点</span><br>        (center_x-r*math.sin(math.pi/<span class="hljs-number">5</span>),<br>        center_y+r*math.cos(math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 顶点</span><br>        (center_x,<br>        center_y-r),<br><br>        <span class="hljs-comment"># 右下点</span><br>        (center_x+r*math.sin(math.pi/<span class="hljs-number">5</span>),<br>        center_y+r*math.cos(math.pi/<span class="hljs-number">5</span>)),<br>    ]<br>    <span class="hljs-comment">#返回5个点的坐标组列表，中心点x、y坐标值及半径</span><br>    <span class="hljs-keyword">return</span> points,center_x,center_y,r<br></code></pre></td></tr></table></figure><h3 id="5-旋转小五角星"><a href="#5-旋转小五角星" class="headerlink" title="5.旋转小五角星"></a>5.旋转小五角星</h3><p>上面的四颗小五角星还没旋转角度，我们要计算出每个小五角星的旋转角度，首先算出大五角星外切圆圆心和每个小五角星外切圆圆心的角度，如下：</p><blockquote><p>⭐︎第一颗：Math.atan(3 &#x2F; 5) * 180 &#x2F; Math.PI ≈ 30.96°<br>⭐︎第二颗：Math.atan(1 &#x2F; 7) * 180 &#x2F; Math.PI ≈ 8.13°<br>⭐︎第三颗：Math.atan(2 &#x2F; 7) * 180 &#x2F; Math.PI ≈ 15.94°<br>⭐︎第四颗：Math.atan(4 &#x2F; 5) * 180 &#x2F; Math.PI ≈ 38.66°</p></blockquote><p>最后还要加减18°（18°为五角星外部角的一半值），得到-48.96°，-26.13°，-2.06，20.66这几个数据。代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_point</span>(<span class="hljs-params">points, center_x, center_y, angle</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对一组点进行旋转换算&quot;&quot;&quot;</span><br>    vertices = []<br>    <span class="hljs-comment">#对小五角星进行旋转</span><br>    angle_rad = math.radians(angle)<br>    cos_theta = math.cos(angle_rad)<br>    sin_theta = math.sin(angle_rad)<br>    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:<br>        rotated_x = center_x + (point[<span class="hljs-number">0</span>] - center_x) * cos_theta - (point[<span class="hljs-number">1</span>] - center_y) * sin_theta<br>        rotated_y = center_y + (point[<span class="hljs-number">0</span>] - center_x) * sin_theta + (point[<span class="hljs-number">1</span>] - center_y) * cos_theta<br>        vertices.append((rotated_x,rotated_y))<br><br>    <span class="hljs-keyword">return</span> vertices<br></code></pre></td></tr></table></figure><p>根据输入的一组坐标点，中心点X、Y及旋转角度，完成对坐标点的转换，返回一组新的坐标点。</p><h3 id="6-完成国旗的绘制"><a href="#6-完成国旗的绘制" class="headerlink" title="6.完成国旗的绘制"></a>6.完成国旗的绘制</h3><p>根据前面定义的函数，完成完整国旗的绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#画出大五角星</span><br>star0 = draw_star(width,height,<span class="hljs-number">0</span>)<br>canvas.create_polygon(star0[<span class="hljs-number">0</span>],outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第一颗小五角星</span><br>star1 = draw_star(width,height,<span class="hljs-number">1</span>)<br>canvas.create_polygon(rotate_point(star1[<span class="hljs-number">0</span>],star1[<span class="hljs-number">1</span>],star1[<span class="hljs-number">2</span>],-<span class="hljs-number">48.96</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第二颗小五角星</span><br>star2 = draw_star(width,height,<span class="hljs-number">2</span>)<br>canvas.create_polygon(rotate_point(star2[<span class="hljs-number">0</span>],star2[<span class="hljs-number">1</span>],star2[<span class="hljs-number">2</span>],-<span class="hljs-number">26.13</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第三颗小五角星</span><br>star3 = draw_star(width,height,<span class="hljs-number">3</span>)<br>canvas.create_polygon(rotate_point(star3[<span class="hljs-number">0</span>],star3[<span class="hljs-number">1</span>],star3[<span class="hljs-number">2</span>],-<span class="hljs-number">2.06</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第四颗小五角星</span><br>star4 = draw_star(width,height,<span class="hljs-number">4</span>)<br>canvas.create_polygon(rotate_point(star4[<span class="hljs-number">0</span>],star4[<span class="hljs-number">1</span>],star4[<span class="hljs-number">2</span>],<span class="hljs-number">20.66</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306121715266.webp"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成一面五星红旗，修改width跟height可以，画不同规格的红旗</span><br><br><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> math<br><br>width = <span class="hljs-number">660</span><br>height = <span class="hljs-number">440</span><br><br>window = tk.Tk()<br>canvas = tk.Canvas(width=width, height=height)<br>canvas.pack()<br>window.title(<span class="hljs-string">&quot;五星红旗&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_coordinates</span>(<span class="hljs-params">width,height,star_type=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的宽、高，返回一组坐标</span><br><span class="hljs-string">    star_type中的0表示返回的为大五角星的中心点坐标，</span><br><span class="hljs-string">    1-4分别为从上到下的4颗小五角星坐标</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 反回中心点坐标及半径</span><br>    <span class="hljs-keyword">if</span> star_type == <span class="hljs-number">0</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">10</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">5</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">3</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">1</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">5</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">8</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">2</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">3</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">6</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">3</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">3</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">3</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br>    <span class="hljs-keyword">elif</span> star_type == <span class="hljs-number">4</span>:<br>        center_x = width/<span class="hljs-number">2</span> - (width/<span class="hljs-number">30</span>*<span class="hljs-number">5</span>)<br>        center_y = height/<span class="hljs-number">2</span> - (height/<span class="hljs-number">20</span>*<span class="hljs-number">1</span>)<br>        r = (width / <span class="hljs-number">30</span>) *<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> center_x, center_y, r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_rectangle</span>(<span class="hljs-params">width,height</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的长、宽画出旗面&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 确定中心点坐标</span><br>    x = width / <span class="hljs-number">2</span><br>    y = height / <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 画出红旗的矩形</span><br>    canvas.create_rectangle(x-(width/<span class="hljs-number">2</span>),y-(height/<span class="hljs-number">2</span>),x+(width/<span class="hljs-number">2</span>),y+(height/<span class="hljs-number">2</span>),outline=<span class="hljs-string">&#x27;red&#x27;</span>,fill=<span class="hljs-string">&#x27;red&#x27;</span>)<br><br>draw_rectangle(width,height)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_star</span>(<span class="hljs-params">x,y,star_type=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据传入的长、宽及返回五角星的5个点坐标&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 确定中心点坐标及半径</span><br>    tem = get_coordinates(x,y,star_type)<br>    center_x = tem[<span class="hljs-number">0</span>]<br>    center_y = tem[<span class="hljs-number">1</span>]<br>    r = tem[<span class="hljs-number">2</span>]<br><br>    points=[<br>        <span class="hljs-comment"># 左上点</span><br>        (center_x-r*math.sin(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>),<br>        center_y-r*math.cos(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 右上点</span><br>        (center_x+r*math.sin(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>),<br>        center_y-r*math.cos(<span class="hljs-number">2</span>*math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 左下点</span><br>        (center_x-r*math.sin(math.pi/<span class="hljs-number">5</span>),<br>        center_y+r*math.cos(math.pi/<span class="hljs-number">5</span>)),<br><br>        <span class="hljs-comment"># 顶点</span><br>        (center_x,<br>        center_y-r),<br><br>        <span class="hljs-comment"># 右下点</span><br>        (center_x+r*math.sin(math.pi/<span class="hljs-number">5</span>),<br>        center_y+r*math.cos(math.pi/<span class="hljs-number">5</span>)),<br>    ]<br>    <span class="hljs-comment">#返回5个点的坐标组列表，中心点x、y坐标值及半径</span><br>    <span class="hljs-keyword">return</span> points,center_x,center_y,r<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate_point</span>(<span class="hljs-params">points, center_x, center_y, angle</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;对一组点进行旋转换算&quot;&quot;&quot;</span><br>    vertices = []<br>    <span class="hljs-comment">#对小五角星进行旋转</span><br>    angle_rad = math.radians(angle)<br>    cos_theta = math.cos(angle_rad)<br>    sin_theta = math.sin(angle_rad)<br>    <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:<br>        rotated_x = center_x + (point[<span class="hljs-number">0</span>] - center_x) * cos_theta - (point[<span class="hljs-number">1</span>] - center_y) * sin_theta<br>        rotated_y = center_y + (point[<span class="hljs-number">0</span>] - center_x) * sin_theta + (point[<span class="hljs-number">1</span>] - center_y) * cos_theta<br>        vertices.append((rotated_x,rotated_y))<br><br>    <span class="hljs-keyword">return</span> vertices<br><br><br><br><span class="hljs-comment">#画出大五角星</span><br>star0 = draw_star(width,height,<span class="hljs-number">0</span>)<br>canvas.create_polygon(star0[<span class="hljs-number">0</span>],outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第一颗小五角星</span><br>star1 = draw_star(width,height,<span class="hljs-number">1</span>)<br>canvas.create_polygon(rotate_point(star1[<span class="hljs-number">0</span>],star1[<span class="hljs-number">1</span>],star1[<span class="hljs-number">2</span>],-<span class="hljs-number">48.96</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第二颗小五角星</span><br>star2 = draw_star(width,height,<span class="hljs-number">2</span>)<br>canvas.create_polygon(rotate_point(star2[<span class="hljs-number">0</span>],star2[<span class="hljs-number">1</span>],star2[<span class="hljs-number">2</span>],-<span class="hljs-number">26.13</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第三颗小五角星</span><br>star3 = draw_star(width,height,<span class="hljs-number">3</span>)<br>canvas.create_polygon(rotate_point(star3[<span class="hljs-number">0</span>],star3[<span class="hljs-number">1</span>],star3[<span class="hljs-number">2</span>],-<span class="hljs-number">2.06</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><span class="hljs-comment">#画出第四颗小五角星</span><br>star4 = draw_star(width,height,<span class="hljs-number">4</span>)<br>canvas.create_polygon(rotate_point(star4[<span class="hljs-number">0</span>],star4[<span class="hljs-number">1</span>],star4[<span class="hljs-number">2</span>],<span class="hljs-number">20.66</span>),<br>                      outline=<span class="hljs-string">&#x27;yellow&#x27;</span>,fill=<span class="hljs-string">&#x27;yellow&#x27;</span>)<br><br>window.mainloop()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个游戏实践-python</title>
    <link href="/2023/06/09/%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%B7%B5-python/"/>
    <url>/2023/06/09/%E4%B8%80%E4%B8%AA%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%B7%B5-python/</url>
    
    <content type="html"><![CDATA[<h1 id="一个游戏实践-Python学习"><a href="#一个游戏实践-Python学习" class="headerlink" title="一个游戏实践-Python学习"></a>一个游戏实践-Python学习</h1><h2 id="0-游戏概述"><a href="#0-游戏概述" class="headerlink" title="0. 游戏概述"></a>0. 游戏概述</h2><blockquote><p>玩家控制着一艘最初出现在屏幕底部中央的飞船。玩家可以使用箭头键左右移动飞船，还可使用空格键进行射击。游戏开始时，一群外星人出现在天空中，他们在屏幕中向下移动。玩家的任务是射杀这些外星人。玩家将所有外星人都消灭干净后，将出现一群新的外星人，他们移动的速度更快。只要有外星人撞到了玩家的飞船或到达了屏幕底部，玩家就损失一艘飞船。玩家损失三艘飞船后，游戏结束。</p></blockquote><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>Pygame，这是一组功能强大而有趣的模块，可用于管理图形、动画乃至声音，让你能够更轻松地开发复杂的游戏。通过使用Pygame来处理在屏幕上绘制图像等任务，你不用考虑众多烦琐而艰难的编码工作，而是将重点放在程序的高级逻辑上.</p><p>安装Pygame包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pygame<br></code></pre></td></tr></table></figure><h2 id="2-开始游戏项目"><a href="#2-开始游戏项目" class="headerlink" title="2.开始游戏项目"></a>2.开始游戏项目</h2><h3 id="2-1创建一个空白窗口并响应用户输入"><a href="#2-1创建一个空白窗口并响应用户输入" class="headerlink" title="2.1创建一个空白窗口并响应用户输入"></a>2.1创建一个空白窗口并响应用户输入</h3><p>创建一个空的Pygame窗口，供后面用来绘制游戏元素，如飞船和外星人。我们还将让这个游戏响应用户输入、设置背景色以及加载飞船图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys <br><br><span class="hljs-keyword">import</span> pygame<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>():<br>    <span class="hljs-comment">#初始化游戏并创建一个屏幕对象</span><br>    pygame.init()<br>    screen = pygame.display.set_mode((<span class="hljs-number">1200</span>,<span class="hljs-number">800</span>))<br>    pygame.display.set_caption(<span class="hljs-string">&quot;外星入侵&quot;</span>)<br><br>    <span class="hljs-comment">#开始游戏的主循环</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>        <span class="hljs-comment">#监视键盘和鼠标事件</span><br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br><br>        <span class="hljs-comment">#让最近绘制的屏幕可见</span><br>        pygame.display.flip()<br><br>run_game()<br></code></pre></td></tr></table></figure><ul><li>行pygame.init()初始化背景设置，让Pygame能够正确地工作</li><li>调用pygame.display.set_mode()来创建一个名为screen的显示窗口，这个游戏的所有图形元素都将在其中绘制。实参(1200, 800)是一个元组，指定了游戏窗口的尺寸。通过将这些尺寸值传递给pygame.display.set_mode()，我们创建了一个宽1200像素、高800像素的游戏窗口<ul><li>对象screen是一个surface。在Pygame中，surface是屏幕的一部分，用于显示游戏元素。在这个游戏中，每个元素（如外星人或飞船）都是一个surface。display.set_mode()返回的surface表示整个游戏窗口。我们激活游戏的动画循环后，每经过一次循环都将自动重绘这个surface。</li></ul></li><li>游戏由一个while循环控制，其中包含一个事件循环以及管理屏幕更新的代码。事件是用户玩游戏时执行的操作，如按键或移动鼠标。为让程序响应事件，我们编写一个事件循环，以侦听事件，并根据发生的事件执行相应的任务。for循环就是一个事件循环</li><li>使用方法pygame.event.get()访问pygame检测到的事件，所有键盘和鼠标事件都将促使for循环运行。在这个循环中，我们将编写一系列的if语句来检测并响应特定的事件</li><li>单击游戏窗口的关闭按钮时，将检测到pygame.QUIT事件，而我们调用sys.exit()来退出游戏</li><li>调用pygame.display.flip()，命令Pygame让最近绘制的屏幕可见。<ul><li>在每次执行while循环时都绘制一个空屏幕，并擦去旧屏幕，使得只有新屏幕可见。在我们移动游戏元素时，pygame.display.flip()将不断更新屏幕，以显示元素的新位置，并在原来的位置隐藏元素，从而营造平滑移动的效果</li></ul></li></ul><h3 id="2-2设置背景色"><a href="#2-2设置背景色" class="headerlink" title="2.2设置背景色"></a>2.2设置背景色</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">```<br>    pygame.display.set_caption(<span class="hljs-string">&quot;外星入侵&quot;</span>)<br><br>    <span class="hljs-comment">#设置背景色</span><br>    bg_color = (<span class="hljs-number">230</span>,<span class="hljs-number">230</span>,<span class="hljs-number">230</span>)<br>    <span class="hljs-comment">#开始游戏的主循环</span><br>```<br>        <span class="hljs-comment">#每次循环时都重新绘制屏幕</span><br>        screen.fill(bg_color)<br>        <br>        <span class="hljs-comment">#让最近绘制的屏幕可见</span><br>        pygame.display.flip()<br>```<br></code></pre></td></tr></table></figure><ul><li>定义一个bg_color，其值为RGB颜色值</li><li>调用screen.fill()，用背景色填充屏幕</li></ul><h3 id="2-3创建设置类"><a href="#2-3创建设置类" class="headerlink" title="2.3创建设置类"></a>2.3创建设置类</h3><p>为了方便对设置的内容进行统一管理，可以将所有涉及到设置放到一个单独的模块中，以免在代码中到处添加设置。可以新增如下Settings类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;存储《外星入侵》的所有设置的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br>        <span class="hljs-comment">#屏幕设置</span><br>        self.screen_width = <span class="hljs-number">1200</span><br>        self.screen_height = <span class="hljs-number">800</span><br>        self.bg_color = (<span class="hljs-number">230</span>, <span class="hljs-number">230</span>, <span class="hljs-number">230</span>)<br></code></pre></td></tr></table></figure><p>主程序文件中，我们导入Settings类，调用pygame.init()，再创建一个Settings实例，并将其存储在变量ai_settings中。创建屏幕时，使用了ai_settings的属性screen_width和screen_height；接下来填充屏幕时，也使用了ai_settings来访问背景色</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091446882.webp"></p><h3 id="2-4添加飞船图像"><a href="#2-4添加飞船图像" class="headerlink" title="2.4添加飞船图像"></a>2.4添加飞船图像</h3><p>下面将飞船加入到游戏中。为了在屏幕上绘制玩家的飞船，我们将加载一幅图像，再使用Pygame方法blit()绘制它。</p><p><em>可以使用<a href="http://pixabay.com/%E7%AD%89%E7%BD%91%E7%AB%99%E6%8F%90%E4%BE%9B%E7%9A%84%E5%9B%BE%E5%BD%A2%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%9B%BE%E5%BD%A2%E6%97%A0%E9%9C%80%E8%AE%B8%E5%8F%AF%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%E3%80%82">http://pixabay.com/等网站提供的图形，这些图形无需许可，你可以对其进行修改。</a></em></p><p>在游戏中几乎可以使用任何类型的图像文件，但使用位图（.bmp）文件最为简单，因为Pygame默认加载位图。</p><p>选择图像时，要特别注意其背景色。请尽可能选择背景透明的图像，这样可使用图像编辑器将其背景设置为任何颜色。图像的背景色与游戏的背景色相同时，游戏看起来最漂亮；也可以将游戏的背景色设置成与图像的背景色相同。</p><h3 id="2-5创建ship类"><a href="#2-5创建ship类" class="headerlink" title="2.5创建ship类"></a>2.5创建ship类</h3><p>选择用于表示飞船的图像后，需要将其显示到屏幕上。我们将创建一个名为ship的模块，其中包含Ship类，它负责管理飞船的大部分行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>():<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,screen</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br>        self.screen = screen<br><br>        <span class="hljs-comment">#加载飞船图像并获取其外接矩形</span><br>        self.image = pygame.image.load(<span class="hljs-string">&#x27;alien_invasion/images/ship.png&#x27;</span>)<br>        self.rect = self.image.get_rect()<br>        self.screen_rect = screen.get_rect()<br><br>        <span class="hljs-comment">#将每艘新飞船放在屏幕的底部中央</span><br>        self.rect.centerx = self.screen_rect.centerx<br>        self.rect.bottom = self.screen_rect.bottom<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br>        self.screen.blit(self.image,self.rect)<br></code></pre></td></tr></table></figure><ul><li>Ship的方法__init__()接受两个参数：引用self和screen，其中后者指定了要将飞船绘制到什么地方。</li><li>调用了pygame.image.load()加载图像，这个函数返回一个表示飞船的surface，而我们将这个surface存储到了self.image中。</li><li>使用get_rect()获取相应surface的属性rect<ul><li>处理rect对象时，可使用矩形四角和中心的<em>x</em>和<em>y</em>坐标。可通过设置这些值来指定矩形的位置</li><li>要将游戏元素居中，可设置相应rect对象的属性center、centerx或centery。要让游戏元素与屏幕边缘对齐，可使用属性top、bottom、left或right；要调整游戏元素的水平或垂直位置，可使用属性x和y，它们分别是相应矩形左上角的<em>x</em>和<em>y</em>坐标。</li><li>在Pygame中，原点(0, 0)位于屏幕左上角，向右下方移动时，坐标值将增大。在1200×800的屏幕上，原点位于左上角，而右下角的坐标为(1200, 800)</li></ul></li><li>将表示屏幕的矩形存储在self.screen_rect中，再将self.rect.centerx（飞船中心的<em>x</em>坐标）设置为表示屏幕的矩形的属性centerx，并将self.rect.bottom（飞船下边缘的<em>y</em>坐标）设置为表示屏幕的矩形的属性bottom。Pygame将使用这些rect属性来放置飞船图像，使其与屏幕下边缘对齐并水平居中</li><li>定义方法blitme()，它根据self.rect指定的位置将图像绘制到屏幕上</li></ul><p><strong>在屏幕上绘制飞船</strong></p><p>在主程序中引入ship类，并调用其方法blitme()</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091510538.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091511294.webp"></p><h3 id="2-6重构模块game-fuctions"><a href="#2-6重构模块game-fuctions" class="headerlink" title="2.6重构模块game_fuctions"></a>2.6重构模块game_fuctions</h3><p>为简化既有代码的结构，使其更容易扩展，通过创建模块game_fuctions，避免主模块alien_invasion.py太长。</p><p><strong>check_events()</strong></p><p>先把管理事件的代码移到一个名为check_events()的函数中，以简化run_game()并隔离事件管理循环。通过隔离事件循环，可将事件管理与游戏的其他方面（如更新屏幕）分离.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys <br><br><span class="hljs-keyword">import</span> pygame<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_events</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;响应屏幕和鼠标事件&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br></code></pre></td></tr></table></figure><p>这个模块中导入了事件检查循环要使用的sys和pygame。当前，函数check_events()不需要任何形参，其函数体复制了alien_invasion.py的事件循环。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091519299.webp"></p><p><strong>update_screen()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_screen</span>(<span class="hljs-params">ai_settings,screen,ship</span>):<br>    <span class="hljs-comment">#每次循环时都重新绘制屏幕</span><br>    screen.fill(ai_settings.bg_color)<br>    ship.blitme()<br><br>    <span class="hljs-comment">#让最近绘制的屏幕可见</span><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091523079.webp"></p><h3 id="2-7驾驶飞船"><a href="#2-7驾驶飞船" class="headerlink" title="2.7驾驶飞船"></a>2.7驾驶飞船</h3><p>下面来让玩家能够左右移动飞船。为此，我们将编写代码，在用户按左或右箭头键时作出响应</p><p><strong>响应按键</strong></p><p>每当用户按键时，都将在Pygame中注册一个事件。事件都是通过方法pygame.event.get()获取的，因此在函数check_events()中，我们需要指定要检查哪些类型的事件。每次按键都被注册为一个KEYDOWN事件。</p><p>检测到KEYDOWN事件时，我们需要检查按下的是否是特定的键。例如，如果按下的是右箭头键，我们就增大飞船的rect.centerx值，将飞船向右移动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-comment">#向右移动飞船</span><br>        ship.rect.centerx += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>主程序更新调用的check_events()代码，将ship作为实参传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始游戏主循环</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>gf.check_events(ship)<br>gf.update_screen(ai_settings, screen, ship)<br></code></pre></td></tr></table></figure><p>现在运行alien_invasion.py，则每按右箭头键一次，飞船都将向右移动1像素</p><p><strong>允许不断移动</strong></p><p>玩家按住右箭头键不放时，我们希望飞船不断地向右移动，直到玩家松开为止。我们将让游戏检测pygame.KEYUP事件，以便玩家松开右箭头键时我们能够知道这一点；然后，我们将结合使用KEYDOWN和KEYUP事件，以及一个名为moving_right的标志来实现持续移动。</p><p>飞船不动时，标志moving_right将为False。玩家按下右箭头键时，我们将这个标志设置为True；而玩家松开时，我们将这个标志重新设置为False。</p><p>飞船的属性都由Ship类控制，因此我们将给这个类添加一个名为moving_right的属性和一个名为update()的方法。方法update()检查标志moving_right的状态，如果这个标志为True，就调整飞船的位置。每当需要调整飞船的位置时，我们都调用这个方法。</p><p>修改ship类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">    <span class="hljs-comment">#移动标志</span><br>    self.moving_right = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> self.moving_right:<br>        self.rect.centerx += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>修改game_fuctions.py模块代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-comment">#按键按下时，开始向右移动飞船</span><br>        ship.moving_right = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-comment">#按键松开时，结束向右移动飞船</span><br>        ship.moving_right = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>修改主程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>    <span class="hljs-comment">#监视键盘和鼠标事件</span><br>    gf.check_events(ship)<br>    ship.update()<br>    <span class="hljs-comment">#刷新屏幕</span><br>    gf.update_screen(ai_settings,screen,ship)<br></code></pre></td></tr></table></figure><p><strong>左右移动</strong></p><p>再次修改Ship类和函数check_events()：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091621029.webp"></p><p>修改game_fuctions.py</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091622447.webp"></p><p><strong>调整飞船的速度</strong></p><p>可以在Settings类中添加属性ship_speed_factor，用于控制飞船的速度</p><p><code>self.ship_speed_factor = 1.5</code>通过将速度设置指定为小数值，可在后面加快游戏的节奏时更细致地控制飞船的速度，然而，rect的centerx等属性只能存储整数值，因此我们需要对Ship类做些修改：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091627178.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306091629980.webp"></p><p><strong>限制飞船的活动范围</strong></p><p>修改Ship类的方法update()，使的飞船不能超出屏幕范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> self.moving_right <span class="hljs-keyword">and</span> self.rect.right &lt; self.screen_rect.right:<br>    self.center += self.ai_settings.ship_speed_factor<br><span class="hljs-keyword">if</span> self.moving_left <span class="hljs-keyword">and</span> self.rect.left &gt; <span class="hljs-number">0</span>:<br>    self.center -= self.ai_settings.ship_speed_factor<br></code></pre></td></tr></table></figure><p><strong>重构check_events()</strong></p><p>函数check_events()将越来越长，我们将其部分代码放在两个函数中：一个处理KEYDOWN事件，另一个处理KEYUP事件</p><h3 id="2-8-射击"><a href="#2-8-射击" class="headerlink" title="2.8 射击"></a>2.8 射击</h3><p>在settings中添加子弹的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#子弹的设置参数</span><br>self.bullet_speed_factor = <span class="hljs-number">1</span><br>self.bullet_width = <span class="hljs-number">3</span><br>self.bullet_height = <span class="hljs-number">15</span><br>self.bullet_color = (<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p><strong>创建Bullet类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><br><span class="hljs-keyword">from</span> pygame.sprite <span class="hljs-keyword">import</span> Sprite<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;一个对飞船发射的子弹管理的类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings,screen,ship</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在飞船的处的位置创建一个子弹对象&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>.__init__()<br>        self.screen = screen<br><br>        <span class="hljs-comment">#在（0，0）位置生成一个子弹，并移到飞船所处的位置</span><br>        self.rect = pygame.Rect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,ai_settings.bullet_width,<br>                                ai_settings.bullet_height)<br>        self.rect.centerx = ship.rect.centerx<br>        self.rect.top = ship.rect.top<br><br>        <span class="hljs-comment">#用小数表示子弹的位置</span><br>        self.y = <span class="hljs-built_in">float</span>(self.rect.y)<br><br>        self.color = ai_settings.bullet_color<br>        self.speed_factor = ai_settings.bullet_speed_factor<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span><br>        self.y -= self.speed_factor<br>        <span class="hljs-comment">#更新子弹的位置</span><br>        self.rect.y = self.y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_bullet</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;重新绘制子弹&quot;&quot;&quot;</span><br>        pygame.draw.rect(self.screen,self.color,self.rect)<br></code></pre></td></tr></table></figure><p>Bullet类继承了我们从模块pygame.sprite中导入的Sprite类。通过使用精灵，可将游戏中相关的元素编组，进而同时操作编组中的所有元素。</p><p>定义update()跟draw_bullet()两个方法，用于更新子弹的位置，并在屏幕上绘制出新的子弹。</p><p>属性speed_factor让我们能够随着游戏的进行或根据需要提高子弹的速度，以调整游戏的行为。子弹发射后，其<em>x</em>坐标始终不变，因此子弹将沿直线垂直地往上穿行。</p><p><strong>将子弹存储到编组中</strong></p><p>定义Bullet类和必要的设置后，就可以编写代码了，在玩家每次按空格键时都射出一发子弹。首先，我们将在alien_invasion.py中创建一个编组（group），用于存储所有有效的子弹，以便能够管理发射出去的所有子弹。</p><p>这个编组将是pygame.sprite.Group类的一个实例；pygame.sprite. Group类类似于列表，但提供了有助于开发游戏的额外功能。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306100903363.webp"></p><p>将bullets传递给了check_events()和update_screen()。在check_events()中，需要在玩家按空格键时处理bullets；而在update_screen()中，需要更新要绘制到屏幕上的bullets。</p><p>当你对编组调用update()时，编组将自动对其中的每个精灵调用update()，因此代码行bullets.update()将为编组bullets中的每颗子弹调用bullet.update()。</p><p><strong>开火</strong></p><p>在game_functions.py中，我们需要修改check_keydown_events()，以便在玩家按空格键时发射一颗子弹。我们无需修改check_keyup_events()，因为玩家松开空格键时什么都不会发生。我们还需修改update_screen()，确保在调用flip()前在屏幕上重绘每颗子弹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">--snip-- <br><span class="hljs-keyword">from</span> bullet <span class="hljs-keyword">import</span> Bullet <br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_keydown_events</span>(<span class="hljs-params">event, ai_settings, screen, ship, bullets</span>):<br> --snip-- <br> <span class="hljs-keyword">elif</span> event.key == pygame.K_SPACE: <br> <span class="hljs-comment"># 创建一颗子弹，并将其加入到编组bullets中</span><br> new_bullet = Bullet(ai_settings, screen, ship) <br> bullets.add(new_bullet) <br> --snip-- <br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_events</span>(<span class="hljs-params">ai_settings, screen, ship, bullets</span>):<br> <span class="hljs-string">&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span> <br> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get(): <br> --snip-- <br> <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN: <br> check_keydown_events(event, ai_settings, screen, ship, bullets) <br> --snip-- <br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_screen</span>(<span class="hljs-params">ai_settings, screen, ship, bullets</span>):<br> --snip-- <br> <span class="hljs-comment"># 在飞船和外星人后面重绘所有子弹</span><br> <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> bullets.sprites(): <br> bullet.draw_bullet() <br> ship.blitme() <br> --snip--<br></code></pre></td></tr></table></figure><p>编组bulltes传递给了check_keydown_events()。玩家按空格键时，创建一颗新子弹（一个名为new_bullet的Bullet实例），并使用方法add()将其加入到编组bullets中；代码bullets.add(new_bullet)将新子弹存储到编组bullets中。</p><p>在check_events()的定义中，我们需要添加形参bullets；调用check_keydown_events()时，我们也需要将bullets作为实参传递给它。</p><p>给在屏幕上绘制子弹的 update_screen() 添加了形参 bullets 。方法bullets.sprites()返回一个列表，其中包含编组bullets中的所有精灵。为在屏幕上绘制发射的所有子弹，我们遍历编组bullets中的精灵，并对每个精灵都调用draw_bullet()。</p><p>如果此时运行alien_invasion.py，将能够左右移动飞船，并发射任意数量的子弹。子弹在屏幕上向上穿行，抵达屏幕顶部后消失。可在settings.py中修改子弹的尺寸、颜色和速度。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306100918932.webp"></p><p><strong>删除消失的子弹</strong></p><p>子弹抵达屏幕顶端后消失，这仅仅是因为Pygame无法在屏幕外面绘制它们。这些子弹实际上依然存在，它们的<em>y</em>坐标为负数，且越来越小。这是个问题，因为它们将继续消耗内存和处理能力。</p><p>为此，我们需要检测这样的条件，即表示子弹的rect的bottom属性为零，它表明子弹已穿过屏幕顶端：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除已消失的子弹</span><br> <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> bullets.copy(): <br> <span class="hljs-keyword">if</span> bullet.rect.bottom &lt;= <span class="hljs-number">0</span>: <br> bullets.remove(bullet) <br> <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(bullets))<br></code></pre></td></tr></table></figure><p>在for循环中，不应从列表或编组中删除条目，因此必须遍历编组的副本。我们使用了方法copy()来设置for循环，这让我们能够在循环中修改bullets。我们检查每颗子弹，看看它是否已从屏幕顶端消失。如果是这样，就将其从bullets中删除。我们使用了一条print语句，以显示当前还有多少颗子弹，从而核实已消失的子弹确实删除了。</p><p><strong>限制子弹的数量</strong></p><p>很多射击游戏都对可同时出现在屏幕上的子弹数量进行限制，以鼓励玩家有目标地射击，因此可以修改settings类，并在game_fuctions中新增子弹前检查当前子弹数量是否小于设定值</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306100929748.webp"></p><p><strong>创建update_bullets()函数</strong></p><p>编写并检查子弹管理代码后，可将其移到模块game_functions中，以让主程序文件alien_invasion.py尽可能简单，在game_fuctions.py后面追加一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_bulltes</span>(<span class="hljs-params">bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;更新子弹位置，并删除已消失的子弹&quot;&quot;&quot;</span><br>    <span class="hljs-comment">#更新子弹位置</span><br>    bullets.update()<br><br>    <span class="hljs-comment">#删除消失的子弹</span><br>    <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> bullets.copy():<br>        <span class="hljs-keyword">if</span> bullet.rect.bottom &lt;= <span class="hljs-number">0</span> :<br>            bullets.remove(bullet)  <br></code></pre></td></tr></table></figure><p><strong>创建函数 fire_bullet()</strong></p><p>将发射子弹的代码移到一个独立的函数中，这样，在check_keydown_events()中只需使用一行代码来发射子弹，让elif代码块变得非常简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fire_bullet</span>(<span class="hljs-params">ai_settings,screen,ship,bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;如果还没达到子弹数量限制，就发射一个子弹&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bullets) &lt; ai_settings.bullets_allowed:<br>        new_bullet = Bullet(ai_settings,screen,ship)<br>        bullets.add(new_bullet)    <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306100941671.webp"></p><h2 id="3-外星人"><a href="#3-外星人" class="headerlink" title="3.外星人"></a>3.外星人</h2><p>首先，我们在屏幕上边缘附近添加一个外星人，然后生成一群外星人。我们让这群外星人向两边和下面移动，并删除被子弹击中的外星人。最后，我们将显示玩家拥有的飞船数量，并在玩家的飞船用完后结束游戏。</p><h3 id="3-1创建Alien类"><a href="#3-1创建Alien类" class="headerlink" title="3.1创建Alien类"></a>3.1创建Alien类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> pygame.sprite <span class="hljs-keyword">import</span> Sprite<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alien</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;表示单个外星人的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings,screen</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化外星人并设置其初始位置&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.screen = screen<br>        self.ai_settings = ai_settings<br><br>        <span class="hljs-comment">#加载外星人图像并获取其外接矩形</span><br>        self.image = pygame.image.load(ai_settings.alien_image)<br>        self.rect = self.image.get_rect()<br>        self.screen_rect = screen.get_rect()<br><br>        <span class="hljs-comment">#每个外星人都在左上角附近</span><br>        self.rect.x = self.rect.width<br>        self.rect.y = self.rect.height<br><br>        <span class="hljs-comment">#在外星人的准备位置</span><br>        self.x = <span class="hljs-built_in">float</span>(self.rect.x)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br>        self.screen.blit(self.image,self.rect)<br></code></pre></td></tr></table></figure><p>除位置不同外，这个类的大部分代码都与Ship类相似。每个外星人最初都位于屏幕左上角附近，我们将每个外星人的左边距都设置为外星人的宽度，并将上边距设置为外星人的高度</p><p><strong>创建Alien实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(): <br> --snip-- <br> <span class="hljs-comment"># 创建一个外星人</span><br> alien = Alien(ai_settings, screen) <br> <span class="hljs-comment"># 开始游戏主循环</span><br> <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br> gf.check_events(ai_settings, screen, ship, bullets) <br> ship.update() <br> gf.update_bullets(bullets) <br> gf.update_screen(ai_settings, screen, ship, alien, bullets)<br></code></pre></td></tr></table></figure><p>导入了新创建的Alien类，并在进入主while循环前创建了一个Alien实例。我们没有修改外星人的位置，因此该while循环没有任何新东西，但我们修改了对update_screen()的调用，传递了一个外星人实例</p><p><strong>让外星人出现在屏幕上</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_screen</span>(<span class="hljs-params">ai_settings, screen, ship, alien, bullets</span>): <br> --snip-- <br> <br> <span class="hljs-comment"># 在飞船和外星人后面重绘所有的子弹</span><br> <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> bullets: <br> bullet.draw_bullet() <br> ship.blitme() <br> alien.blitme() <br> <br> <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br> pygame.display.flip()<br></code></pre></td></tr></table></figure><p>先绘制飞船和子弹，再绘制外星人，让外星人在屏幕上位于最前面</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306101048326.webp"></p><h3 id="3-2创建一群外星人"><a href="#3-2创建一群外星人" class="headerlink" title="3.2创建一群外星人"></a>3.2创建一群外星人</h3><p>要绘制一群外星人，需要确定一行能容纳多少个外星人以及要绘制多少行外星人。我们将首先计算外星人之间的水平间距，并创建一行外星人，再确定可用的垂直空间，并创建整群外星人</p><p><code>available_space_x = ai_settings.screen_width – (2 * alien_width)</code>:为确定一行可容纳多少个外星人，我们来看看可用的水平空间有多大。屏幕宽度存储在ai_settings.screen_width中，但需要在屏幕两边都留下一定的边距，把它设置为外星人的宽度。由于有两个边距，因此可用于放置外星人的水平空间为屏幕宽度减去外星人宽度的两倍</p><p><code>number_aliens_x = available_space_x / (2 * alien_width) </code>:我们还需要在外星人之间留出一定的空间，即外星人宽度。因此，显示一个外星人所需的水平空间为外星人宽度的两倍：一个宽度用于放置外星人，另一个宽度为外星人右边的空白区域。为确定一行可容纳多少个外星人，我们将可用空间除以外星人宽度的两倍</p><p><strong>创建多行外星人</strong></p><p>为创建一行外星人，首先在alien_invasion.py中创建一个名为aliens的空编组，用于存储全部外星人，再调用game_functions.py中创建外星人群的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建一个用于存储外星人的编组</span><br>   aliens = Group()<br>   <span class="hljs-comment">#创建外星人群</span><br>   gf.create_fleet(ai_settings,screen,aliens)<br><br>   <span class="hljs-comment">#开始游戏的主循环</span><br>   <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>       <span class="hljs-comment">#监视键盘和鼠标事件</span><br>       gf.check_events(ai_settings,screen,ship,bullets)        <br>       ship.update()<br><br>       gf.update_bulltes(bullets)<br><br>       <span class="hljs-comment">#刷新屏幕</span><br>       gf.update_screen(ai_settings,screen,ship,aliens,bullets)<br></code></pre></td></tr></table></figure><ul><li>创建了一个空编组，用于存储所有的外星人。</li><li>调用稍后将编写的函数create_fleet()，并将ai_settings、对象screen和空编组aliens传递给它。</li><li>修改对update_screen()的调用，让它能够访问外星人编组</li></ul><p><strong>创建外星人群</strong></p><p>新函数create_fleet()，我们将它放在game_functions. py的末尾。我们还需要导入Alien类，因此务必在文件game_functions.py开头添加相应的import语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_fleet</span>(<span class="hljs-params">ai_settings,screen,aliens</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建外星人群&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建一个外星人，并计算一行可容纳多少个外星人</span><br>    <span class="hljs-comment"># 外星人间距为外星人宽度</span><br>    alien = Alien(ai_settings, screen)<br>    alien_width = alien.rect.width<br>    available_space_x = ai_settings.screen_width - <span class="hljs-number">2</span> * alien_width<br>    number_aliens_x = <span class="hljs-built_in">int</span>(available_space_x / (<span class="hljs-number">2</span> * alien_width))<br><br>    <span class="hljs-comment">#创建一行外星人</span><br>    <span class="hljs-keyword">for</span> alien_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_aliens_x):<br>        <span class="hljs-comment"># 创建一个外星人并将其加入当前行</span><br>        alien = Alien(ai_settings,screen)<br>        alien.x = alien_width + <span class="hljs-number">2</span>*alien_width*alien_number<br>        alien.rect.x = alien.x<br>        aliens.add(alien)<br></code></pre></td></tr></table></figure><p><strong>重构create_fleet()</strong></p><p>将create_fleet()函数拆分为get_number_aliens_x()和create_alien():</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_fleet</span>(<span class="hljs-params">ai_settings,screen,aliens</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建外星人群&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建一个外星人，并计算一行可容纳多少个外星人</span><br>    <span class="hljs-comment"># 外星人间距为外星人宽度</span><br>    alien = Alien(ai_settings, screen)<br>    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)<br>    <span class="hljs-keyword">for</span> alien_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_aliens_x): <br>        create_alien(ai_settings, screen, aliens, alien_number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_number_aliens_x</span>(<span class="hljs-params">ai_settings,alien_width</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算每行可容纳多少个外星人&quot;&quot;&quot;</span><br>    available_space_x = ai_settings.screen_width - <span class="hljs-number">2</span> * alien_width<br>    number_aliens_x = <span class="hljs-built_in">int</span>(available_space_x / (<span class="hljs-number">2</span> * alien_width))<br>    <span class="hljs-keyword">return</span> number_aliens_x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_alien</span>(<span class="hljs-params">ai_settings,screen,aliens,alien_number</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;</span><br>    alien = Alien(ai_settings, screen) <br>    alien_width = alien.rect.width<br>    alien.x = alien_width + <span class="hljs-number">2</span> * alien_width * alien_number <br>    alien.rect.x = alien.x <br>    aliens.add(alien)<br></code></pre></td></tr></table></figure><ul><li>函数get_number_aliens_x()的代码都来自create_fleet()，且未做任何修改。</li><li>函数create_alien()的代码也都来自create_fleet()，且未做任何修改，只是使用刚创建的外星人来获取外星人宽度。</li><li>我们将计算可用水平空间的代码替换为对get_number_aliens_x()的调用，并删除了引用alien_width的代码行，因为现在这是在create_alien()中处理的。然后调用create_alien()。</li></ul><p><strong>添加行</strong></p><p>要创建外星人群，需要计算屏幕可容纳多少行，并对创建一行外星人的循环重复相应的次数.</p><p>为计算可容纳的行数，我们这样计算可用垂直空间：将屏幕高度减去第一行外星人的上边距（外星人高度）、飞船的高度以及最初外星人群与飞船的距离（外星人高度的两倍）：</p><blockquote><p>available_space_y &#x3D; ai_settings.screen_height – 3 * alien_height – ship_height </p></blockquote><p>每行下方都要留出一定的空白区域，并将其设置为外星人的高度。为计算可容纳的行数，我们将可用垂直空间除以外星人高度的两倍（同样，如果这样的计算不对，我们马上就能发现，继而将间距调整为合理的值）。</p><blockquote><p>number_rows &#x3D; available_height_y &#x2F; (2 * alien_height) </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_fleet</span>(<span class="hljs-params">ai_settings,screen,ship,aliens</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建外星人群&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建一个外星人，并计算一行可容纳多少个外星人</span><br>    <span class="hljs-comment"># 外星人间距为外星人宽度</span><br>    alien = Alien(ai_settings, screen)<br>    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)<br>    number_rows = get_number_aliens_row(ai_settings,ship.rect.height,alien.rect.height)<br>    <span class="hljs-keyword">for</span> row_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_rows):<br>        <span class="hljs-keyword">for</span> alien_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(number_aliens_x): <br>            create_alien(ai_settings, screen, aliens, alien_number,row_number)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_number_aliens_x</span>(<span class="hljs-params">ai_settings,alien_width</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算每行可容纳多少个外星人&quot;&quot;&quot;</span><br>    available_space_x = ai_settings.screen_width - <span class="hljs-number">2</span> * alien_width<br>    number_aliens_x = <span class="hljs-built_in">int</span>(available_space_x / (<span class="hljs-number">2</span> * alien_width))<br>    <span class="hljs-keyword">return</span> number_aliens_x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_number_aliens_row</span>(<span class="hljs-params">ai_settings,ship_height,alien_height</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;计算可容纳多少行外星人&quot;&quot;&quot;</span><br>    available_apace_y = ai_settings.screen_height - <span class="hljs-number">3</span> * alien_height - ship_height<br>    number_rows = <span class="hljs-built_in">int</span>(available_apace_y / (<span class="hljs-number">2</span> * alien_height))<br>    <span class="hljs-keyword">return</span> number_rows<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_alien</span>(<span class="hljs-params">ai_settings,screen,aliens,alien_number,row_number</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;</span><br>    alien = Alien(ai_settings, screen) <br>    alien_width = alien.rect.width<br>    alien.x = alien_width + <span class="hljs-number">2</span> * alien_width * alien_number <br>    alien.rect.x = alien.x <br>    alien.rect.y = alien.rect.height + <span class="hljs-number">2</span> * alien.rect.height * row_number<br>    aliens.add(alien)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306101544095.webp"></p><h3 id="3-3让外星人移动"><a href="#3-3让外星人移动" class="headerlink" title="3.3让外星人移动"></a>3.3让外星人移动</h3><p>下面来让外星人群在屏幕上向右移动，撞到屏幕边缘后下移一定的距离，再沿相反的方向移动。我们将不断地移动所有的外星人，直到所有外星人都被消灭，有外星人撞上飞船，或有外星人抵达屏幕底端</p><p><strong>向右移动外星人</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>): <br> <span class="hljs-string">&quot;&quot;&quot;向右移动外星人&quot;&quot;&quot;</span> <br> self.x += self.ai_settings.alien_speed_factor <br> self.rect.x = self.x<br></code></pre></td></tr></table></figure><p>在settings.py类中增加外星人的移动速度<code>ai_settings.alien_speed_factor </code></p><p>在game_fuctions.py中增加函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_aliens</span>(<span class="hljs-params">aliens</span>): <br> <span class="hljs-string">&quot;&quot;&quot;更新外星人群中所有外星人的位置&quot;&quot;&quot;</span> <br> aliens.update()<br></code></pre></td></tr></table></figure><p><strong>增加移动方向设置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 外星人设置</span><br>self.alien_speed_factor = <span class="hljs-number">1</span> <br>self.fleet_drop_speed = <span class="hljs-number">10</span> <br><span class="hljs-comment"># fleet_direction为1表示向右移，为-1表示向左移</span><br>self.fleet_direction = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>设置fleet_drop_speed指定了有外星人撞到屏幕边缘时，外星人群向下移动的速度。将这个速度与水平速度分开是有好处的，这样你就可以分别调整这两种速度了。</p><p>要实现fleet_direction设置，可以将其设置为文本值，如’left’或’right’，但这样就必须编写if-elif语句来检查外星人群的移动方向。鉴于只有两个可能的方向，我们使用值1和-1来表示它们，并在外星人群改变方向时在这两个值之间切换。</p><p>另外，鉴于向右移动时需要增大每个外星人的<em>x</em>坐标，而向左移动时需要减小每个外星人的<em>x</em>坐标，使用数字来表示方向更合理.</p><p><strong>检查是否撞到屏幕</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_edges</span>(<span class="hljs-params">self</span>): <br> <span class="hljs-string">&quot;&quot;&quot;如果外星人位于屏幕边缘，就返回True&quot;&quot;&quot;</span> <br> screen_rect = self.screen.get_rect() <br> <span class="hljs-keyword">if</span> self.rect.right &gt;= screen_rect.right: <br> <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br> <span class="hljs-keyword">elif</span> self.rect.left &lt;= <span class="hljs-number">0</span>: <br> <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br> <br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>): <br> <span class="hljs-string">&quot;&quot;&quot;向左或向右移动外星人&quot;&quot;&quot;</span> <br> self.x += (self.ai_settings.alien_speed_factor * <br> self.ai_settings.fleet_direction) <br> self.rect.x = self.x<br></code></pre></td></tr></table></figure><p>我们可对任何外星人调用新方法check_edges()，看看它是否位于屏幕左边缘或右边缘。如果外星人的rect的right属性大于或等于屏幕的rect的right属性，就说明外星人位于屏幕右边缘。如果外星人的rect的left属性小于或等于0，就说明外星人位于屏幕左边缘。</p><p>修改了方法update()，将移动量设置为外星人速度和fleet_direction的乘积，让外星人向左或向右移。如果fleet_direction为1，就将外星人当前的<em>x</em>坐标增大alien_speed_factor，从而将外星人向右移；如果fleet_direction为，就将外星人当前的<em>x</em>坐标减去alien_speed_factor，从而将外星人向左移。</p><p><strong>向下移动</strong></p><p>有外星人到达屏幕边缘时，需要将整群外星人下移，并改变它们的移动方向。需要对game_functions.py做重大修改，因为我们要在这里检查是否有外星人到达了左边缘或右边缘。为此，我们编写函数check_fleet_edges()和change_fleet_direction()，并对update_aliens()进行修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_fleet_edges</span>(<span class="hljs-params">ai_settings, aliens</span>): <br> <span class="hljs-string">&quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot;</span> <br> <span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens.sprites(): <br> <span class="hljs-keyword">if</span> alien.check_edges(): <br> change_fleet_direction(ai_settings, aliens) <br> <span class="hljs-keyword">break</span> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_fleet_direction</span>(<span class="hljs-params">ai_settings, aliens</span>): <br> <span class="hljs-string">&quot;&quot;&quot;将整群外星人下移，并改变它们的方向&quot;&quot;&quot;</span> <br> <span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens.sprites():<br> alien.rect.y += ai_settings.fleet_drop_speed <br> ai_settings.fleet_direction *= -<span class="hljs-number">1</span><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_aliens</span>(<span class="hljs-params">ai_settings, aliens</span>): <br> <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string"> 检查是否有外星人位于屏幕边缘，并更新整群外星人的位置</span><br><span class="hljs-string"> &quot;&quot;&quot;</span><br> check_fleet_edges(ai_settings, aliens)<br> aliens.update()<br></code></pre></td></tr></table></figure><p>在check_fleet_edges()中，我们遍历外星人群，并对其中的每个外星人调用check_edges()。如果check_edges()返回True，我们就知道相应的外星人位于屏幕边缘，需要改变外星人群的方向，因此我们调用change_fleet_direction()并退出循环。在change_fleet_direction()中，我们遍历所有外星人，将每个外星人下移fleet_drop_speed设置的值；然后，将fleet_direction的值修改为其当前值与-1的乘积。</p><p>我们修改了函数update_aliens()，在其中通过调用check_fleet_edges()来确定是否有外星人位于屏幕边缘。现在，函数update_aliens()包含形参ai_settings，因此我们调用它时指定了与ai_settings对应的实参。</p><h3 id="3-4射杀外星人"><a href="#3-4射杀外星人" class="headerlink" title="3.4射杀外星人"></a>3.4射杀外星人</h3><p>游戏编程中，碰撞指的是游戏元素重叠在一起。要让子弹能够击落外星人，我们将使用sprite.groupcollide()检测两个编组的成员之间的碰撞。</p><p><strong>检测子弹与外星人的碰撞</strong></p><p>方法sprite.groupcollide()将每颗子弹的rect同每个外星人的rect进行比较，并返回一个字典，其中包含发生了碰撞的子弹和外星人。在这个字典中，每个键都是一颗子弹，而相应的值都是被击中的外星人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_bullets</span>(<span class="hljs-params">aliens, bullets</span>): <br> <span class="hljs-string">&quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;</span> <br> --snip-- <br> <span class="hljs-comment"># 检查是否有子弹击中了外星人</span><br> <span class="hljs-comment"># 如果是这样，就删除相应的子弹和外星人</span><br> collisions = pygame.sprite.groupcollide(bullets, aliens, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>新增的这行代码遍历编组bullets中的每颗子弹，再遍历编组aliens中的每个外星人。每当有子弹和外星人的rect重叠时，groupcollide()就在它返回的字典中添加一个键-值对。两个实参True告诉Pygame删除发生碰撞的子弹和外星人(要模拟能够穿行到屏幕顶端的高能子弹——消灭它击中的每个外星人，可将第一个布尔实参设置为False，并让第二个布尔实参为True。这样被击中的外星人将消失，但所有的子弹都始终有效，直到抵达屏幕顶端后消失。)</p><p><strong>为测试创建大子弹</strong></p><p>测试有些功能时，可以修改游戏的某些设置，以便专注于游戏的特定方面。例如，可以缩小屏幕以减少需要击落的外星人数量，也可以提高子弹的速度，以便能够在单位时间内发射大量子弹。</p><p><strong>生成新的外星人群</strong></p><p>要在外星人群被消灭后又显示一群外星人，首先需要检查编组aliens是否为空。如果为空，就调用create_fleet()。我们将在update_bullets()中执行这种检查，因为外星人都是在这里被消灭的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(aliens) == <span class="hljs-number">0</span>:<br>    <span class="hljs-comment"># 删除现有的子弹并生成新的外星人群</span><br>    bullets.empty()<br>    create_fleet(ai_settings,screen,ship,aliens)<br></code></pre></td></tr></table></figure><p><strong>提高子弹速度</strong></p><p>如果你现在尝试在这个游戏中射杀外星人，可能发现子弹的速度比以前慢，这是因为在每次循环中， Pygame 需要做的工作更多了。为提高子弹的速度，可调整 settings.py 中bullet_speed_factor的值。</p><p><strong>重构update_bullets()</strong></p><p>下面来重构update_bullets()，使其不再完成那么多任务。我们将把处理子弹和外星人碰撞的代码移到一个独立的函数中</p><h3 id="3-5结束游戏"><a href="#3-5结束游戏" class="headerlink" title="3.5结束游戏"></a>3.5结束游戏</h3><p><strong>检测外星人与飞船的碰撞</strong></p><p>我们首先检查外星人和飞船之间的碰撞，以便外星人撞上飞船时我们能够作出合适的响应。我们在更新每个外星人的位置后立即检测外星人和飞船之间的碰撞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_aliens</span>(<span class="hljs-params">ai_settings,ship,aliens</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;更新外星人的位置&quot;&quot;&quot;</span><br>    check_fleet_edges(ai_settings,aliens)<br>    aliens.update()<br><br>    <span class="hljs-comment"># 检测外星人与飞船的碰撞</span><br>    <span class="hljs-keyword">if</span> pygame.sprite.groupcollide(ship,aliens):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;飞船被击中啦！&#x27;</span>)<br></code></pre></td></tr></table></figure><p>方法spritecollideany()接受两个实参：一个精灵和一个编组。它检查编组是否有成员与精灵发生了碰撞，并在找到与精灵发生了碰撞的成员后就停止遍历编组。在这里，它遍历编组aliens，并返回它找到的第一个与飞船发生了碰撞的外星人。</p><p>如果没有发生碰撞，spritecollideany()将返回None，因此Ø处的if代码块不会执行。如果找到了与飞船发生碰撞的外星人，它就返回这个外星人，因此if代码块将执行：打印“Ship hit!!!”。（有外星人撞到飞船时，需要执行的任务很多：需要删除余下的所有外星人和子弹，让飞船重新居中，以及创建一群新的外星人。</p><p><strong>响应外星人与飞船的碰撞</strong></p><p>现在需要确定外星人与飞船发生碰撞时，该做些什么。我们不销毁ship实例并创建一个新的ship实例，而是通过跟踪游戏的统计信息来记录飞船被撞了多少次（跟踪统计信息还有助于记分）。</p><p>下面来编写一个用于跟踪游戏统计信息的新类——GameStats，并将其保存为文件game_stats.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameStats</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;</span><br>        self.ai_settings = ai_settings<br>        self.reset_stats()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset_stats</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;</span><br>        self.ships_left = self.ai_settings.ship_limit<br></code></pre></td></tr></table></figure><p>在这个游戏运行期间，我们只创建一个GameStats实例，但每当玩家开始新游戏时，需要重置一些统计信息。为此，我们在方法reset_stats()中初始化大部分统计信息，而不是在__init__()中直接初始化它们。我们在__init__()中调用这个方法，这样创建GameStats实例时将妥善地设置这些统计信息，同时在玩家开始新游戏时也能调用reset_stats()。</p><p>当前只有一项统计信息——ships_left，其值在游戏运行期间将不断变化。一开始玩家拥有的飞船数存储在settings.py的ship_limit中.</p><p>我们还需对alien_invasion.py做些修改，以创建一个GameStats实例：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306102019847.webp"></p><p>我们导入了新类GameStats，创建了一个名为stats的实例，再调用update_aliens()并添加了实参stats、screen和ship。在有外星人撞到飞船时，我们将使用这些实参来跟踪玩家还有多少艘飞船，以及创建一群新的外星人.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_aliens</span>(<span class="hljs-params">ai_settings,stats,screen,ship,aliens</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;更新外星人的位置&quot;&quot;&quot;</span><br>    check_fleet_edges(ai_settings,aliens)<br>    aliens.update()<br><br>    <span class="hljs-comment"># 检测外星人与飞船的碰撞</span><br>    <span class="hljs-keyword">if</span> pygame.sprite.spritecollideany(ship,aliens):<br>        ship_hit(ai_settings,screen,ship,aliens)<br>        <span class="hljs-comment"># print(f&#x27;飞船被击中啦！&#x27;)</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ship_hit</span>(<span class="hljs-params">ai_settings, stats, screen, ship, aliens, bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应被外星人碰撞到的飞船&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 将ships_left减1</span><br>    stats.ships_left -= <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">#清空外星人列表和子弹列表</span><br>    aliens.empty()<br>    bullets.empty()<br><br>    <span class="hljs-comment">#创建一群外星人，并将飞船放到屏幕底端中央</span><br>    create_fleet(ai_settings,screen,ship,aliens)<br>    ship.center_ship()<br><br>    <span class="hljs-comment"># 暂停</span><br>    sleep(<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>我们首先从模块time中导入了函数sleep()，以便使用它来让游戏暂停。新函数ship_hit()在飞船被外星人撞到时作出响应。在这个函数内部，将余下的飞船数减1，然后清空编组aliens和bullets。</p><p>接下来，我们创建一群新的外星人，并将飞船居中，稍后将在Ship类中添加方法center_ship()。最后，我们更新所有元素后（但在将修改显示到屏幕前）暂停，让玩家知道其飞船被撞到了。屏幕将暂时停止变化，让玩家能够看到外星人撞到了飞船。函数sleep()执行完毕后，将接着执行函数update_screen().</p><p>更新了update_aliens()的定义，使其包含形参stats、screen和bullets，让它能够在调用ship_hit()时传递这些值.</p><p><strong>有外星人到达屏幕底端</strong></p><p>如果有外星人到达屏幕底端，我们将像有外星人撞到飞船那样作出响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_aliens_bottom</span>(<span class="hljs-params">ai_settings, stats,screen,ship,aliens,bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;检测是否有外星人抵达屏幕底端&quot;&quot;&quot;</span><br>    screen_rect = screen.get_rect()<br>    <span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens.sprites():<br>        <span class="hljs-keyword">if</span> alien.rect.bottom &gt;= screen_rect.bottom:<br>            <span class="hljs-comment">#像与飞船碰撞一样的处理</span><br>            ship_hit(ai_settings,stats,screen,ship,aliens,bullets)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>函数check_aliens_bottom()检查是否有外星人到达了屏幕底端。到达屏幕底端后，外星人的属性rect.bottom的值大于或等于屏幕的属性rect.bottom的值。如果有外星人到达屏幕底端，我们就调用ship_hit()；只要检测到一个外星人到达屏幕底端，就无需检查其他外星人，因此我们在调用ship_hit()后退出循环。</p><p>我们在更新所有外星人的位置并检测是否有外星人和飞船发生碰撞后调用check_aliens_bottom()</p><p><strong>结束游戏</strong></p><p>现在这个游戏看起来更完整了，但它永远都不会结束，只是ships_left不断变成更小的负数。</p><p>下面在GameStats中添加一个作为标志的属性game_active，以便在玩家的飞船用完后结束游戏.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, settings</span>): <br>--snip-- <br><span class="hljs-comment"># 游戏刚启动时处于活动状态</span><br>self.game_active = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>现在在ship_hit()中添加代码，在玩家的飞船都用完后将game_active设置为False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">ship_hit</span>(<span class="hljs-params">ai_settings, stats, screen, ship, aliens, bullets</span>): <br> <span class="hljs-string">&quot;&quot;&quot;响应飞船被外星人撞到&quot;&quot;&quot;</span> <br> <span class="hljs-keyword">if</span> stats.ships_left &gt; <span class="hljs-number">0</span>: <br>     <span class="hljs-comment"># 将ships_left减1 </span><br>     stats.ships_left -= <span class="hljs-number">1</span> <br>     --snip-- <br>     <span class="hljs-comment">#暂停一会儿</span><br>     sleep(<span class="hljs-number">0.5</span>) <br> <span class="hljs-keyword">else</span>: <br> stats.game_active = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><strong>确定应运行游戏的哪个部分</strong></p><p>在alien_invasion.py中，我们需要确定游戏的哪些部分在任何情况下都应运行，哪些部分仅在游戏处于活动状态时才运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>    <span class="hljs-comment">#监视键盘和鼠标事件</span><br>    gf.check_events(ai_settings,screen,ship,bullets) <br><br>    <span class="hljs-keyword">if</span> stats.game_active:       <br>        ship.update()      <br>        gf.update_bulltes(ai_settings,screen,ship,bullets,aliens)<br>        gf.update_aliens(ai_settings, stats, screen, ship, aliens,bullets)<br><br><br>    <span class="hljs-comment">#刷新屏幕</span><br>    gf.update_screen(ai_settings,screen,ship,aliens,bullets)<br></code></pre></td></tr></table></figure><h2 id="4-记分系统"><a href="#4-记分系统" class="headerlink" title="4.记分系统"></a>4.记分系统</h2><h3 id="4-1添加PLAY按钮"><a href="#4-1添加PLAY按钮" class="headerlink" title="4.1添加PLAY按钮"></a>4.1添加PLAY按钮</h3><p>将添加一个Play按钮，它在游戏开始前出现，并在游戏结束后再次出现，让玩家能够开始新游戏</p><p>下面让游戏一开始处于非活动状态，并提示玩家单击Play按钮来开始游戏。为此，在game_stats.py中将<code>self.game_active = False</code></p><p><strong>创建button类</strong></p><p>由于Pygame没有内置创建按钮的方法，我们创建一个Button类，用于创建带标签的实心矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame.font<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span>():<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings,screen,msg</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化按钮&quot;&quot;&quot;</span><br>        self.screen = screen<br>        self.screen_rect = screen.get_rect()<br><br>        <span class="hljs-comment">#设置按钮的大小和其他属性</span><br>        self.width, self.height = <span class="hljs-number">200</span>, <span class="hljs-number">50</span><br>        self.button_color = (<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)<br>        self.text_color = (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>)<br>        self.font = pygame.font.SysFont(<span class="hljs-literal">None</span>,<span class="hljs-number">48</span>)<br><br>        <span class="hljs-comment">#创建按钮的rect对象，并使其居中</span><br>        self.rect = pygame.Rect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,self.width,self.height)<br>        self.rect.center = self.screen_rect.center<br><br>        <span class="hljs-comment">#按钮标签只需创建一次</span><br>        self.prep_msg(msg)<br></code></pre></td></tr></table></figure><p>首先，我们导入了模块pygame.font，它让Pygame能够将文本渲染到屏幕上。方法__init__()接受参数self，对象ai_settings和screen，以及msg，其中msg是要在按钮中显示的文本。</p><p>我们设置按钮的尺寸，然后通过设置button_color让按钮的rect对象为亮绿色，并通过设置text_color让文本为白色。</p><p>指定使用什么字体来渲染文本。实参None让Pygame使用默认字体，而48指定了文本的字号。</p><p>为让按钮在屏幕上居中，我们创建一个表示按钮的rect对象，并将其center属性设置为屏幕的center属性。</p><p>Pygame通过将你要显示的字符串渲染为图像来处理文本。调用prep_msg()来处理这样的渲染。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_msg</span>(<span class="hljs-params">self,msg</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;将msg渲染为图像，并使其在按钮居中&quot;&quot;&quot;</span><br>    self.msg_image = self.font.render(msg,<span class="hljs-literal">True</span>,self.text_color,<br>                                      self.button_color)<br>    self.msg_image_rect = self.msg_image.get_rect()<br>    self.msg_image_rect.center = self.rect.center<br></code></pre></td></tr></table></figure><p>调用screen.fill()来绘制表示按钮的矩形，再调用screen.blit()，并向它传递一幅图像以及与该图像相关联的rect对象，从而在屏幕上绘制文本图像</p><p><strong>在屏幕上绘制按钮</strong></p><p>使用Button类来创建一个Play按钮。鉴于只需要一个Play按钮，我们直接在alien_invasion.py中创建它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#绘制一个开始按钮</span><br>play_button = Button(ai_settings,screen,<span class="hljs-string">&#x27;Play&#x27;</span>)<br><span class="hljs-comment">#开始游戏的主循环</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>    <span class="hljs-comment">#监视键盘和鼠标事件</span><br>    gf.check_events(ai_settings,screen,ship,bullets) <br><br>    <span class="hljs-keyword">if</span> stats.game_active:       <br>        ship.update()      <br>        gf.update_bulltes(ai_settings,screen,ship,bullets,aliens)<br>        gf.update_aliens(ai_settings, stats, screen, ship, aliens,<br>                         bullets)<br><br><br>    <span class="hljs-comment">#刷新屏幕</span><br>    gf.update_screen(ai_settings,screen,stats,ship,aliens,bullets,<br>                     play_button)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306102120748.webp"></p><p><strong>开始游戏</strong></p><p>为在玩家单击Play按钮时开始新游戏，需在game_functions.py中添加如下代码，以监视与这个按钮相关的鼠标事件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_events</span>(<span class="hljs-params">ai_settings,screen,stats,play_button,ship,bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应屏幕和鼠标事件&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>            check_keydown_events(event,ai_settings,screen,ship,bullets)<br><br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>            <span class="hljs-comment">#按键松开时，结束向右移动飞船</span><br>            check_keyup_events(event,ship)<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.K_q:<br>            <span class="hljs-comment">#按q退出游戏</span><br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.MOUSEBUTTONDOWN:<br>            <span class="hljs-comment">#鼠标按下</span><br>            mouse_x, mouse_y = pygame.mouse.get_pos()<br>            check_play_button(stats,play_button,mouse_x,mouse_y)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_play_button</span>(<span class="hljs-params">stats,play_button,mouse_x,mouse_y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> play_button.rect.collidepoint(mouse_x, mouse_y):<br>        stats.game_active = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>重置游戏</strong></p><p>为在玩家每次单击Play按钮时都重置游戏，需要重置统计信息、删除现有的外星人和子弹、创建一群新的外星人，并让飞船居中，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_play_button</span>(<span class="hljs-params">ai_settings,screen,stats,play_button,ship,aliens,</span><br><span class="hljs-params">                      bullets,mouse_x,mouse_y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> play_button.rect.collidepoint(mouse_x, mouse_y):<br>        <span class="hljs-comment">#重置统计信息</span><br>        stats.reset_stats()<br>        stats.game_active = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment">#清空外星人信息及子弹信息</span><br>        aliens.empty()<br>        bullets.empty()<br><br>        <span class="hljs-comment">#创建一群新的外星人和飞船，并让飞船居中</span><br>        create_fleet(ai_settings,screen,ship,aliens)<br>        ship.center_ship()<br></code></pre></td></tr></table></figure><p><strong>将 Play 按钮切换到非活动状态</strong></p><p>当前，Play按钮存在一个问题，那就是即便Play按钮不可见，玩家单击其原来所在的区域时，游戏依然会作出响应。游戏开始后，如果玩家不小心单击了Play按钮原来所处的区域，游戏将重新开始！</p><p>为修复这个问题，可让游戏仅在game_active为False时才开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_play_button</span>(<span class="hljs-params">ai_settings,screen,stats,play_button,ship,aliens,</span><br><span class="hljs-params">                      bullets,mouse_x,mouse_y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;</span><br>    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)<br>    <span class="hljs-keyword">if</span> button_clicked <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> stats.game_active:<br>        <span class="hljs-comment">#重置统计信息</span><br>        stats.reset_stats()<br>        stats.game_active = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment">#清空外星人信息及子弹信息</span><br>        aliens.empty()<br>        bullets.empty()<br><br>        <span class="hljs-comment">#创建一群新的外星人和飞船，并让飞船居中</span><br>        create_fleet(ai_settings,screen,ship,aliens)<br>        ship.center_ship()<br></code></pre></td></tr></table></figure><p>标志button_clicked的值为True或False，仅当玩家单击了Play按钮且游戏当前处于非活动状态时，游戏才重新开始。</p><p><strong>隐藏光标</strong></p><p>为让玩家能够开始游戏，我们要让光标可见，但游戏开始后，光标只会添乱。为修复这种问题，我们在游戏处于活动状态时让光标不可见：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> button_clicked <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> stats.game_active:<br>    <span class="hljs-comment"># 隐藏光标</span><br>    pygame.mouse.set_visible(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>通过向set_visible()传递False，让Pygame在光标位于游戏窗口内时将其隐藏起来</p><h3 id="4-2提高等级"><a href="#4-2提高等级" class="headerlink" title="4.2提高等级"></a>4.2提高等级</h3><p>当前，将整群外星人都消灭干净后，玩家将提高一个等级，但游戏的难度并没有变。下面来增加一点趣味性：每当玩家将屏幕上的外星人都消灭干净后，加快游戏的节奏，让游戏玩起来更难</p><p><strong>修改速度设置</strong></p><p>先重新组织Settings类，将游戏设置划分成静态的和动态的两组。对于随着游戏进行而变化的设置，我们还确保它们在开始新游戏时被重置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#以什么样的速度加快游戏节奏</span><br>self.speedup_scale = <span class="hljs-number">1.1</span><br><br>self.initialize_dynamic_settings()<br></code></pre></td></tr></table></figure><p>我们添加了设置speedup_scale，用于控制游戏节奏的加快速度：2表示玩家每提高一个等级，游戏的节奏就翻倍；1表示游戏节奏始终不变。将其设置为1.1能够将游戏节奏提高到够快，让游戏既有难度，又并非不可完成。最后，我们调用initialize_dynamic_settings()，以初始化随游戏进行而变化的属性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_dynamic_settings</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;初始化随游戏进行而变化的设置&quot;&quot;&quot;</span> <br>    self.ship_speed_factor = <span class="hljs-number">1.5</span> <br>    self.bullet_speed_factor = <span class="hljs-number">3</span> <br>    self.alien_speed_factor = <span class="hljs-number">1</span> <br>    <span class="hljs-comment"># fleet_direction为1表示向右；为-1表示向左</span><br>    self.fleet_direction = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这个方法设置了飞船、子弹和外星人的初始速度。随游戏的进行，我们将提高这些速度，而每当玩家开始新游戏时，都将重置这些速度。在这个方法中，我们还设置了fleet_direction，使得游戏刚开始时，外星人总是向右移动。每当玩家提高一个等级时，我们都使用increase_speed()来提高飞船、子弹和外星人的速度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">increase_speed</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;提高速度设置&quot;&quot;&quot;</span> <br>    self.ship_speed_factor *= self.speedup_scale <br>    self.bullet_speed_factor *= self.speedup_scale <br>    self.alien_speed_factor *= self.speedup_scale<br></code></pre></td></tr></table></figure><p>为提高这些游戏元素的速度，我们将每个速度设置都乘以speedup_scale的值。</p><p>在check_bullet_alien_collisions()中，我们在整群外星人都被消灭后调用increase_speed()来加快游戏的节奏，再创建一群新的外星人</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306102150797.webp"></p><p><strong>重置速度</strong></p><p>每当玩家开始新游戏时，我们都需要将发生了变化的设置重置为初始值，否则新游戏开始时，速度设置将是前一次游戏增加了的值</p><h3 id="4-3记分"><a href="#4-3记分" class="headerlink" title="4.3记分"></a>4.3记分</h3><p>下面来实现一个记分系统，以实时地跟踪玩家的得分，并显示最高得分、当前等级和余下的飞船数。</p><p>得分是游戏的一项统计信息，因此我们在GameStats中添加一个score属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset_stats</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;</span><br>    self.ships_left = self.ai_settings.ship_limit<br>    self.score = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>为在每次开始游戏时都重置得分，我们在reset_stats()而不是__init__()中初始化score</p><p><strong>显示得分</strong></p><p>为在屏幕上显示得分，我们首先创建一个新类Scoreboard。就当前而言，这个类只显示当前得分，但后面我们也将使用它来显示最高得分、等级和余下的飞船数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame.font<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scoreboard</span>(): <br>    <span class="hljs-string">&quot;&quot;&quot;显示得分信息的类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_settings, screen, stats</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;初始化显示得分涉及的属性&quot;&quot;&quot;</span> <br>        self.screen = screen <br>        self.screen_rect = screen.get_rect() <br>        self.ai_settings = ai_settings <br>        self.stats = stats <br> <br>        <span class="hljs-comment"># 显示得分信息时使用的字体设置</span><br>        self.text_color = (<span class="hljs-number">30</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>)<br>        self.font = pygame.font.SysFont(<span class="hljs-literal">None</span>, <span class="hljs-number">48</span>) <br>        <span class="hljs-comment"># 准备初始得分图像</span><br>        self.prep_score()<br></code></pre></td></tr></table></figure><p>由于Scoreboard在屏幕上显示文本，因此我们首先导入模块pygame.font。接下来，我们在__init__()中包含形参ai_settings、screen和stats，让它能够报告我们跟踪的值。然后，我们设置文本颜色并实例化一个字体对象。为将要显示的文本转换为图像，我们调用了prep_score()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;</span><br>    score_str = <span class="hljs-built_in">str</span>(self.stats.score)<br>    self.score_image = self.font.render(score_str, <span class="hljs-literal">True</span>, self.text_color<br>                                        , self.ai_settings.bg_color) <br> <br>    <span class="hljs-comment"># 将得分放在屏幕右上角</span><br>    self.score_rect = self.score_image.get_rect() <br>    self.score_rect.right = self.screen_rect.right - <span class="hljs-number">20</span> <br>    self.score_rect.top = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>在prep_score()中，我们首先将数字值stats.score转换为字符串（见），再将这个字符串传递给创建图像的render()。为在屏幕上清晰地显示得分，我们向render()传递了屏幕背景色，以及文本颜色。</p><p>我们将得分放在屏幕右上角，并在得分增大导致这个数字更宽时让它向左延伸。为确保得分始终锚定在屏幕右边，我们创建了一个名为score_rect的rect，让其右边缘与屏幕右边缘相距20像素，并让其上边缘与屏幕上边缘也相距20像素。</p><p>最后，我们创建方法show_score()，用于显示渲染好的得分图像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;</span> <br>    self.screen.blit(self.score_image, self.score_rect)<br></code></pre></td></tr></table></figure><p><strong>创建记分牌</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建存储游戏统计信息的实例，并创建记分牌</span><br>stats = GameStats(ai_settings) <br>sb = Scoreboard(ai_settings, screen, stats)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306102203282.webp"></p><p>为显示得分，将update_screen()修改成下面这样:</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306102204866.webp"></p><p><strong>在外星人被消灭时更新得分</strong></p><p>为在屏幕上实时地显示得分，每当有外星人被击中时，我们都更新stats.score的值，再调用prep_score()更新得分图像。但在此之前，我们需要指定玩家每击落一个外星人都将得到多少个点<code>self.alien_points = 50</code></p><p>在check_bullet_alien_collisions()中，每当有外星人被击落时，都更新得分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bullet_alien_collisions</span>(<span class="hljs-params">ai_settings, screen, ship, stats,</span><br><span class="hljs-params">                                  sb,aliens, bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;</span> <br>    <span class="hljs-comment"># 删除发生碰撞的子弹和外星人</span><br>    collisions =  pygame.sprite.groupcollide(bullets,aliens,<span class="hljs-literal">True</span>,<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">if</span> collisions:<br>        stats.score += ai_settings.alien_points<br>        sb.prep_score()<br></code></pre></td></tr></table></figure><p>更新check_bullet_alien_collisions()的定义，在其中包含了形参stats和sb，让它能够更新得分和记分牌。有子弹撞到外星人时，Pygame返回一个字典（collisions）。我们检查这个字典是否存在，如果存在，就将得分加上一个外星人值的点数。接下来，我们调用prep_score()来创建一幅显示最新得分的新图像</p><p><strong>将消灭的每个外星人的点数都计入得分</strong></p><p>当前，我们的代码可能遗漏了一些被消灭的外星人。例如，如果在一次循环中有两颗子弹射中了外星人，或者因子弹更宽而同时击中了多个外星人，玩家将只能得到一个被消灭的外星人的点数。为修复这种问题，我们来调整检测子弹和外星人碰撞的方式。</p><p>在check_bullet_alien_collisions()中，与外星人碰撞的子弹都是字典collisions中的一个键；而与每颗子弹相关的值都是一个列表，其中包含该子弹撞到的外星人。我们遍历字典collisions，确保将消灭的每个外星人的点数都记入得分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_bullet_alien_collisions</span>(<span class="hljs-params">ai_settings, screen, ship, stats,</span><br><span class="hljs-params">                                  sb,aliens, bullets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;</span> <br>    <span class="hljs-comment"># 删除发生碰撞的子弹和外星人</span><br>    collisions =  pygame.sprite.groupcollide(bullets,aliens,<span class="hljs-literal">True</span>,<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">if</span> collisions:<br>        <span class="hljs-keyword">for</span> aliens <span class="hljs-keyword">in</span> collisions.values():<br>            stats.score += ai_settings.alien_points * <span class="hljs-built_in">len</span>(aliens)<br>            sb.prep_score()<br></code></pre></td></tr></table></figure><p><strong>提高点数</strong></p><p>玩家每提高一个等级，游戏都变得更难，因此处于较高的等级时，外星人的点数应更高。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111129704.webp"></p><p>我们定义了点数提高的速度，并称之为score_scale。很小的节奏加快速度（1.1）让游戏很快就变得极具挑战性，但为让记分发生显著的变化，需要将点数的提高速度设置为更大的值（1.5）。现在，我们在加快游戏节奏的同时，提高了每个外星人的点数。为让点数为整数，我们使用了函数int()。</p><p><strong>将得分整圆</strong></p><p>大多数街机风格的射击游戏都将得分显示为10的整数倍，下面让我们的记分系统遵循这个原则。我们还将设置得分的格式，在大数字中添加用逗号表示的千位分隔符。我们在Scoreboard中修改成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;</span><br>    rounded_score = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(self.stats.score, -<span class="hljs-number">1</span>))<br>    score_str =  <span class="hljs-string">&quot;&#123;:,&#125;&quot;</span>.<span class="hljs-built_in">format</span>(rounded_score)<br></code></pre></td></tr></table></figure><p>函数round()通常让小数精确到小数点后多少位，其中小数位数是由第二个实参指定的。然而，如果将第二个实参指定为负数，round()将圆整到最近的10、100、1000等整数倍。让Python将stats.score的值圆整到最近的10的整数倍，并将结果存储到rounded_score中.</p><p>使用了一个字符串格式设置指令，它让Python将数值转换为字符串时在其中插入逗号，例如，输出1,000,000而不是1000000。如果你现在运行这个游戏，看到的将是10的整数倍的整洁得分</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111134567.webp"></p><p><strong>最高得分</strong></p><p>每个玩家都想超过游戏的最高得分记录。下面来跟踪并显示最高得分，给玩家提供要超越的目标。我们将最高得分存储在GameStats中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameStats</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;</span><br>        self.ai_settings = ai_settings<br>        <span class="hljs-comment">#游戏刚启动时处于非活动状态</span><br>        self.game_active = <span class="hljs-literal">False</span><br>        self.reset_stats()<br>        <span class="hljs-comment"># 在任何情况下都不应重置最高得分</span><br>        self.high_score = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>下面来修改Scoreboard以显示最高得分。先来修改方法_<em>init</em>_()：</p><p><code>self.prep_high_score()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_high_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;将最高得分转换为渲染的图像&quot;&quot;&quot;</span> <br>    high_score = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(self.stats.high_score, -<span class="hljs-number">1</span>))<br>    high_score_str = <span class="hljs-string">&quot;&#123;:,&#125;&quot;</span>.<span class="hljs-built_in">format</span>(high_score)<br>    self.high_score_image = self.font.render(high_score_str, <span class="hljs-literal">True</span>, <br>    self.text_color, self.ai_settings.bg_color) <br><br>    <span class="hljs-comment">#将最高得分放在屏幕顶部中央</span><br>    self.high_score_rect = self.high_score_image.get_rect() <br>    self.high_score_rect.centerx = self.screen_rect.centerx <br>    self.high_score_rect.top = self.score_rect.top<br></code></pre></td></tr></table></figure><p>我们将最高得分圆整到最近的10的整数倍，并添加了用逗号表示的千分位分隔符。然后，我们根据最高得分生成一幅图像，使其水平居中，并将其top属性设置为当前得分图像的top属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;</span> <br>    self.screen.blit(self.score_image, self.score_rect)<br>    self.screen.blit(self.high_score_image, self.high_score_rect)<br></code></pre></td></tr></table></figure><p>为检查是否诞生了新的最高得分，我们在game_functions.py中添加一个新函数check_high_score()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_high_score</span>(<span class="hljs-params">stats, sb</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;检查是否诞生了新的最高得分&quot;&quot;&quot;</span> <br>    <span class="hljs-keyword">if</span> stats.score &gt; stats.high_score: <br>        stats.high_score = stats.score <br>        sb.prep_high_score()<br></code></pre></td></tr></table></figure><p>函数check_high_score()包含两个形参：stats和sb。它使用stats来比较当前得分和最高得分，并在必要时使用sb来修改最高得分图像.</p><p>在check_bullet_alien_collisions()中，每当有外星人被消灭，都需要在更新得分后调用check_high_score()</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111142623.webp"></p><p><strong>显示等级</strong></p><p>为在游戏中显示玩家的等级，首先需要在GameStats中添加一个表示当前等级的属性。为确保每次开始新游戏时都重置等级，在reset_stats()中初始化它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reset_stats</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;</span><br>    self.ships_left = self.ai_settings.ship_limit<br>    self.score = <span class="hljs-number">0</span><br>    self.level = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>为让Scoreboard能够在当前得分下方显示当前等级，我们在__init__()中调用了一个新方法prep_level()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_level</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;将等级转换为渲染的图像&quot;&quot;&quot;</span><br>    self.level_image = self.font.render(<span class="hljs-built_in">str</span>(self.stats.level), <span class="hljs-literal">True</span>, <br>    self.text_color, self.ai_settings.bg_color) <br><br>    <span class="hljs-comment"># 将等级放在得分下方</span><br>    self.level_rect = self.level_image.get_rect()<br>    self.level_rect.right = self.score_rect.right<br>    self.level_rect.top = self.score_rect.bottom + <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>方法prep_level()根据存储在stats.level中的值创建一幅图像，并将其right属性设置为得分的right属性。然后，将top属性设置为比得分图像的bottom属性大10像素，以便在得分和等级之间留出一定的空间。</p><p>修改show_score()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_score</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;</span> <br>    self.screen.blit(self.score_image, self.score_rect)<br>    self.screen.blit(self.high_score_image, self.high_score_rect)<br>    self.screen.blit(self.level_image, self.level_rect)<br></code></pre></td></tr></table></figure><p>在check_bullet_alien_collisions()中提高等级，并更新等级图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果外星人都被消灭了，重新生成新的外星人群</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(aliens) == <span class="hljs-number">0</span>:<br>    <span class="hljs-comment">#如果外星人都被消灭，则提高一个等级</span><br>    bullets.empty()<br>    ai_settings.increase_speed()<br><br>    <span class="hljs-comment">#提高等级</span><br>    stats.level += <span class="hljs-number">1</span><br>    sb.prep_level()<br>    create_fleet(ai_settings,screen,ship,aliens)<br></code></pre></td></tr></table></figure><p>如果整群外星人都被消灭，我们就将stats.level的值加1，并调用prep_level()，以确保正确地显示新等级.</p><p>为确保开始新游戏时更新记分和等级图像，在按钮Play被单击时触发重置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_play_button</span>(<span class="hljs-params">ai_settings,screen,stats,sb,play_button,ship,aliens,</span><br><span class="hljs-params">                      bullets,mouse_x,mouse_y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;</span><br>    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)<br>    <span class="hljs-keyword">if</span> button_clicked <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> stats.game_active:<br>        <span class="hljs-comment">#重置游戏设置</span><br>        ai_settings.initialize_dynamic_settings()<br><br>        <span class="hljs-comment"># 隐藏光标</span><br>        pygame.mouse.set_visible(<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment">#重置统计信息</span><br>        stats.reset_stats()<br>        stats.game_active = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment">#重置记分牌图像</span><br>        sb.prep_score() <br>        sb.prep_high_score() <br>        sb.prep_level()<br></code></pre></td></tr></table></figure><p>check_play_button()的定义需要包含对象sb。为重置记分牌图像，我们在重置相关游戏设置后调用prep_score()、prep_high_score()和prep_level(),在check_events()中，现在需要向check_play_button()传递sb，让它能够访问记分牌对象.</p><p><strong>显示余下的飞船</strong></p><p>最后，我们来显示玩家还有多少艘飞船，但使用图形而不是数字。为此，我们在屏幕左上角绘制飞船图像来指出还余下多少艘飞船，就像众多经典的街机游戏那样</p><p>需要让Ship继承Sprite，以便能够创建飞船编组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>():<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,ai_settings,screen</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__init__()<br></code></pre></td></tr></table></figure><p>导入了Sprite，让Ship继承Sprite （见），并在__init__()的开头就调用了super()</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111201900.webp"></p><p>修改Scoreboard，在其中创建一个可供显示的飞船编组。下面是其中的import语句和方法__init__():</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111204156.webp"></p><p>鉴于要创建一个飞船编组，我们导入Group和Ship类。调用prep_level()后，我们调用了prep_ships()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prep_ships</span>(<span class="hljs-params">self</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;显示还余下多少艘飞船&quot;&quot;&quot;</span><br>    self.ships = Group()<br>    <span class="hljs-keyword">for</span> ship_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.stats.ships_left): <br>        ship = Ship(self.ai_settings, self.screen)<br>        ship.rect.x = <span class="hljs-number">10</span> + ship_number * ship.rect.width<br>        ship.rect.y = <span class="hljs-number">10</span><br>        self.ships.add(ship)<br></code></pre></td></tr></table></figure><p>方法prep_ships()创建一个空编组self.ships，用于存储飞船实例。为填充这个编组，根据玩家还有多少艘飞船运行一个循环相应的次数。在这个循环中，我们创建一艘新飞船，并设置其<em>x</em>坐标，让整个飞船编组都位于屏幕左边，且每艘飞船的左边距都为10像素。</p><p>我们还将<em>y</em>坐标设置为离屏幕上边缘10像素，让所有飞船都与得分图像对齐。最后，我们将每艘新飞船都添加到编组ships中</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111205355.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111206473.webp"></p><p>我们还在飞船被外星人撞到时调用prep_ships()，从而在玩家损失一艘飞船时更新飞船图像</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111211315.webp"></p><p>首先，我们在update_aliens()的定义中添加了形参sb。然后，我们向ship_hit()和check_aliens_bottom()都传递了sb，让它们都能够访问记分牌对象。</p><p>接下来，我们更新了ship_hit()的定义，使其包含形参sb。我们在将ships_left的值减1后调用了prep_ships()，这样每次损失了飞船时，显示的飞船数都是正确的。</p><p>在check_aliens_bottom()中需要调用ship_hit()，因此对这个函数进行更新</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111214776.webp"></p><p>现在，check_aliens_bottom()包含形参sb，并在调用ship_hit()时传递了实参sb。</p><p>最后，在alien_invasion.py中修改调用update_aliens()的代码，向它传递实参sb</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111434045.webp"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用API-Web应用编程</title>
    <link href="/2023/06/08/%E4%BD%BF%E7%94%A8API-Web%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/08/%E4%BD%BF%E7%94%A8API-Web%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="使用github的API接口获取项目信息并生成图形化展示"><a href="#使用github的API接口获取项目信息并生成图形化展示" class="headerlink" title="使用github的API接口获取项目信息并生成图形化展示"></a>使用github的API接口获取项目信息并生成图形化展示</h1><p>利用github提供的API接口：<strong><a href="https://api.github.com/search/repositories?q=language:python&sort=stars">https://api.github.com/search/repositories?q=language:python&amp;sort=stars</a></strong>，通过python实现对获取数据的分析展示。</p><p>范例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-keyword">from</span> pygal.style <span class="hljs-keyword">import</span> LightColorizedStyle <span class="hljs-keyword">as</span> LCS, LightenStyle <span class="hljs-keyword">as</span> LS<br><br>url = <span class="hljs-string">&#x27;https://api.github.com/search/repositories?q=language:python&amp;sort=stars&#x27;</span><br><span class="hljs-comment">#获取请求</span><br>r = requests.get(url)<br><br><span class="hljs-keyword">if</span> r.status_code != <span class="hljs-number">200</span>:<br>    <span class="hljs-comment">#根据返回码判断是否访问成功</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;连接失败，请检查网络连接&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment">#将获取到的返回值items部分内容赋值给repo_dicts</span><br>    repo_dicts = r.json()[<span class="hljs-string">&#x27;items&#x27;</span>]<br>    <br>    <span class="hljs-comment">#创建两个空列表，用于存储仓库名称及仓库对应的星数及描述</span><br>    names, plot_dicts = [], []<br><br>    <span class="hljs-comment">#遍历列表，将名称加入到列表中</span><br>    <span class="hljs-keyword">for</span> repo_dict <span class="hljs-keyword">in</span> repo_dicts:<br>        names.append(repo_dict[<span class="hljs-string">&#x27;name&#x27;</span>])<br>        <span class="hljs-comment">#plot_dict列表中存储的是字典，字典由value,labele及xlink三个键</span><br>        plot_dict = &#123;<br>            <span class="hljs-string">&#x27;value&#x27;</span>:repo_dict[<span class="hljs-string">&#x27;stargazers_count&#x27;</span>],<br>            <span class="hljs-string">&#x27;label&#x27;</span>:repo_dict[<span class="hljs-string">&#x27;description&#x27;</span>],<br>            <span class="hljs-string">&#x27;xlink&#x27;</span>:repo_dict[<span class="hljs-string">&#x27;html_url&#x27;</span>]<br>        &#125;<br>        plot_dicts.append(plot_dict)<br> <br>    <span class="hljs-comment">#定义可视化展示柱形图的样式</span><br>    my_style = LS(<span class="hljs-string">&#x27;#333366&#x27;</span>, base_style=LCS)<br><br>    <span class="hljs-comment">#Pygal类Config的实例，并将其命名为my_config</span><br>    my_config = pygal.Config()<br>    <span class="hljs-comment">#让标签绕x轴旋转45度</span><br>    my_config.x_label_rotation = <span class="hljs-number">45</span> <br>    <span class="hljs-comment">#隐藏图例</span><br>    my_config.show_legend = <span class="hljs-literal">False</span><br>    <span class="hljs-comment">#设置图表标题、副标题和主标签的字体大小</span><br>    my_config.title_font_size = <span class="hljs-number">24</span> <br>    my_config.label_font_size = <span class="hljs-number">14</span> <br>    my_config.major_label_font_size = <span class="hljs-number">18</span><br>    <span class="hljs-comment">#将较长的项目名缩短为15个字符（如果你将鼠标指向屏幕上被截短的项目名，将显示完整的项目名）</span><br>    my_config.truncate_label = <span class="hljs-number">15</span><br>    <span class="hljs-comment">#隐藏图表中的水平线</span><br>    my_config.show_y_guides = <span class="hljs-literal">False</span><br>    <span class="hljs-comment">#设置宽度</span><br>    my_config.width = <span class="hljs-number">1000</span><br><br>    chart = pygal.Bar(my_config, style=my_style) <br>    chart.title = <span class="hljs-string">&#x27;Github上的Python项目排名&#x27;</span> <br>    chart.x_labels = names<br><br>    chart.add(<span class="hljs-string">&#x27;&#x27;</span>,plot_dicts)<br>    chart.render_to_file(<span class="hljs-string">&#x27;python_repos2.svg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>最终展示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306081634826.webp"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用pyecharts绘制中国地图</title>
    <link href="/2023/06/08/%E4%BD%BF%E7%94%A8pyecharts%E7%BB%98%E5%88%B6%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE/"/>
    <url>/2023/06/08/%E4%BD%BF%E7%94%A8pyecharts%E7%BB%98%E5%88%B6%E4%B8%AD%E5%9B%BD%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/qq_38161040/article/details/122464517">(18条消息) 2022见证中国崛起从Python绘制中国地图开始：使用pyecharts最新版本绘制中国地图实例详解，个性化地图定制及常用参数解析_挣扎的蓝藻的博客-CSDN博客</a></p><p><a href="https://lanzao.blog.csdn.net/article/details/122850961"><strong>Python</strong> 地图篇 - 使用 <strong>pyecharts</strong> 绘制世界地图、中国地图、省级地图、市级地图实例详解</a></p><p>先给大家看下效果图哈。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111505612.webp"></p><p>首先需要安装 <strong>pyecharts</strong> 库，直接 <code>pip install pyecharts</code> 就好了。<br>新版本的话不需要单独安装地图，如果是 <strong>0.5</strong> 版本是需要单独安装的，目前演示的是当前最新版本 <strong>1.9.1</strong><br><strong>地图数据如下：</strong><br>因为是中国地图，所以对标的省份，我设置了 <strong>2</strong> 组，里面的数据是随机生成的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">import</span> random<br><br><br>ultraman = [<br>[<span class="hljs-string">&#x27;四川&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;台湾&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;新疆&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江西&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;河南&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;辽宁&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;西藏&#x27;</span>, <span class="hljs-number">0</span>]<br>]<br><br><br>monster = [<br>[<span class="hljs-string">&#x27;广东&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江西&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;湖南&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;浙江&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-number">0</span>]<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_filling</span>(<span class="hljs-params">array</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：给数组数据填充随机数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i:<br>        i[<span class="hljs-number">1</span>] = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)<br>        <span class="hljs-comment">#print(i)</span><br><br>data_filling(ultraman)<br>data_filling(monster)<br><br></code></pre></td></tr></table></figure><p>首先演示下添加一组数据，运行后会生成一个 <strong>html</strong> 文件，打开后就可以查看生成的地图了。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111505139.webp"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>))<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111505637.webp"></p><p>然后演示下添加两组数据，只要再加个 <strong>add()</strong> 函数就好了，非常方便。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>))<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111504059.webp"></p><p>给大家加了块完整源码，直接运行即可哈。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">import</span> random<br><br><br>ultraman = [<br>[<span class="hljs-string">&#x27;四川&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;台湾&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;新疆&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江西&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;河南&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;辽宁&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;西藏&#x27;</span>, <span class="hljs-number">0</span>]<br>]<br><br><br>monster = [<br>[<span class="hljs-string">&#x27;广东&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江西&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;湖南&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;浙江&#x27;</span>, <span class="hljs-number">0</span>],<br>[<span class="hljs-string">&#x27;江苏&#x27;</span>, <span class="hljs-number">0</span>]<br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_filling</span>(<span class="hljs-params">array</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：给数组数据填充随机数</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:<br>        <br>        i[<span class="hljs-number">1</span>] = random.randint(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>)<br>        <span class="hljs-built_in">print</span>(i)<br><br>data_filling(ultraman)<br>data_filling(monster)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>))<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br>create_china_map()<br><br></code></pre></td></tr></table></figure><p>默认是选中的，添加 <code>is_selected=False</code> 参数可以设置默认不显示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">False</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>))<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br>create_china_map()<br><br></code></pre></td></tr></table></figure><p>可以看到默认只显示了怪兽的数据。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111504927.webp"></p><p>视觉映射配置项 <code>visualmap_opts=opts.VisualMapOpts(max_=1000, is_piecewise=True)</code> 可以设置为地图颜色类型分段显示，<code>max_</code> 的值对应的是数据的范围，参数 <code>is_piecewise=True</code> 表示为分段显示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">True</span>)<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p>分段显示效果图：<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111504190.webp"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>)<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p>这是参数为 <code>is_piecewise=False</code> 的标准显示。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111504592.webp"></p><p>参数 <code>is_roam=False</code> 会控制不可进行鼠标缩放和平移。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span>,<br>            <br>            is_roam=<span class="hljs-literal">False</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>)<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br><br></code></pre></td></tr></table></figure><p>参数启用时鼠标滚轮可以放大缩小图像。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111504323.webp"></p><p>鼠标可以左右拖动使地图平移。<br><strong>优先级声明：</strong>  <strong>a</strong> 数据设置为 <strong>False</strong>，<strong>b</strong> 数据设置为 <strong>True</strong>，不选中 <strong>a</strong> 数据，也可以进行缩放和平移拖动。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111503414.webp"></p><p>参数 <code>is_map_symbol_show=False</code> 可以关闭图形标记，关闭就不显示点了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span>,<br>            <br>            is_roam=<span class="hljs-literal">True</span>,<br>            <br>            is_map_symbol_show=<span class="hljs-literal">False</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>)<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p>可以看到奥特曼相关区域的点已经没有了。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111503621.webp"></p><p>系列配置项的参数 <code>label_opts=opts.LabelOpts(is_show=False)</code> 可以关闭标签名称显示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span>,<br>            <br>            is_roam=<span class="hljs-literal">True</span>,<br>            <br>            is_map_symbol_show=<span class="hljs-literal">False</span><br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>),<br>        )<br>        <br>        <br>        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">False</span>))<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p>可以看到省份的名称不显示了。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111503351.webp"></p><p>将 <code>label_opts=opts.LabelOpts(is_show=False)</code> 添加到 <strong>add()</strong> 里，可以实现局部显示标签名的效果，显示标签的为另一组数据，可以根据此特性灵活进行应用。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span>,<br>            <br>            is_roam=<span class="hljs-literal">True</span>,<br>            <br>            is_map_symbol_show=<span class="hljs-literal">False</span>,<br>            <br>            label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">False</span>)<br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(<br>        <br>        title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>        <br>        visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>),<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p>可以看到局部省份的名称有显示。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111503054.webp"></p><p>系列配置项里的标签加上 <code>color=&quot;bule&quot;</code> 参数可设置标签颜色为蓝色。<br>图元样式配置的 <code>areaColor</code> 为区域颜色， <code>borderColor</code> 为边框颜色，<br>其中 <code>normal</code> 为常规模式下的，<code>emphasis</code> 为强调样式下的，即鼠标移动到区域上的显示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">itemstyle_opts=&#123;<br>    <br>    <span class="hljs-string">&quot;normal&quot;</span>: &#123;<span class="hljs-string">&quot;areaColor&quot;</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-string">&quot;borderColor&quot;</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;,<br>    <br>    <span class="hljs-string">&quot;emphasis&quot;</span>: &#123;<span class="hljs-string">&quot;areaColor&quot;</span>: <span class="hljs-string">&quot;rgba(0,0,0,1)&quot;</span>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到我鼠标移动到新疆显示的为我设置的黑色，透明度为 <strong>1</strong>。<br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111502927.webp"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_china_map</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27; </span><br><span class="hljs-string">     作用：生成中国地图</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    (<br>        Map()<br>        .add(<br>            series_name=<span class="hljs-string">&quot;奥特曼&quot;</span>, <br>            data_pair=ultraman, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>            <br>            is_selected=<span class="hljs-literal">True</span>,<br>            <br>            is_roam=<span class="hljs-literal">True</span>,<br>            <br>            is_map_symbol_show=<span class="hljs-literal">False</span>,<br>            <br>            itemstyle_opts=&#123;<br>                <br>                <span class="hljs-string">&quot;normal&quot;</span>: &#123;<span class="hljs-string">&quot;areaColor&quot;</span>: <span class="hljs-string">&quot;white&quot;</span>, <span class="hljs-string">&quot;borderColor&quot;</span>: <span class="hljs-string">&quot;red&quot;</span>&#125;,<br>                <br>                <span class="hljs-string">&quot;emphasis&quot;</span>: &#123;<span class="hljs-string">&quot;areaColor&quot;</span>: <span class="hljs-string">&quot;rgba(0,0,0,1)&quot;</span>&#125;<br>            &#125;<br>        )<br>        .add(<br>            series_name=<span class="hljs-string">&quot;怪兽&quot;</span>, <br>            data_pair=monster, <br>            maptype=<span class="hljs-string">&quot;china&quot;</span>, <br>        )<br>        <br>        .set_global_opts(<br>            <br>            title_opts=opts.TitleOpts(title=<span class="hljs-string">&quot;中国地图&quot;</span>),<br>            <br>            visualmap_opts=opts.VisualMapOpts(max_=<span class="hljs-number">1000</span>, is_piecewise=<span class="hljs-literal">False</span>)<br>        )<br>        <br>        .set_series_opts(<br>            <br>            label_opts=opts.LabelOpts(is_show=<span class="hljs-literal">True</span>, color=<span class="hljs-string">&quot;blue&quot;</span>)<br>        )<br>        <br>        .render(<span class="hljs-string">&quot;中国地图.html&quot;</span>)<br>    )<br><br></code></pre></td></tr></table></figure><p><strong>Map()</strong> 里通过添加 <strong>init_opts</strong> 参数可以配置初始化画布大小。<br><strong>例如：</strong> <code>Map(init_opts=opts.InitOpts(height=&quot;1000px&quot;, width=&quot;1500px&quot;))</code><br><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306111502999.webp"></p><p>喜欢的点个赞❤吧！</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pyecharts</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据可视化-python</title>
    <link href="/2023/06/05/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-python/"/>
    <url>/2023/06/05/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-python/</url>
    
    <content type="html"><![CDATA[<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><p>matplotlib，它是一个数学绘图库，我们将使用它来制作简单的图表，如折线图和散点图。然后，我们将基于随机漫步概念生成一个更有趣的数据集——根据一系列随机决策生成的图表。</p><p>Pygal包，它专注于生成适合在数字设备上显示的图表。通过使用Pygal，可在用户与图表交互时突出元素以及调整其大小，还可轻松地调整整个图表的尺寸，使其适合在微型智能手表或巨型显示器上显示。</p><h2 id="1-生成数据"><a href="#1-生成数据" class="headerlink" title="1.生成数据"></a>1.生成数据</h2><h3 id="1-1matplotlib画廊"><a href="#1-1matplotlib画廊" class="headerlink" title="1.1matplotlib画廊"></a>1.1matplotlib画廊</h3><p>要查看使用matplotlib可制作的各种图表，请访问<a href="http://matplotlib.org/">https://matplotlib.org</a>的示例画廊。单击画廊中的图表，就可查看用于生成图表的代码。</p><p>中文文档地址：<a href="https://www.matplotlib.org.cn/">Matplotlib</a></p><h3 id="1-2绘制简单折线图"><a href="#1-2绘制简单折线图" class="headerlink" title="1.2绘制简单折线图"></a>1.2绘制简单折线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>squares = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br>plt.plot(squares)<br>plt.show()<br></code></pre></td></tr></table></figure><p>我们首先导入了模块pyplot，并给它指定了别名plt，以免反复输入pyplot。在线示例大都这样做，因此这里也这样做。模块pyplot包含很多用于生成图表的函数。</p><p>我们创建了一个列表，在其中存储了前述平方数，再将这个列表传递给函数plot()，这个函数尝试根据这些数字绘制出有意义的图形。</p><p><strong>如何让显示中文</strong></p><p>如何电脑已安装了相应的字体如‘微软雅黑’，则可以设置<code>plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;Microsoft YaHei&#39;]</code>指定字体，即可实现中文显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># from matplotlib.font_manager import FontProperties</span><br><br><span class="hljs-comment"># # 指定中文字体文件路径</span><br><span class="hljs-comment"># font_path = &#x27;C:\Windows\Fonts\msyh.ttc&#x27;</span><br><br><span class="hljs-comment"># # 加载字体文件</span><br><span class="hljs-comment"># font_prop = FontProperties(fname=font_path)</span><br><br><span class="hljs-comment"># 设置中文显示</span><br><span class="hljs-comment"># plt.rcParams[&#x27;font.family&#x27;] = font_prop.get_name()</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>]<br><br>squares = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br>plt.plot(squares,linewidth=<span class="hljs-number">5</span>)<br><br>plt.title(<span class="hljs-string">&quot;平方数折线图&quot;</span>,fontsize=<span class="hljs-number">24</span>)<br>plt.xlabel(<span class="hljs-string">&quot;数值&quot;</span>,fontsize=<span class="hljs-number">14</span>)<br>plt.ylabel(<span class="hljs-string">&quot;值的平方&quot;</span>,fontsize=<span class="hljs-number">14</span>)<br><br>plt.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>,labelsize=<span class="hljs-number">24</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><strong><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306050939247.webp"></strong></p><h3 id="1-3使用scatter-绘制一系列点"><a href="#1-3使用scatter-绘制一系列点" class="headerlink" title="1.3使用scatter()绘制一系列点"></a>1.3使用scatter()绘制一系列点</h3><p>要绘制一系列的点，可向scatter()传递两个分别包含<em>x</em>值和<em>y</em>值的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment">#图表标签及标题支持中文显示</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Microsoft YaHei&#x27;</span>]<br><br><br>x_values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>y_values = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br><br>plt.scatter(x_values,y_values,s=<span class="hljs-number">100</span>,c=<span class="hljs-string">&#x27;#80bee1&#x27;</span>,linewidths=<span class="hljs-number">0.5</span>)<br><br>plt.title(<span class="hljs-string">&quot;平方数散点图&quot;</span>,fontsize=<span class="hljs-number">18</span>)<br>plt.xlabel(<span class="hljs-string">&quot;X轴&quot;</span>,fontsize=<span class="hljs-number">10</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Y轴&quot;</span>,fontsize=<span class="hljs-number">10</span>)<br><br>plt.tick_params(axis=<span class="hljs-string">&#x27;both&#x27;</span>,labelsize=<span class="hljs-number">14</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306050948560.webp"></p><h3 id="1-4自动计算数据"><a href="#1-4自动计算数据" class="headerlink" title="1.4自动计算数据"></a>1.4自动计算数据</h3><p>手工计算列表要包含的值可能效率低下，需要绘制的点很多时尤其如此。可以不必手工计算包含点坐标的列表，而让Python循环来替我们完成这种计算。</p><p>matplotlib允许你给散点图中的各个点指定颜色。默认为蓝色点和黑色轮廓，在散点图包含的数据点不多时效果很好。但绘制很多点时，黑色轮廓可能会粘连在一起。要删除数据点的轮廓，可在调用scatter()时传递实参edgecolor&#x3D;’none’</p><p><strong>自定义颜色</strong></p><p>要修改数据点的颜色，可向scatter()传递参数c，并将其设置为要使用的颜色的名称，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x_values, y_values, c=<span class="hljs-string">&#x27;red&#x27;</span>, dgecolor=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>你还可以使用RGB颜色模式自定义颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x_values, y_values, c=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>), edgecolor=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>值越接近0，指定的颜色越深，值越接近1，指定的颜色越浅。</p><p><strong>颜色映射</strong></p><p>颜色映射（colormap）是一系列颜色，它们从起始颜色渐变到结束颜色。在可视化中，颜色映射用于突出数据的规律，例如，你可能用较浅的颜色来显示较小的值，并使用较深的颜色来显示较大的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, <br> edgecolor=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>我们将参数c设置成了一个<em>y</em>值列表，并使用参数cmap告诉pyplot使用哪个颜色映射。这些代码将<em>y</em>值较小的点显示为浅蓝色，并将<em>y</em>值较大的点显示为深蓝色.</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306051039323.webp"></p><p><em>注意：要了解pyplot中所有的颜色映射，请访问<a href="http://matplotlib.org/%EF%BC%8C%E5%8D%95%E5%87%BBExamples%EF%BC%8C%E5%90%91%E4%B8%8B%E6%BB%9A%E5%8A%A8%E5%88%B0Color">http://matplotlib.org/，单击Examples，向下滚动到Color</a> Examples，再单击olormaps_reference。</em></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_001.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_002.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_003.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_004.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_005.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_006.png"></p><p><img src="https://matplotlib.org/stable/_images/sphx_glr_colormap_reference_007.png"></p><h3 id="1-5自动保存图片"><a href="#1-5自动保存图片" class="headerlink" title="1.5自动保存图片"></a>1.5自动保存图片</h3><p>要让程序自动将图表保存到文件中，可将对plt.show()的调用替换为对plt.savefig()的调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.savefig(<span class="hljs-string">&#x27;squares_plot.png&#x27;</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>)<br></code></pre></td></tr></table></figure><p>第一个实参指定要以什么样的文件名保存图表，这个文件将存储到scatter_squares.py所在的目录中；第二个实参指定将图表多余的空白区域裁剪掉</p><h3 id="1-6随机漫步"><a href="#1-6随机漫步" class="headerlink" title="1.6随机漫步"></a>1.6随机漫步</h3><p>随机漫步是这样行走得到的路径：每次行走都完全是随机的，没有明确的方向，结果是由一系列随机决策决定的。</p><p>在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。例如，漂浮在水滴上的花粉因不断受到水分子的挤压而在水面上移动。水滴中的分子运动是随机的，因此花粉在水面上的运动路径犹如随机漫步。我们稍后将编写的代码模拟了现实世界的很多情形。</p><p>RandomWalk类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomWalk</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;&quot;一个生成随机漫步数据的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,num_points=<span class="hljs-number">5000</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;</span><br>        self.num_points = num_points<br><br>        <span class="hljs-comment">#所有的随机漫步都始于(0,0)</span><br>        self.x_values = [<span class="hljs-number">0</span>]<br>        self.y_vlaues = [<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fill_walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;</span><br><br>        <span class="hljs-comment">#不断漫步，直到列表达到指定的长度</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(self.x_values) &lt; self.num_points:<br>            <span class="hljs-comment">#决定前进的方向及沿这个方向前进的距离</span><br>            x_direction = choice([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>])<br>            x_distance = choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>            x_step = x_direction * x_distance<br><br>            y_direction = choice([<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>])<br>            y_distance = choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>            y_step = y_direction * y_distance<br><br>            <span class="hljs-comment">#拒绝原地踏步</span><br>            <span class="hljs-keyword">if</span> x_step ==<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y_step ==<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br><br>            <span class="hljs-comment">#计算下一个点的x和y值</span><br>            next_x = self.x_values[-<span class="hljs-number">1</span>] + x_step<br>            next_y = self.y_vlaues[-<span class="hljs-number">1</span>] + y_step<br><br>            self.x_values.append(next_x)<br>            self.y_vlaues.append(next_y)<br><br></code></pre></td></tr></table></figure><p>图形化展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">from</span> random_walk <span class="hljs-keyword">import</span> RandomWalk<br><br><span class="hljs-comment">#只要程序处于活动状态，就不断地模拟随机漫步</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment">#创建一个RandomWalk实例，并将其包含的点都绘制出来</span><br>    my_randomwalk = RandomWalk()<br>    my_randomwalk.fill_walk()<br><br>    <span class="hljs-comment">#图形化显示</span><br>    plt.scatter(my_randomwalk.x_values,my_randomwalk.y_vlaues,s=<span class="hljs-number">10</span>)<br>    plt.suptitle(<span class="hljs-string">&quot;随机漫步&quot;</span>,fontproperties=<span class="hljs-string">&#x27;SimHei&#x27;</span>)<br>    plt.show()<br><br>    keep_running = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;进行一个随机漫步吗？(y/n)&quot;</span>)<br>    <span class="hljs-keyword">if</span> keep_running == <span class="hljs-string">&#x27;n&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p><strong>给点着色</strong></p><p>我们将使用颜色映射来指出漫步中各点的先后顺序，并删除每个点的黑色轮廓，让它们的颜色更明显。为根据漫步中各点的先后顺序进行着色，我们传递参数c，并将其设置为一个列表，其中包含各点的先后顺序。由于这些点是按顺序绘制的，因此给参数c指定的列表只需包含数字1~5000</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">point_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(rw.num_points)) <br> plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, <br> edgecolor=<span class="hljs-string">&#x27;none&#x27;</span>, s=<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306051501014.webp"></p><p><strong>隐藏坐标轴</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 隐藏坐标轴,plt.scatter模式下：</span><br>plt.axis(<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># ax.scatter模式下两种方式都可以：</span><br>ax.axis(<span class="hljs-literal">False</span>)<br>ax.xaxis.set_visible(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>为修改坐标轴，使用了函数plt.axes()（见Ø）来将每条坐标轴的可见性都设置为False。随着你越来越多地进行数据可视化，经常会看到这种串接方法的方式。为修改坐标轴，使用了函数plt.axes()（见Ø）来将每条坐标轴的可见性都设置为False。随着你越来越多地进行数据可视化，经常会看到这种串接方法的方式。</p><p><strong>chatgpt解释plt.scatter与ax.scatter的区别：</strong></p><blockquote><p><code>plt.scatter</code> 和 <code>ax.scatter</code> 都用于绘制散点图，它们的区别在于使用的绘图方式和用法上略有不同。</p><p><code>plt.scatter</code> 是 <code>pyplot</code> 模块提供的函数，它是面向过程的绘图方式。你可以直接调用 <code>plt.scatter</code> 来创建一个散点图，并且在同一个函数调用中设置图形的各种属性，如点的大小、颜色、标签等。这种方式适合简单的绘图需求。</p><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;import matplotlib<span class="hljs-selector-class">.pyplot</span> as plt<br><br>&gt;x = <span class="hljs-selector-attr">[1, 2, 3, 4]</span><br>&gt;y = <span class="hljs-selector-attr">[5, 6, 7, 8]</span><br><br>&gt;plt<span class="hljs-selector-class">.scatter</span>(x, y, marker=<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;blue&#x27;</span>)<br>&gt;plt<span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">&#x27;X&#x27;</span>)<br>&gt;plt<span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>&gt;plt<span class="hljs-selector-class">.title</span>(<span class="hljs-string">&#x27;Scatter Plot&#x27;</span>)<br>&gt;plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p><code>ax.scatter</code> 是使用面向对象的方式进行绘图，它需要先创建一个图形对象 <code>fig</code> 和一个子图对象 <code>ax</code>，然后通过 <code>ax.scatter</code> 调用子图对象的方法来创建散点图，并设置图形的属性。这种方式更灵活，适合复杂的图形绘制需求，可以通过操作子图对象来进行更多的自定义设置。</p><p>示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;import matplotlib<span class="hljs-selector-class">.pyplot</span> as plt<br><br>&gt;x = <span class="hljs-selector-attr">[1, 2, 3, 4]</span><br>&gt;y = <span class="hljs-selector-attr">[5, 6, 7, 8]</span><br><br>&gt;fig, ax = plt<span class="hljs-selector-class">.subplots</span>()<br>&gt;ax<span class="hljs-selector-class">.scatter</span>(x, y, marker=<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-attribute">color</span>=<span class="hljs-string">&#x27;blue&#x27;</span>)<br>&gt;ax<span class="hljs-selector-class">.set_xlabel</span>(<span class="hljs-string">&#x27;X&#x27;</span>)<br>&gt;ax<span class="hljs-selector-class">.set_ylabel</span>(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>&gt;ax<span class="hljs-selector-class">.set_title</span>(<span class="hljs-string">&#x27;Scatter Plot&#x27;</span>)<br>&gt;plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><p>总结来说，<code>plt.scatter</code> 是面向过程的方式，直接在当前图形上绘制散点图，而 <code>ax.scatter</code> 是面向对象的方式，需要先创建图形对象和子图对象，然后调用子图对象的方法来绘制散点图。使用面向对象的方式可以更灵活地控制图形的各个元素和属性。</p></blockquote><h3 id="1-7调整尺寸以适应屏幕"><a href="#1-7调整尺寸以适应屏幕" class="headerlink" title="1.7调整尺寸以适应屏幕"></a>1.7调整尺寸以适应屏幕</h3><p>图表适合屏幕大小时，更能有效地将数据中的规律呈现出来。为让绘图窗口更适合屏幕大小，可像下面这样调整matplotlib输出的尺寸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><p>可以增加分辨率参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(dpi=<span class="hljs-number">128</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br><br>fig , ax = plt.subplots(dpi=<span class="hljs-number">128</span>,figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><h3 id="1-8使用Pygal模拟掷骰子"><a href="#1-8使用Pygal模拟掷骰子" class="headerlink" title="1.8使用Pygal模拟掷骰子"></a>1.8使用Pygal模拟掷骰子</h3><p>在数学领域，常常利用掷骰子来解释各种数据分析。</p><p>要了解使用Pygal可创建什么样的图表，请查看图表类型画廊：访问<a href="http://www.pygal.org/%EF%BC%8C%E5%8D%95%E5%87%BBDocumentation%EF%BC%8C%E5%86%8D%E5%8D%95%E5%87%BBChart">http://www.pygal.org/，单击Documentation，再单击Chart</a> types。每个示例都包含源代码，让你知道这些图表是如何生成的</p><p><strong>设置刻度标签中文</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ax.tick_params(axis=<span class="hljs-string">&#x27;x&#x27;</span>)  <span class="hljs-comment"># 设置刻度标签旋转角度</span><br><span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> ax.get_xticklabels():<br>    label.set_fontproperties(<span class="hljs-string">&#x27;SimHei&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>zip()函数的使用：</strong></p><blockquote><p>可以使用<code>zip()</code>函数将两个列表组合成一个元组列表。<code>zip()</code>函数将按索引位置将两个列表中的元素逐个配对，返回一个包含元组的迭代器。然后，你可以将迭代器转换为列表。以下是示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&gt;list2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><br>&gt;combined_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(list1, list2))<br><br>&gt;<span class="hljs-built_in">print</span>(combined_list)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;[(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>在示例中，<code>zip(list1, list2)</code>将列表<code>list1</code>和<code>list2</code>中的元素逐个配对，得到一个元组的迭代器。然后，通过<code>list()</code>函数将迭代器转换为列表，得到了一个包含元组的列表<code>combined_list</code>。</p></blockquote><h2 id="2-下载数据"><a href="#2-下载数据" class="headerlink" title="2.下载数据"></a>2.下载数据</h2><p>要在文本文件中存储数据，最简单的方式是将数据作为一系列以逗号分隔的值（CSV）写入文件</p><p>csv模块包含在Python标准库中，可用于分析CSV文件中的数据行。</p><ul><li>enumerate()：用来获取每个元素的索引及其值。</li></ul><h3 id="2-1模块datetime"><a href="#2-1模块datetime" class="headerlink" title="2.1模块datetime()"></a>2.1模块datetime()</h3><p>方法strptime()可接受各种实参，并根据它们来决定如何解读日期:</p><table><thead><tr><th>实参</th><th>含义</th></tr></thead><tbody><tr><td>%A</td><td>星期的名称，如Monday</td></tr><tr><td>%B</td><td>月份名，如January</td></tr><tr><td>%m</td><td>用数字表示的月份（01~12）</td></tr><tr><td>%d</td><td>用数字表示月份中的一天（01~31）</td></tr><tr><td>%Y</td><td>四位的年份，如2015</td></tr><tr><td>%y</td><td>两位的年份，如15</td></tr><tr><td>%H</td><td>24小时制的小时数（00~23）</td></tr><tr><td>%I</td><td>12小时制的小时数（01~12）</td></tr><tr><td>%p</td><td>am或pm</td></tr><tr><td>%M</td><td>分钟数（00~59）</td></tr><tr><td>%S</td><td>秒数（00~61）</td></tr></tbody></table><h3 id="2-2fill-between-方法"><a href="#2-2fill-between-方法" class="headerlink" title="2.2fill_between()方法"></a>2.2fill_between()方法</h3><p>fill_between()，它接受一个<em>x</em>值系列和两个<em>y</em>值系列，并填充两个<em>y</em>值系列之间的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">plt.plot(dates, highs, c=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>) <br>plt.plot(dates, lows, c=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>plt.fill_between(dates, highs, lows, facecolor=<span class="hljs-string">&#x27;blue&#x27;</span>, alpha=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>实参alpha指定颜色的透明度。Alpha值为0表示完全透明，1（默认设置）表示完全不透明。通过将alpha设置为0.5，可让红色和蓝色折线的颜色看起来更浅。</p><p>我们向fill_between()传递了一个<em>x</em>值系列：列表dates，还传递了两个<em>y</em>值系列：highs和lows。实参facecolor指定了填充区域的颜色，我们还将alpha设置成了较小的值0.1，让填充区域将两个数据系列连接起来的同时不分散观察者的注意力</p><h2 id="3-人口地图数据"><a href="#3-人口地图数据" class="headerlink" title="3.人口地图数据"></a>3.人口地图数据</h2><p>Pygal中的地图制作工具要求数据为特定的格式：用国别码表示国家，以及用数字表示人口数量。处理地理政治数据时，经常需要用到几个标准化国别码集。</p><p>我们的数据中，国别码是三位的，而pygal的地图工具使用两位国别码。要使用pygal绘制世界地图。需要安装依赖包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pygal_maps_world<br></code></pre></td></tr></table></figure><p>国别码位于<code>i18n</code>模块</p><p><code>from pygal_maps_world.i18n import COUNTRIES</code>这样就导入了, COUNTRIES是一个字典，键是两位国别码，值是具体国家名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> code, name <span class="hljs-keyword">in</span> COUNTRIES.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> : <span class="hljs-subst">&#123;code&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pygal<br><br><span class="hljs-keyword">from</span> countries_codes <span class="hljs-keyword">import</span> get_country_code<br><br>filename = <span class="hljs-string">r&#x27;E:\Learning\python\16_下载数据\population_json.json&#x27;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:<br>    pop_data = json.load(f)<br><br>cc_population = &#123;&#125;<br><span class="hljs-keyword">for</span> pop_dict <span class="hljs-keyword">in</span> pop_data:<br>    <span class="hljs-keyword">if</span> pop_dict[<span class="hljs-string">&#x27;Year&#x27;</span>] == <span class="hljs-number">2016</span>:<br>        country = pop_dict[<span class="hljs-string">&#x27;Country Name&#x27;</span>]<br>        population = pop_dict[<span class="hljs-string">&#x27;Value&#x27;</span>]<br>        code = get_country_code(country)<br>        <span class="hljs-keyword">if</span> code:<br>            cc_population[code] = population<br><br><span class="hljs-comment"># print(cc_population)</span><br>cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;<br><br><span class="hljs-keyword">for</span> cc,pop <span class="hljs-keyword">in</span> cc_population.items():<br>    <span class="hljs-keyword">if</span> pop &lt; <span class="hljs-number">100000000</span>:<br>        cc_pops_1[cc] = pop<br>    <span class="hljs-keyword">elif</span> pop &lt; <span class="hljs-number">1000000000</span>:<br>        cc_pops_2[cc] = pop<br>    <span class="hljs-keyword">else</span>:<br>        cc_pops_3[cc] = pop<br><br>wm = pygal.maps.world.World()<br>wm.title = <span class="hljs-string">&#x27;2016年世界人口分布&#x27;</span><br><br>wm.add(<span class="hljs-string">&#x27;0-10m&#x27;</span>, cc_pops_1) <br>wm.add(<span class="hljs-string">&#x27;10m-1bn&#x27;</span>, cc_pops_2) <br>wm.add(<span class="hljs-string">&#x27;&gt;1bn&#x27;</span>, cc_pops_3)<br><br><span class="hljs-comment"># wm.add(&#x27;2016&#x27;,cc_population)</span><br><span class="hljs-comment"># wm.add(&#x27;North America&#x27;, [&#x27;us&#x27;,&#x27;ca&#x27;,&#x27;mx&#x27;])</span><br><span class="hljs-comment"># wm.add(&#x27;Central America&#x27;, [&#x27;bz&#x27;, &#x27;cr&#x27;, &#x27;gt&#x27;, &#x27;hn&#x27;, &#x27;ni&#x27;, &#x27;pa&#x27;, &#x27;sv&#x27;]) </span><br><span class="hljs-comment"># wm.add(&#x27;South America&#x27;, [&#x27;ar&#x27;, &#x27;bo&#x27;, &#x27;br&#x27;, &#x27;cl&#x27;, &#x27;co&#x27;, &#x27;ec&#x27;, &#x27;gf&#x27;, </span><br><span class="hljs-comment">#                          &#x27;gy&#x27;, &#x27;pe&#x27;, &#x27;py&#x27;, &#x27;sr&#x27;, &#x27;uy&#x27;, &#x27;ve&#x27;])</span><br><br>wm.render_to_file(<span class="hljs-string">&quot;world-population.svg&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pygal_maps_world.i18n <span class="hljs-keyword">import</span> COUNTRIES<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_country_code</span>(<span class="hljs-params">country_name</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;根据国家名，返回2位的国别代码&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> code,name <span class="hljs-keyword">in</span> COUNTRIES.items():<br>        <span class="hljs-keyword">if</span> country_name == name:<br>            <span class="hljs-keyword">return</span> code<br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Congo, Rep.&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;cg&#x27;</span><br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Congo, Dem. Rep.&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;cd&#x27;</span><br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Yemen, Rep.&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ye&#x27;</span><br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Korea, Dem. People’s Rep.&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;kp&#x27;</span><br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Korea, Rep.&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;kr&#x27;</span><br>        <span class="hljs-keyword">elif</span> country_name == <span class="hljs-string">&#x27;Libya&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ly&#x27;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202306071919358.webp"></p><p>人口数据：</p><p><a href="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/img/population_json.json">population_json.json</a></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python学习笔记</title>
    <link href="/2023/06/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/01/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python学习笔记摘要"><a href="#Python学习笔记摘要" class="headerlink" title="Python学习笔记摘要"></a>Python学习笔记摘要</h1><h2 id="1-起步"><a href="#1-起步" class="headerlink" title="1.起步"></a>1.起步</h2><h3 id="1-1Python的安装等"><a href="#1-1Python的安装等" class="headerlink" title="1.1Python的安装等"></a>1.1Python的安装等</h3><p>略</p><h3 id="1-2设置代码格式"><a href="#1-2设置代码格式" class="headerlink" title="1.2设置代码格式"></a>1.2设置代码格式</h3><ul><li><p>PEP 8建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。</p></li><li><p>在程序中混合使用制表符和空格可能导致极难解决的问题。如果你混合使用了制表符和空格，可将文件中所有的制表符转换为空格，大多数编辑器都提供了这样的功能。</p></li><li><p>很多Python程序员都建议每行不超过80字符。</p></li><li><p>PEP 8还建议注释的行长都不超过72字符，因为有些工具为大型项目自动生成文档时，会在每行注释开头添加格式化字符。</p></li><li><p>要将程序的不同部分分开，可使用空行，但是也不应该滥用，空行不会影响代码的运行，但会影响代码的可读性。</p></li></ul><p>在vscode中设置80字符参考线：</p><p>设置-文本编辑器-Rulers-在settings.json中编辑加入下列这段代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;[python]&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.rulers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-number">80</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;editor.defaultFormatter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-python.python&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-3编码风格"><a href="#1-3编码风格" class="headerlink" title="1.3编码风格"></a>1.3编码风格</h3><ul><li><p>类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。</p></li><li><p>实例名和模块名都采用小写格式，并在单词之间加上下划线。</p></li><li><p>对于每个类，都应紧跟在类定义后面包含一个文档字符串</p></li><li><p>可使用空行来组织代码，但不要滥用</p></li><li><p>需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再添加一个空行，然后编写导入你自己编写的模块的import语句</p></li></ul><h2 id="2-变量和数据类型"><a href="#2-变量和数据类型" class="headerlink" title="2.变量和数据类型"></a>2.变量和数据类型</h2><h3 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a>2.1变量</h3><p>变量的命名规则：</p><ul><li>变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为message_1，但不能将其命名为1_message</li><li>变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名greeting_message可行，但变量名greeting message会引发错误</li><li>不要将Python关键字和函数名用作变量名，即不要使用Python保留用于特殊用途的单词，如print（大部分编辑器会有提示）</li><li>变量名应既简短又具有描述性。例如，name比n好，student_name比s_n好，name_length比length_of_persons_name好</li><li>慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0</li></ul><h3 id="2-2字符串"><a href="#2-2字符串" class="headerlink" title="2.2字符串"></a>2.2字符串</h3><p>字符串在python中表示为被引号括起来的，引号可以是单引号也可以是双引号。因此如果一个字符串内是有单引号或者撇号的，外面使用双引号，如果字符串内是要包含双引号的，外面用单引号。</p><p><strong>字符串的一些方法：</strong></p><ul><li><p><code>title()</code>,将每个单词的首字母改为大写</p></li><li><p><code>upper()</code>,将所有字母都改为大写</p></li><li><p><code>lower()</code>,将所有字母都改为小写</p></li><li><p><code>rstrip()</code>,在输出时删除字符串末尾的空白（空白包括空格、制表符<code>\t</code>、换行符<code>\n</code>等），只在输出是去除空白，实际并没有改变字符串的值</p><blockquote><p>&gt;&gt;&gt; <strong>favorite_language &#x3D; ‘python ‘</strong></p><p>&gt;&gt;&gt; <strong>favorite_language</strong> </p><p>‘python ‘ </p><p>&gt;&gt;&gt; <strong>favorite_language.rstrip()</strong></p><p>‘python’ </p><p>&gt;&gt;&gt; <strong>favorite_language</strong></p><p>‘python ‘ </p></blockquote></li><li><p><code>lstrip()</code>,在输出时删除字符串开头的空白</p></li><li><p><code>strip()</code>,在输出时删除字符串前后的空白</p></li></ul><h3 id="2-3数字"><a href="#2-3数字" class="headerlink" title="2.3数字"></a>2.3数字</h3><p><strong>整数</strong></p><p>Python使用两个乘号表示乘方运算，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>浮点数</strong></p><p>Python也存在小数位的精度问题，例如存在下面这些情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.30000000000000004</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span>* <span class="hljs-number">0.1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.30000000000000004</span><br></code></pre></td></tr></table></figure><p><strong>str()函数</strong></p><p>通过str()函数来避免类型错误，在输出包含字符串及整数的信息时，将整数转换为字符串，从而实现信息的拼接</p><h3 id="2-3注释"><a href="#2-3注释" class="headerlink" title="2.3注释"></a>2.3注释</h3><p>养成写注释的习惯！养成写注释的习惯！养成写注释的习惯！重要的事情说三遍。</p><h2 id="3列表"><a href="#3列表" class="headerlink" title="3列表"></a>3列表</h2><p>列表由一系列按特定顺序排列的元素组成，在Python中，用方括号（[]）来表示列表，并用逗号来分隔其中的元素。</p><h3 id="3-1访问列表"><a href="#3-1访问列表" class="headerlink" title="3.1访问列表"></a>3.1访问列表</h3><p>列表是有序集合，只需要将该元素的位置或索引告诉Python即可，当你请求获取列表元素时，Python只返回该元素，而不包括方括号和引号。</p><ul><li>可以对从列表取出的元素使用字符串方法。</li><li>列表元素的索引从0开始，而不是从 1开始，这点要注意。</li><li>-1表示列表的最后一个元素</li></ul><h3 id="3-2列表的增、删、改"><a href="#3-2列表的增、删、改" class="headerlink" title="3.2列表的增、删、改"></a>3.2列表的增、删、改</h3><ul><li>修改：修改列表元素的语法与访问列表元素的语法类似。要修改列表元素，可指定列表名和要修改的元素的索引，再指定该元素的新值。</li><li>末尾添加元素：使用append()函数,可以在列表的末尾添加元素</li><li>列表中插入元素：使用insert()函数,可以在列表的任何位置添加新元素</li><li>列表中删除元素：使用del语句可以删除列表中的任何元素，前提是你要知道你删除的元素索引</li><li>使用pop()删除元素：pop()函数可删除列表末尾的元素，并允许使得它的值。</li><li>使用pop()删除任何位置元素：只需在括号中指定要删除的元素的索引即可。</li><li>根据值删除元素：不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用方法remove()。<ul><li>注意：remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值</li></ul></li></ul><h3 id="3-3组织列表"><a href="#3-3组织列表" class="headerlink" title="3.3组织列表"></a>3.3组织列表</h3><p>创建的列表中，元素的排列顺序常常是无法预测的，因为你并非总能控制用户提供数据的顺序。这虽然在大多数情况下都是不可避免的，但你经常需要以特定的顺序呈现信息。有时候，你希望保留列表元素最初的排列顺序，而有时候又需要调整排列顺序。Python提供了很多组织列表的方式，可根据具体情况选用。</p><p><strong>永久排序</strong></p><p>可以通过sort()函数对列表进行排序，并且是永久性地修改了列表元素的排列顺序。</p><ul><li><code>sort()</code>:按字母顺序进行排列</li><li><code>sort(reverse=True)</code>:按字母顺序相反的顺序排列</li></ul><p><strong>临时排序</strong></p><p>要保留列表元素原来的排列顺序，同时以特定的顺序呈现它们，可使用函数sorted()。</p><p><strong>倒序打印</strong></p><p>要反转列表元素的排列顺序，可使用方法reverse()，永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用reverse()即可。</p><p><strong>确定列表的长度</strong></p><p>使用函数len()可快速获悉列表的长度</p><h2 id="4-操作列表"><a href="#4-操作列表" class="headerlink" title="4.操作列表"></a>4.操作列表</h2><p>如何<strong>遍历</strong>整个列表，这只需要几行代码，无论列表有多长。循环让你能够对列表的每个元素都采取一个或一系列相同的措施，从而高效地处理任何长度的列表，包括包含数千乃至数百万个元素的列表。</p><h3 id="4-1遍历整个列表"><a href="#4-1遍历整个列表" class="headerlink" title="4.1遍历整个列表"></a>4.1遍历整个列表</h3><p><strong>for循环</strong></p><ul><li>通过使用for循环，实现对列表的快速遍历。</li><li>在for循环中，可对每个元素执行任何操作。</li><li>在for循环后面，没有缩进的代码都只执行一次，而不会重复执行。</li></ul><h3 id="4-2避免缩进错误"><a href="#4-2避免缩进错误" class="headerlink" title="4.2避免缩进错误"></a>4.2避免缩进错误</h3><p>Python根据缩进来判断代码行与前一个代码行的关系。</p><h3 id="4-3创建数值列表"><a href="#4-3创建数值列表" class="headerlink" title="4.3创建数值列表"></a>4.3创建数值列表</h3><p>列表非常适合用于存储数字集合，而Python提供了很多工具，可帮助你高效地处理数字列表。</p><p><strong>range()函数</strong></p><p>函数range()让你能够轻松地生成一系列的数字。例如下面的语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(value)<br></code></pre></td></tr></table></figure><p>括号内的参数表示从1开始包括1到5结束但不包括5。</p><p><strong>使用range()创建数字列表</strong></p><p>可使用函数list()将range()的结果直接转换为列表，如果将range()作为list()的参数，输出将是一个数字列表。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(nubmers)<br></code></pre></td></tr></table></figure><p>numbers是一个列表，预期结果将会是：</p><blockquote><p>[1, 2, 3, 4, 5] </p></blockquote><p><strong>range()函数指定步长</strong></p><p>range()函数还可以指定步长，例如下面的代码将打印1-10内的偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">even_numbers=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>使用函数range()几乎能够创建任何需要的数字集，例如，如何创建一个列表，其中包含前10个整数（即1~10）的平方呢？在Python中，两个星号（**）表示乘方运算。下面的代码演示了如何将前10个整数的平方加入到一个列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = []<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>    square = value**<span class="hljs-number">2</span><br>    squares.append(square)<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p><strong>对数字列表执行简单的统计计算</strong></p><p>有几个专门用于处理数字列表的Python函数。例如，你可以轻松地找出数字列表的最大值、最小值和总和：</p><ul><li>min()</li><li>max()</li><li>sum()</li><li>···</li></ul><p><strong>列表解析</strong></p><p>列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素，下面这两段代码的结果是一样的：</p><p>使用for循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">squares=[]<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>):<br>    squares.append(value**<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p>使用列表解析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [value**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>)]<br><span class="hljs-built_in">print</span>(squares)<br></code></pre></td></tr></table></figure><p>要使用这种语法，首先指定一个描述性的列表名，如squares；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为value**2，它计算平方值。接下来，编写一个for循环，用于给表达式提供值，再加上右方括号。在这个示例中，for循环为for value in range(1,11)，它将值1~10提供给表达式value**2。请注意，这里的for语句末尾没有冒号。</p><h3 id="4-4使用列表的一部分"><a href="#4-4使用列表的一部分" class="headerlink" title="4.4使用列表的一部分"></a>4.4使用列表的一部分</h3><p>以处理列表的部分元素——Python称之为切片。</p><p><strong>切片</strong></p><p>要创建切片，可指定要使用的第一个元素和最后一个元素的索引要创建切片，可指定要使用的第一个元素和最后一个元素的索引，下面的范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>] <br><span class="hljs-built_in">print</span>(players[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><ul><li><p>print(players[0:3])表示打印列表的一个切片，包含1-3名队员，输出的也是一个列表；</p></li><li><p>print(players[１:4])表示提取列表第2-4个元素</p></li><li><p>print(players[:4])表示从列表开头到第4个元素</p></li><li><p>print(players[2:])表示从第3个元素到最后</p></li><li><p>print(players[-3:])表示末尾的3个元素</p></li></ul><p><strong>遍历切片</strong></p><p>如果要遍历列表的部分元素，可在for循环中使用切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>] <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Here are the first three players on my team:&quot;</span>) <br><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players[:<span class="hljs-number">3</span>]:<br>    <span class="hljs-built_in">print</span>(player.title())<br></code></pre></td></tr></table></figure><p><strong>复制列表</strong></p><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:]）。这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。</p><p>如果使用“&#x3D;”将一个列表赋给另一个列表，其表示的并非是将列表的内容复制到新的列表，仅是将两个列表指向同一个列表的内容。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_foods = [<span class="hljs-string">&#x27;pizza&#x27;</span>, <span class="hljs-string">&#x27;falafel&#x27;</span>, <span class="hljs-string">&#x27;carrot cake&#x27;</span>]<br>friend_foods = my_foods<br></code></pre></td></tr></table></figure><p>这里将my_foods赋给friend_foods，而不是将my_foods的副本存储到friend_foods。这种语法实际上是让Python将新变量friend_foods关联到包含在my_foods中的列表，因此这两个变量都指向同一个列表。鉴于此，当我们将’cannoli’添加到my_foods中时，它也将出现在friend_foods中；同样，虽然’ice cream’好像只被加入到了friend_foods中，但它也将出现在这两个列表中。输出表明，两个列表是相同的。</p><h3 id="4-5元组"><a href="#4-5元组" class="headerlink" title="4.5元组"></a>4.5元组</h3><p>Python将不能修改的值称为不可变的，而不可变的列表被称为元组。</p><p><strong>定义元组</strong></p><p>元组看起来犹如列表，但<strong>使用圆括号而不是方括号来标识</strong>。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。</p><p><strong>遍历元组中的所有值</strong></p><p>像列表一样，也可以使用for循环来遍历元组中的所有值。</p><p><strong>修改元组变量</strong></p><p>虽然不能修改元组的元素，但可以给存储元组的变量赋值，从而实现重新定义元组。</p><p>相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，可使用元组。</p><h2 id="5-if语句"><a href="#5-if语句" class="headerlink" title="5.if语句"></a>5.if语句</h2><h3 id="5-1条件测试"><a href="#5-1条件测试" class="headerlink" title="5.1条件测试"></a>5.1条件测试</h3><p>每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。</p><p>Python根据条件测试的值为True还是False来决定是否执行if语句中的代码。如果条件测试的值为True，Python就执行紧跟在if语句后面的代码；如果为False，Python就忽略这些代码。</p><p><strong>检查是否相等</strong></p><p>使用两个等（&#x3D;&#x3D;）来进行相等判断，<code>==</code>运算符两边的值相等时返回True，否则返回False。</p><p><strong>检查是否相等时不考虑大小写</strong></p><p>在Python中检查是否相等时区分大小写，如果在判断时不需要考虑大小写，那我们可使用lower()函数后再进行比较。常见的场景类似如下：</p><blockquote><p>网站采用类似的方式让用户输入的数据符合特定的格式。例如，网站可能使用类似的测试来确保用户名是独一无二的，而并非只是与另一个用户名的大小写不同。用户提交新的用户名时，将把它转换为小写，并与所有既有用户名的小写版本进行比较。执行这种检查时，如果已经有用户名’john’（不管大小写如何），则用户提交用户名’John’时将遭到拒绝。</p></blockquote><p><strong>检查是否不相等</strong></p><p>使用惊叹号和等号(!&#x3D;)来表示不等于。</p><p><strong>比较数字</strong></p><p>条件语句中可包含各种数学比较，如小于、小于等于、大于、大于等于：</p><ul><li>&#x3D;</li><li>&lt;&#x3D;</li><li>&gt;</li><li>&gt;&#x3D;</li><li>!&#x3D;</li></ul><p><strong>检查多个条件</strong></p><p>你可能想同时检查多个条件，例如，有时候你需要在两个条件都为True时才执行相应的操作，而有时候你只要求一个条件为True时就执行相应的操作。在这些情况下，关键字and和or可助你一臂之力。</p><ul><li><code>and</code>:只有两个都为True时才为True</li><li><code>or</code>:只要有一个为True时就为True，两个条件都为False是才返回False</li></ul><p><strong>检查特定值是否包含在列表中</strong></p><p>要判断特定的值是否已包含在列表中，可使用关键字<code>in</code></p><p><strong>检查特定值是否不包含在列表中</strong></p><p>要判断特定的值是否<strong>不包含</strong>在列表中，可使用关键字<code>not in</code></p><p><strong>布尔表达式</strong></p><p>布尔表达式，是条件测试的别名。与条件表达式一样，布尔表达式的结果要么为True，要么为False。</p><h3 id="5-2-if语句"><a href="#5-2-if语句" class="headerlink" title="5.2 if语句"></a>5.2 if语句</h3><p><strong>if</strong></p><p>在if语句中，缩进的作用与for循环中相同。如果测试通过了，将执行if语句后面所有缩进的代码行，否则将忽略它们</p><p><strong>if-else</strong></p><p>if-else语句块类似于简单的if语句，但其中的else语句让你能够指定条件测试未通过时要执行的操作。</p><p>if-else结构非常适合用于要让Python执行两种操作之一的情形。在这种简单的if-else结构中，总是会执行两个操作中的一个。</p><p><strong>if-elif-else</strong></p><p>经常需要检查超过两个的情形，为此可使用Python提供的if-elif-else结构。</p><p>Python只执行if-elif-else结构中的一个代码块，它依次检查每个条件测试，直到遇到通过了的条件测试。</p><p><strong>省略else代码块</strong></p><p>Python并不要求if-elif结构后面必须有else代码块。</p><p>else是一条包罗万象的语句，只要不满足任何if或elif中的条件测试，其中的代码就会执行，这可能会引入无效甚至恶意的数据。</p><p><strong>测试多个条件</strong></p><p>在可能有多个条件为True，且你需要在每个条件为True时都采取相应措施时，适合使用这种方法。</p><h3 id="5-4使用if语句处理列表"><a href="#5-4使用if语句处理列表" class="headerlink" title="5.4使用if语句处理列表"></a>5.4使用if语句处理列表</h3><p>通过结合使用if语句和列表，可完成一些有趣的任务：对列表中特定的值做特殊处理。</p><h3 id="5-5设置if语句的格式"><a href="#5-5设置if语句的格式" class="headerlink" title="5.5设置if语句的格式"></a>5.5设置if语句的格式</h3><p>在条件测试的格式设置方面，PEP 8提供的唯一建议是，在诸如&#x3D;&#x3D;、&gt;&#x3D;和&lt;&#x3D;等比较运算符两边各添加一个空格。</p><h2 id="6-字典"><a href="#6-字典" class="headerlink" title="6.字典"></a>6.字典</h2><p>在Python中，字典是一系列键—值对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。</p><p><strong>在Python中，字典用放在花括号{}中的一系列键—值对表示</strong></p><p>键—值对是两个相关联的值。指定键时，Python将返回与之相关联的值。键和值之间用冒号分隔，而键—值对之间用逗号分隔。在字典中，你想<strong>存储多少个键—值对都可以</strong>。</p><h3 id="6-1使用字典"><a href="#6-1使用字典" class="headerlink" title="6.1使用字典"></a>6.1使用字典</h3><p><strong>添加键-值对</strong></p><p>字典是一种动态结构，可随时在其中添加键—值对。要添加键—值对，可依次指定字典名、用方括号括起的键和相关联的值。</p><p><strong>修改字典的值</strong></p><p>要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。</p><p><strong>删除键-值对</strong></p><p>对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。<strong>使用del语句时，必须指定字典名和要删除的键。</strong></p><p><strong>由类似对象组成的字典</strong></p><p>字典存储的是一个对象的多种信息，但你也可以使用字典来存储众多对象的同一种信息。</p><p>确定需要使用多行来定义字典时，在输入左花括号后按回车键，再在下一行缩进四个空格，指定第一个键—值对，并在它后面加上一个逗号</p><h3 id="6-2遍历字典"><a href="#6-2遍历字典" class="headerlink" title="6.2遍历字典"></a>6.2遍历字典</h3><p>通过for语句结合字典的方法items()，实现对字典的遍历，范例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> xxx.items()<br></code></pre></td></tr></table></figure><p>在不需要使用字典的值时，可以使用方法keys()获取字典中的key，当然在实际应用中，可以不加上keys()方法。</p><p><strong>按顺序遍历字典中的所有键</strong></p><p>字典总是明确地记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。要以特定的顺序返回元素，一种办法是在for循环中对返回的键进行排序，为此，可使用函数sorted()来获得按特定顺序排列的键列表的副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(dictionary.keys()):<br></code></pre></td></tr></table></figure><p><strong>遍历字典中的所有值</strong></p><p>如果你感兴趣的主要是字典包含的值，可使用方法values()，它返回一个值列表，而不包含任何键。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> dictionary.values():<br></code></pre></td></tr></table></figure><p>这种做法提取字典中所有的值，而没有考虑是否重复。涉及的值很少时，这也许不是问题，但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，可使用集合（set）。</p><p>集合类似于列表，但每个元素都必须是独一无二的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(dictionary.values()):<br></code></pre></td></tr></table></figure><p>通过对包含重复元素的列表调用set()，可让Python找出列表中独一无二的元素，并使用这些元素来创建一个集合.</p><h3 id="6-4嵌套"><a href="#6-4嵌套" class="headerlink" title="6.4嵌套"></a>6.4嵌套</h3><p>有时候，需要将一系列字典存储在列表中，或将列表作为值存储在字典中，这称为嵌套。你可以在列表中嵌套字典、在字典中嵌套列表甚至在字典中嵌套字典。</p><p><strong>字典列表</strong></p><p>经常需要在列表中包含大量的字典，而其中每个字典都包含特定对象的众多信息。例如，你可能需要为网站的每个用户创建一个字典，并将这些字典存储在一个名为users的列表中。在这个列表中，所有字典的结构都相同，因此你可以遍历这个列表，并以相同的方式处理其中的每个字典。</p><p><strong>在字典中存储列表</strong></p><p>有时候，需要将列表存储在字典中，而不是将字典存储在列表中。</p><p>每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表</p><p><strong>在字典中存储字典</strong></p><p>可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。</p><h2 id="7-用户输入和while循环"><a href="#7-用户输入和while循环" class="headerlink" title="7.用户输入和while循环"></a>7.用户输入和while循环</h2><h3 id="7-1函数input-的工作原理"><a href="#7-1函数input-的工作原理" class="headerlink" title="7.1函数input()的工作原理"></a>7.1函数input()的工作原理</h3><p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</p><p><strong>编写清晰的程序</strong></p><p>每当你使用函数input()时，都应指定清晰而易于明白的提示，准确地指出你希望用户提供什么样的信息——指出用户该输入任何信息的提示都行。</p><p>有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示存储在一个变量中，再将该变量传递给函数input()，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">prompt = <span class="hljs-string">&quot;If you tell us who you are, we can personalize the messages you see.&quot;</span> <br>prompt += <span class="hljs-string">&quot;\nWhat is your first name? &quot;</span><br>name = <span class="hljs-built_in">input</span>(prompt)<br></code></pre></td></tr></table></figure><p><strong>使用int()来获取数值输入</strong></p><p>使用函数input()时，Python将用户输入解读为字符串，如何输入的数字需要进行后续的计算时，可使用函数int()，它让Python将输入视为数值。</p><p>函数int()将数字的字符串表示转换为数值表示。</p><p><strong>求模运算符</strong></p><p>处理数值信息时，求模运算符（%）是一个很有用的工具，它将两个数相除并返回余数。</p><p>求模运算符不会指出一个数是另一个数的多少倍，而只指出余数是多少。</p><h3 id="7-2while循环"><a href="#7-2while循环" class="headerlink" title="7.2while循环"></a>7.2while循环</h3><p>for循环用于针对集合中的每个元素都执行一个代码块，而while循环不断地运行，直到指定的条件不满足为止。</p><p>在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于</p><p>活动状态。这个变量被称为标志，充当了程序的交通信号灯。你可让程序在标志为True时继续运行，并在任何事件导致标志的值为False时让程序停止运行。这样，在while语句中就只需检查一个条件——标志的当前值是否为True，并将所有测试（是否发生了应将标志设置为False的事件）都放在其他地方，从而让程序变得更为整洁。</p><p><strong>使用break退出循环</strong></p><p>要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用break语句。break语句用于控制程序流程，可使用它来控制哪些代码行将执行，哪些代码行不执行，从而让程序按你的要求执行你要执行的代码。</p><p><strong>注意</strong> 在任何Python循环中都可使用break语句。例如，可使用break语句来退出遍历列表或字典的for循环。</p><p><strong>在循环中使用 continue</strong></p><p>要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它不像break语句那样不再执行余下的代码并退出整个循环，而是退出当前循环，并继续执行下一个循环</p><p><strong>避免无限循环</strong></p><p>每个while循环都必须有停止运行的途径，这样才不会没完没了地执行下去</p><h3 id="7-3使用while循环来处理列表和字典"><a href="#7-3使用while循环来处理列表和字典" class="headerlink" title="7.3使用while循环来处理列表和字典"></a>7.3使用while循环来处理列表和字典</h3><p>for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while循环。通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。</p><p><strong>在列表之间移动元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先，创建一个待验证用户列表</span><br><span class="hljs-comment"># 和一个用于存储已验证用户的空列表</span><br>unconfirmed_users = [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;brian&#x27;</span>, <span class="hljs-string">&#x27;candace&#x27;</span>] <br>confirmed_users = [] <br><span class="hljs-comment"># 验证每个用户，直到没有未验证用户为止</span><br><span class="hljs-comment"># 将每个经过验证的列表都移到已验证用户列表中</span><br><span class="hljs-keyword">while</span> unconfirmed_users: <br>current_user = unconfirmed_users.pop()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Verifying user: &quot;</span> + current_user.title()) <br>confirmed_users.append(current_user) <br><span class="hljs-comment"># 显示所有已验证的用户</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nThe following users have been confirmed:&quot;</span>) <br><span class="hljs-keyword">for</span> confirmed_user <span class="hljs-keyword">in</span> confirmed_users: <br><span class="hljs-built_in">print</span>(confirmed_user.title())<br></code></pre></td></tr></table></figure><p><strong>删除包含特定值的所有列表元素</strong></p><p>我们使用函数remove()来删除列表中的特定值，这之所以可行，是因为要删除的值在列表中只出现了一次。如果要删除列表中所有包含特定值的元素，该怎么办呢？</p><p>假设你有一个宠物列表，其中包含多个值为’cat’的元素。要删除所有这些元素，可不断运行一个while循环，直到列表中不再包含值’cat’，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pets = [<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;goldfish&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;rabbit&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>] <br><span class="hljs-built_in">print</span>(pets) <br><span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">in</span> pets: <br>    pets.remove(<span class="hljs-string">&#x27;cat&#x27;</span>) <br> <br><span class="hljs-built_in">print</span>(pets)<br></code></pre></td></tr></table></figure><p><strong>使用用户输入来填充字典</strong></p><p>看范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">responses = &#123;&#125; <br><span class="hljs-comment"># 设置一个标志，指出调查是否继续</span><br>polling_active = <span class="hljs-literal">True</span> <br><span class="hljs-keyword">while</span> polling_active: <br> <span class="hljs-comment"># 提示输入被调查者的名字和回答</span><br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\nWhat is your name? &quot;</span>) <br>    response = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Which mountain would you like to climb someday? &quot;</span>) <br> <br> <span class="hljs-comment"># 将答卷存储在字典中</span><br>    responses[name] = response <br> <br> <span class="hljs-comment"># 看看是否还有人要参与调查</span><br>    repeat = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Would you like to let another person respond? (yes/ no) &quot;</span>) <br>    <span class="hljs-keyword">if</span> repeat == <span class="hljs-string">&#x27;no&#x27;</span>: <br>        polling_active = <span class="hljs-literal">False</span> <br> <br><span class="hljs-comment"># 调查结束，显示结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n--- Poll Results ---&quot;</span>) <br><span class="hljs-keyword">for</span> name, response <span class="hljs-keyword">in</span> responses.items(): <br>    <span class="hljs-built_in">print</span>(name + <span class="hljs-string">&quot; would like to climb &quot;</span> + response + <span class="hljs-string">&quot;.&quot;</span>)<br></code></pre></td></tr></table></figure><p>这个程序首先定义了一个空字典（responses），并设置了一个标志（polling_active），用于指出调查是否继续。只要polling_active为True，Python就运行while循环中的代码。</p><h2 id="8-函数"><a href="#8-函数" class="headerlink" title="8.函数"></a>8.函数</h2><p>函数让你能够将程序分成多个很小的部分，其中每部分都负责完成一项具体任务。你可以根据需要调用同一个函数任意次，还可将函数存储在独立的文件中。</p><p>使用函数可让你编写的代码效率更高，更容易维护和排除故障，还可在众多不同的程序中重用。</p><h3 id="8-1定义函数"><a href="#8-1定义函数" class="headerlink" title="8.1定义函数"></a>8.1定义函数</h3><p>文档字符串用三引号括起（”””这是函数的说明”””），Python使用它们来生成有关程序中函数的文档。</p><ul><li>形参——函数完成其工作所需的一项信息</li><li>实参——是调用函数时传递给函数的信息</li></ul><h3 id="8-2传递参数"><a href="#8-2传递参数" class="headerlink" title="8.2传递参数"></a>8.2传递参数</h3><p>鉴于函数定义中可能包含多个形参，因此函数调用中也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。</p><p><strong>位置实参</strong></p><p>你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。</p><p><strong>关键字实参</strong></p><p>关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆（不会得到名为Hamster的harry这样的结果）。关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。</p><p>关键字实参的顺序无关紧要，因为Python知道各个值该存储到哪个形参中。</p><p><strong>默认值</strong></p><p>编写函数时，可给每个形参指定默认值。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。</p><h3 id="8-3返回值"><a href="#8-3返回值" class="headerlink" title="8.3返回值"></a>8.3返回值</h3><p>函数并非总是直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。函数返回的值被称为返回值。</p><p>在函数中，可使用return语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成，从而简化主程序。</p><p>有时候，需要让实参变成可选的，这样使用函数的人就只需在必要时才提供额外的信息。可使用默认值来让实参变成可选的。</p><p>函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。</p><h3 id="8-4传递列表"><a href="#8-4传递列表" class="headerlink" title="8.4传递列表"></a>8.4传递列表</h3><p>向函数传递列表很有用，这种列表包含的可能是名字、数字或更复杂的对象（如字典）。将列表传递给函数后，函数就能直接访问其内容。</p><p><strong>在函数中修改列表</strong></p><p>将列表传递给函数后，函数就可对其进行修改。在函数中对这个列表所做的任何修改都是永久性的，这让你能够高效地处理大量的数据。</p><ul><li><strong>每个函数都应只负责一项具体的工作</strong></li></ul><p><strong>禁止函数修改列表</strong></p><p>可向函数传递列表的副本而不是原件；这样函数所做的任何修改都只影响副本，而丝毫不影响原件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">function_name(list_name[:])<br></code></pre></td></tr></table></figure><h3 id="8-5传递任意数量的实参"><a href="#8-5传递任意数量的实参" class="headerlink" title="8.5传递任意数量的实参"></a>8.5传递任意数量的实参</h3><p>有时候，你预先不知道函数需要接受多少个实参，好在Python允许函数从调用语句中收集任意数量的实参</p><p>用<code>*形参名</code>的形参表示可以接收任意数量的实参，并装到元组中。注意，Python将实参封装到一个元组中，即便函数只收到一个值也如此。范例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pizza</span>(<span class="hljs-params">*toppings</span>): <br> <span class="hljs-string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span> <br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nMaking a pizza with the following toppings:&quot;</span>) <br>     <span class="hljs-keyword">for</span> topping <span class="hljs-keyword">in</span> toppings: <br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- &quot;</span> + topping) <br> <br>make_pizza(<span class="hljs-string">&#x27;pepperoni&#x27;</span>) <br>make_pizza(<span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;green peppers&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后</strong>。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pizza</span>(<span class="hljs-params">size, *toppings</span>): <br> <span class="hljs-string">&quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot;</span> <br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\nMaking a &quot;</span> + <span class="hljs-built_in">str</span>(size) + <br>         <span class="hljs-string">&quot;-inch pizza with the following toppings:&quot;</span>) <br>     <span class="hljs-keyword">for</span> topping <span class="hljs-keyword">in</span> toppings: <br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;- &quot;</span> + topping) <br> <br>make_pizza(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;pepperoni&#x27;</span>) <br>make_pizza(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;green peppers&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有时候，需要接受任意数量的实参，但预先不知道传递给函数的会是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键—值对——调用语句提供了多少就接受多少。</p><p><strong>用<code>**形参</code>接收任意数量的关键字实参</strong>,范例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_profile</span>(<span class="hljs-params">first, last, **user_info</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot;</span> <br>    profile = &#123;&#125; <br>    profile[<span class="hljs-string">&#x27;first_name&#x27;</span>] = first <br>    profile[<span class="hljs-string">&#x27;last_name&#x27;</span>] = last <br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> user_info.items():<br>        profile[key] = value <br>    <span class="hljs-keyword">return</span> profile <br>user_profile = build_profile(<span class="hljs-string">&#x27;albert&#x27;</span>, <span class="hljs-string">&#x27;einstein&#x27;</span>, location=<span class="hljs-string">&#x27;princeton&#x27;</span>, field=<span class="hljs-string">&#x27;physics&#x27;</span>) <br><span class="hljs-built_in">print</span>(user_profile)<br></code></pre></td></tr></table></figure><p>形参**user_info中的两个星号让Python创建一个名为user_info的空字典，并将收到的所有名称—值对都封装到这个字典中</p><h3 id="8-6将函数存储在模块中"><a href="#8-6将函数存储在模块中" class="headerlink" title="8.6将函数存储在模块中"></a>8.6将函数存储在模块中</h3><p>函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解得多。你还可以更进一步，将函数存储在被称为模块的独立文件中，再将模块导入到主程序中。import语句允许在当前运行的程序文件中使用模块中的代码。</p><p><strong>导入整体模块</strong></p><p>要让函数是可导入的，得先创建模块。模块是扩展名为.py的文件，包含要导入到程序中的代码。</p><p>只需编写一条import语句并在其中指定模块名，就可在程序中使用该模块中的所有函数。如果你使用这种import语句导入了名为module_name.py的整个模块，就可使用下面的语法来使用其中任何一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">module_name.fuction_name()<br></code></pre></td></tr></table></figure><p><strong>导入特定的函数</strong></p><p>还可以导入模块中的特定函数，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> module_name <span class="hljs-keyword">import</span> fuction_name<br></code></pre></td></tr></table></figure><p>若使用这种语法，调用函数时就无需使用句点，与使用主体程序中的函数是一样的用法。</p><p><strong>使用as给函数指定别名</strong></p><p>如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名——函数的另一个名称，类似于外号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> module_name <span class="hljs-keyword">import</span> fuction_name <span class="hljs-keyword">as</span> fn<br></code></pre></td></tr></table></figure><p><strong>使用as给模块指定别名</strong></p><p>还可以给模块指定别名。通过给模块指定简短的别名（如给模块pizza指定别名p），让你能够更轻松地调用模块中的函数。引用模块内的函数的名称还是没有变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> module_name <span class="hljs-keyword">as</span> mn<br></code></pre></td></tr></table></figure><p><strong>导入模块中的所有函数</strong></p><p>使用星号（*）运算符可让Python导入模块中的所有函数。</p><p>import语句中的星号让Python将模块pizza中的每个函数都复制到这个程序文件中。由于导入了每个函数，可通过名称来调用每个函数，而无需使用句点表示法。但是强烈不建议这么做。</p><p><em>最佳的做法是，要么只导入你需要使用的函数，要么导入整个模块并使用句点表示法</em></p><h3 id="8-7函数编写指南"><a href="#8-7函数编写指南" class="headerlink" title="8.7函数编写指南"></a>8.7函数编写指南</h3><ul><li>编写函数时，需要牢记几个细节。应给函数指定描述性名称，且只在其中使用小写字母和下划线。</li><li>每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式。</li><li>给形参指定默认值时，等号两边不要有空格。</li><li>如果程序或模块包含多个函数，可使用两个空行将相邻的函数分开，这样将更容易知道前一个函数在什么地方结束，下一个函数从什么地方开始。</li><li>所有的import语句都应放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。</li></ul><h2 id="9-类"><a href="#9-类" class="headerlink" title="9.类"></a>9.类</h2><p>Python 中的类（Class）是一种面向对象编程（Object-Oriented Programming，简称 OOP）的概念，它允许我们通过创建对象来组织和管理代码。类是一种抽象的数据类型，用于封装数据和行为。</p><p>类定义了一组属性和方法，描述了对象的特征和行为。对象是类的实例，通过实例化类可以创建具体的对象。</p><p>下面是一个简单的类的示例，以便更好地理解：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 定义一个简单的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-comment"># 类属性</span><br>    species = <span class="hljs-string">&#x27;Human&#x27;</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, name, age</span>):<br>        <span class="hljs-comment"># 实例属性</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-comment"># 实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        print(f<span class="hljs-string">&quot;Hello, my name is &#123;self.name&#125; and I&#x27;m &#123;self.age&#125; years old.&quot;</span>)<br><br><span class="hljs-comment"># 创建对象</span><br>person1 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>)<br>person2 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">30</span>)<br><br><span class="hljs-comment"># 调用对象的方法</span><br>person1.greet()  <span class="hljs-comment"># 输出: Hello, my name is Alice and I&#x27;m 25 years old.</span><br>person2.greet()  <span class="hljs-comment"># 输出: Hello, my name is Bob and I&#x27;m 30 years old.</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个名为 <code>Person</code> 的类。它具有类属性 <code>species</code>，表示人类这个类别的物种。类还定义了一个初始化方法 <code>__init__()</code>，它在创建对象时被调用，用于设置对象的初始状态。<code>__init__()</code> 方法的第一个参数是 <code>self</code>，它表示类的实例本身。通过 <code>self</code> 可以访问和设置对象的属性。</p><p>类还定义了一个实例方法 <code>greet()</code>，用于打印个人信息。在调用实例方法时，不需要显式传递 <code>self</code> 参数，Python 会自动将对象实例作为第一个参数传递给方法。</p><p>通过创建类的实例，我们可以创建具体的对象。在上面的示例中，我们创建了两个 <code>Person</code> 类的对象 <code>person1</code> 和 <code>person2</code>。每个对象都具有自己的属性值，可以调用对象的方法来执行特定的操作。</p><p>类是面向对象编程中的核心概念之一，它提供了一种组织和封装代码的方式，使得代码更具可维护性、可扩展性和复用性。通过定义类和创建对象，我们可以按照面向对象的思想来编写更优雅和灵活的代码。</p><h3 id="9-1创建和使用类"><a href="#9-1创建和使用类" class="headerlink" title="9.1创建和使用类"></a>9.1创建和使用类</h3><ul><li>根据约定，在Python中，首字母大写的名称指的是类。</li><li>类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式</li><li>_<em>init</em>_()是一个特殊的方法，创建新实例时，Python都会自动运行它</li><li>_<em>init</em>_()的形参self必不可少，还必须位于其他形参的前面</li><li>每个与类相关联的方法调用都自动传递实参self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法</li><li>以self为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量</li><li>可将类视为有关如何创建实例的说明</li><li>首字母大写的名称指的是类，而小写的名称指的是根据类创建的实例</li></ul><h3 id="9-2使用类和实例"><a href="#9-2使用类和实例" class="headerlink" title="9.2使用类和实例"></a>9.2使用类和实例</h3><p>类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。在有些情况下，如设置默认值时，在方法__init__()内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参。</p><p>可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方法进行递增（增加特定的值）。</p><p><strong>直接修改属性的值</strong></p><p>要修改属性的值，最简单的方式是通过实例直接访问它。</p><p><strong>通过方法修改属性的值</strong></p><p><strong>通过方法对属性的值进行递增</strong></p><p>有时候需要将属性值递增特定的量，而不是将其设置为全新的值</p><h3 id="9-3继承"><a href="#9-3继承" class="headerlink" title="9.3继承"></a>9.3继承</h3><p>编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。</p><p><strong>子类的方法_<em>init</em>_()</strong></p><p>创建子类的实例时，Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法__init__()需要父类施以援手。</p><p>看下面这个范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        self.make = make<br>        self.model = model<br>        self.year = year<br>        self.odometer_reading = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_descriptive_name</span>(<span class="hljs-params">self</span>):<br>        long_name = <span class="hljs-built_in">str</span>(self.year) + <span class="hljs-string">&#x27; &#x27;</span> + self.make + <span class="hljs-string">&#x27; &#x27;</span> + self.model<br>        <span class="hljs-keyword">return</span> long_name.title()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This car has &quot;</span> + <span class="hljs-built_in">str</span>(self.odometer_reading) + <span class="hljs-string">&quot; miles on it.&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-keyword">if</span> mileage &gt;= self.odometer_reading:<br>            self.odometer_reading = mileage<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_odometer</span>(<span class="hljs-params">self, miles</span>):<br>        self.odometer_reading += miles<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span> <br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span> <br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br></code></pre></td></tr></table></figure><ul><li>创建子类时，父类必须包含在当前文件中，且位于子类前面</li><li>定义子类时，必须在括号内指定父类的名称</li><li>方法__init__()接受创建Car实例所需的信息</li><li>super()是一个特殊函数，帮助Python将父类和子类关联起来。这行代码让Python调用ElectricCar的父类的方法__init__()，让ElectricCar实例包含父类的所有属性。父类也称为超类（superclass），名称super因此而得名</li></ul><p><strong>给子类定义属性和方法</strong></p><p>让一个类继承另一个类后，可添加区分子类和父类所需的新属性和方法。</p><p><strong>重写父类的方法</strong></p><p>对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p><p><em>使用继承时，可让子类保留从父类那里继承而来的精华，并剔除不需要的糟粕</em></p><p><strong>将实例用作属性</strong></p><p>使用代码模拟实物时，你可能会发现自己给类添加的细节越来越多：属性和方法清单以及文件都越来越长。在这种情况下，可能需要将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。</p><p>例如，不断给ElectricCar类添加细节时，我们可能会发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下，我们可将这些属性和方法提取出来，放到另一个名为Battery的类中，并将一个Battery实例用作ElectricCar类的一个属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        self.make = make<br>        self.model = model<br>        self.year = year<br>        self.odometer_reading = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_descriptive_name</span>(<span class="hljs-params">self</span>):<br>        long_name = <span class="hljs-built_in">str</span>(self.year) + <span class="hljs-string">&#x27; &#x27;</span> + self.make + <span class="hljs-string">&#x27; &#x27;</span> + self.model<br>        <span class="hljs-keyword">return</span> long_name.title()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This car has &quot;</span> + <span class="hljs-built_in">str</span>(self.odometer_reading) + <span class="hljs-string">&quot; miles on it.&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-keyword">if</span> mileage &gt;= self.odometer_reading:<br>            self.odometer_reading = mileage<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_odometer</span>(<span class="hljs-params">self, miles</span>):<br>        self.odometer_reading += miles<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Battery</span>(): <br>    <span class="hljs-string">&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;</span> <br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, battery_size=<span class="hljs-number">70</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;</span> <br>        self.battery_size = battery_size <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This car has a &quot;</span> + <span class="hljs-built_in">str</span>(self.battery_size) + <span class="hljs-string">&quot;-kWh battery.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>): <br>    <span class="hljs-string">&quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;</span> <br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span> <br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br>        self.battery = Battery()<br><br>my_tesla = ElectricCar(<span class="hljs-string">&#x27;tesla&#x27;</span>, <span class="hljs-string">&#x27;model s&#x27;</span>, <span class="hljs-number">2016</span>) <br><span class="hljs-built_in">print</span>(my_tesla.get_descriptive_name()) <br>my_tesla.battery.describe_battery()<br></code></pre></td></tr></table></figure><ul><li>我们定义了一个名为Battery的新类，它没有继承任何类</li><li>法__init__()除self外，还有另一个形参battery_size</li><li>方法describe_battery()也移到了这个类中</li><li>在ElectricCar类中，我们添加了一个名为self.battery的属性。这行代码让Python创建一个新的Battery实例（由于没有指定尺寸，因此为默认值70），并将该实例存储在属性self.battery中</li></ul><h3 id="9-4导入类"><a href="#9-4导入类" class="headerlink" title="9.4导入类"></a>9.4导入类</h3><p>Python允许你将类存储在模块中，然后在主程序中导入所需的模块。</p><ul><li>导入单个类；<code>import module_name import class_name</code></li><li>在一个模块中存储多个类</li><li>从一个模块中导入多个类，从一个模块中导入多个类时，用逗号分隔了各个类;<code>import module_name import class_name1,class_name2</code></li><li>还可以导入整个模块，再使用句点表示法访问需要的类；使用语法<em>module_name.class_name</em>访问需要的类<code>import module_name</code></li><li>导入模块中的所有类；<code>from module_name import *</code> ，强烈不推荐使用这种方式导入类</li><li>在一个模块中导入另一个模块</li></ul><h3 id="9-5Python标准库"><a href="#9-5Python标准库" class="headerlink" title="9.5Python标准库"></a>9.5Python标准库</h3><p>Python标准库是一组模块，安装的Python都包含它。</p><p>可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import语句</p><h2 id="10-文件和异常"><a href="#10-文件和异常" class="headerlink" title="10.文件和异常"></a>10.文件和异常</h2><p>学习处理文件和保存数据可让你的程序使用起来更容易：用户将能够选择输入什么样的数据，以及在什么时候输入；用户使用你的程序做一些工作后，可将程序关闭，以后再接着往下做。</p><p>学习处理异常可帮助你应对文件不存在的情形，以及处理其他可能导致程序崩溃的问题。这让你的程序在面对错误的数据时更健壮——不管这些错误数据源自无意的错误，还是源自破坏程序的恶意企图。</p><p>打开文件时，可指定读取模式（’r’）、写入模式（’w’）、附加模式（’a’）或让你能够读取和写入文件的模式（’r+’）。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><h3 id="10-1从文件中读取数据"><a href="#10-1从文件中读取数据" class="headerlink" title="10.1从文件中读取数据"></a>10.1从文件中读取数据</h3><p><strong>读取整个文件</strong></p><p>函数open()接受一个参数：要打开的文件的名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object: <br>contents = file_object.read() <br><span class="hljs-built_in">print</span>(contents)<br></code></pre></td></tr></table></figure><p>关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存在bug，导致close()语句未执行，文件将不会关闭。</p><p>read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print语句中使用rstrip()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;pi_digits.txt&#x27;</span>) <span class="hljs-keyword">as</span> file_object: <br>contents = file_object.read() <br><span class="hljs-built_in">print</span>(contents.rstrip())<br></code></pre></td></tr></table></figure><p>要让Python打开不与程序文件位于同一个目录中的文件，需要提供文件路径，它让Python到系统的特定位置去查找。</p><p><strong>逐行读取</strong></p><p>要以每次一行的方式检查文件，可对文件对象使用for循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span> <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object: <br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file_object: <br>            <span class="hljs-built_in">print</span>(line)<br></code></pre></td></tr></table></figure><p>使用关键字with时，open()返回的文件对象只在with代码块内可用。如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行存储在一个列表中，并在with代码块外使用该列表：你可以立即处理文件的各个部分，也可推迟到程序后面再处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;pi_digits.txt&#x27;</span> <br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> file_object: <br>     lines = file_object.readlines() <br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines: <br>     <span class="hljs-built_in">print</span>(line.rstrip())<br></code></pre></td></tr></table></figure><p><strong>使用文件的内容</strong></p><p>strip()可以删除空格</p><p>读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数int()将其转换为整数，或使用函数float()将其转换为浮点数。</p><p>对于你可处理的数据量，Python没有任何限制；只要系统的内存足够多，你想处理多少数据都可以</p><h3 id="10-2写入文件"><a href="#10-2写入文件" class="headerlink" title="10.2写入文件"></a>10.2写入文件</h3><p>保存数据的最简单的方式之一是将其写入到文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">filename = <span class="hljs-string">&#x27;programming.txt&#x27;</span> <br> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file_object: <br> file_object.write(<span class="hljs-string">&quot;I love programming.&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（’w’）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。</p><p>函数write()不会在你写入的文本末尾添加换行符，因此如果你写入多行时没有指定换行符，像显示到终端的输出一样，还可以使用空格、制表符和空行来设置这些输出的格式</p><p>如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。你以附加模式打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python将为你创建一个空文件。</p><h3 id="10-3异常"><a href="#10-3异常" class="headerlink" title="10.3异常"></a>10.3异常</h3><p>Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当发生让Python不知所措的错误时，它都会创建一个异常对象。如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。</p><p>异常是使用try-except代码块处理的。try-except代码块让Python执行指定的操作，同时告诉Python发生异常时怎么办。使用了try-except代码块时，即便出现异常，程序也将继续运行：显示你编写的友好的错误消息，而不是令用户迷惑的traceback。</p><p>通过将可能引发错误的代码放在try-except代码块中，可提高这个程序抵御错误的能力</p><p>try-except-else代码块的工作原理大致如下：Python尝试执行try代码块中的代码；只有可能引发异常的代码才需要放在try语句中。有时候，有一些仅在try代码块成功执行时才需要运行的代码；这些代码应放在else代码块中。except代码块告诉Python，如果它尝试运行try代码块中的代码时引发了指定的异常，该怎么办。</p><p><strong>处理 FileNotFoundError 异常</strong></p><p>使用文件时，一种常见的问题是找不到文件：你要查找的文件可能在其他地方、文件名可能不正确或者这个文件根本就不存在。对于所有这些情形，都可使用try-except代码块以直观的方式进行处理。</p><p><strong>分析文本</strong></p><p>使用try-except代码块提供了两个重要的优点：避免让用户看到traceback；让程序能够继续分析能够找到的其他文件。</p><p><strong>失败时一声不吭</strong></p><p>有时候你希望程序在发生异常时一声不吭，就像什么都没有发生一样继续运行。要让程序在失败时一声不吭，可像通常那样编写try代码块，但在except代码块中明确地告诉Python什么都不要做。Python有一个pass语句，可在代码块中使用它来让Python什么都不要做。</p><p>pass语句还充当了占位符，它提醒你在程序的某个地方什么都没有做，并且以后也许要在这里做些什么</p><p>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络链接，就有可能出现异常。凭借经验可判断该在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。</p><h3 id="10-4存储数据"><a href="#10-4存储数据" class="headerlink" title="10.4存储数据"></a>10.4存储数据</h3><p>模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json在Python程序之间分享数据。更重要的是，JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。这是一种轻便格式，很有用，也易于学习。</p><p><strong>使用json.dump()和json.load()</strong></p><p>函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。</p><p><strong>重构</strong></p><p>你经常会遇到这样的情况：代码能够正确地运行，但可做进一步的改进——将代码划分为一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展。</p><h2 id="11-测试"><a href="#11-测试" class="headerlink" title="11.测试"></a>11.测试</h2><h3 id="11-1测试函数"><a href="#11-1测试函数" class="headerlink" title="11.1测试函数"></a>11.1测试函数</h3><p>编写函数或类时，还可为其编写测试。通过测试，可确定代码面对各种输入都能够按要求的那样工作。</p><ul><li><p>Python标准库中的模块unittest提供了代码测试工具。单元测试用于核实函数的某个方面没有问题；</p></li><li><p>测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。</p></li><li><p>全覆盖式测试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。</p></li><li><p>创建测试用例的语法需要一段时间才能习惯，但测试用例创建后，再添加针对函数的单元测试就很简单了</p></li><li><p>要为函数编写测试用例，可先导入模块unittest以及要测试的函数，再创建一个继承unittest.TestCase的类，并编写一系列方法对函数行为的不同方面进行测试</p></li><li><p>使用unittest类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致</p></li><li><p>测试未通过时，不要修改测试，而应修复导致测试不能通过的代码：检查刚对函数所做的修改，找出导致函数行为不符合预期的修改</p></li></ul><p>范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest <br><span class="hljs-keyword">from</span> name_function <span class="hljs-keyword">import</span> get_formatted_name<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NamesTestCase</span>(unittest.TestCase): <br>     <span class="hljs-string">&quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;</span> <br> <br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_first_last_name</span>(<span class="hljs-params">self</span>): <br>         <span class="hljs-string">&quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span> <br>         formatted_name = get_formatted_name(<span class="hljs-string">&#x27;janis&#x27;</span>, <span class="hljs-string">&#x27;joplin&#x27;</span>) <br>         self.assertEqual(formatted_name, <span class="hljs-string">&#x27;Janis Joplin&#x27;</span>) <br>        <br>unittest.main()<br></code></pre></td></tr></table></figure><p>Python在unittest.TestCase类中提供了很多断言方法:</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>assertEqual(a, b)</td><td>核实a &#x3D;&#x3D; b</td></tr><tr><td>assertNotEqual(a, b)</td><td>核实a !&#x3D; b</td></tr><tr><td>assertTrue(x)</td><td>核实x为True</td></tr><tr><td>assertFalse(x)</td><td>核实x为False</td></tr><tr><td>assertIn(item, list)</td><td>核实item在list中</td></tr><tr><td>assertNotIn(item, list)</td><td>核实item不在list中</td></tr></tbody></table><h3 id="11-2测试类"><a href="#11-2测试类" class="headerlink" title="11.2测试类"></a>11.2测试类</h3><p>类的测试与函数的测试相似——你所做的大部分工作都是测试类中方法的行为</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑群晖显示真实CPU信息</title>
    <link href="/2023/05/31/%E9%BB%91%E7%BE%A4%E6%99%96%E6%98%BE%E7%A4%BA%E7%9C%9F%E5%AE%9ECPU%E4%BF%A1%E6%81%AF/"/>
    <url>/2023/05/31/%E9%BB%91%E7%BE%A4%E6%99%96%E6%98%BE%E7%A4%BA%E7%9C%9F%E5%AE%9ECPU%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>黑群晖信息中心显示的CPU信息不正确，例如918+对应的CPU为J3455，而不是本机真实的CPU信息，逼死强迫症，可以通过打补丁让其显示真实的CPU信息，操作方法如下：</strong></p><h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><ol><li><p>通过ssh登录到群晖后台</p></li><li><p>切换到root账号下，并切换到期望存放补丁文件的目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br>cd /volumue5/download<br></code></pre></td></tr></table></figure></li><li><p>通过wget命令下载补丁文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/FOXBI/ch_cpuinfo/releases/download/ch_cpuinfo/ch_cpuinfo.tar<br></code></pre></td></tr></table></figure></li><li><p>解压补丁包文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar xvf ch_cpuinfo.tar<br>chmod +x ch_cpuinfo<br></code></pre></td></tr></table></figure></li><li><p>执行补丁文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./ch_cpuinfo<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305311942781.webp" alt="输入1为首次执行"></p><p>&gt;输入1表示首次执行</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305311942949.webp" alt="输入2为重新执行"></p><p>&gt;输入2表示重新安装</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305311943165.webp" alt="输入3为恢复默认"></p><p>&gt;输入3表示恢复默认</p></li><li><p>执行完毕后，退出账号并重新登录，刷新页面就会看到信息中心已经显示了正确的CPU信息了</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305311955386.webp"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑群晖918+ CPU不自动变频</title>
    <link href="/2023/05/30/%E9%BB%91%E7%BE%A4%E6%99%96CPU%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%8F%98%E9%A2%91/"/>
    <url>/2023/05/30/%E9%BB%91%E7%BE%A4%E6%99%96CPU%E4%B8%8D%E8%87%AA%E5%8A%A8%E5%8F%98%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p><strong>硬件配置：</strong></p><ul><li>CPU：i3-8100</li><li>主板：昂达B365SD4-ITX</li><li>内存：12G</li></ul><p><strong>系统版本：</strong>918+ 7.1.1-42962</p><p>安装黑群晖系统后，发现CPU一直处于最高频率在运行，不会自动变频，并且available cpufreq governors只有<code>powersave</code>,<code>performance</code>, <code>userspace</code>这三个，而不通常的performance 、power save 、user<em>space</em>、conservative 和 ondemand 五种。</p><p>偶然的机会在<a href="https://xpenology.com/forum/topic/19846-cpu-frequency-scaling-for-ds918/">CPU Frequency scaling for DS918+ - Software Modding - XPEnology Community</a>看到了解决方案。</p><blockquote><p>项目地址：<a href="https://github.com/Trauma/cpufreq-userspace-scaler">https://github.com/Trauma/cpufreq-userspace-scaler</a></p><h1 id="cpufreq-userspace-scaler"><a href="#cpufreq-userspace-scaler" class="headerlink" title="cpufreq-userspace-scaler"></a>cpufreq-userspace-scaler</h1><h5 id="Cpu-frequency-scaling-script-for-cpufreq-userspace-governor"><a href="#Cpu-frequency-scaling-script-for-cpufreq-userspace-governor" class="headerlink" title="Cpu frequency scaling script for cpufreq userspace governor"></a>Cpu frequency scaling script for cpufreq userspace governor</h5><h2 id="If-you’re-missing-ondemand-or-conservative-governors-this-script-is-for-you"><a href="#If-you’re-missing-ondemand-or-conservative-governors-this-script-is-for-you" class="headerlink" title="If you’re missing ondemand or conservative governors, this script is for you."></a>If you’re missing ondemand or conservative governors, this script is for you.</h2><p>This script is scaling cpu frequency according to current average load. You can set 2 frequency steps : low, mid. This 2 thresholds will automatically set cpu frequency accordingly :</p><ul><li>the threshold will set the cpu to his minimal frequency, unless you force it to <code>lowload</code> <code>scalingminfreq</code></li><li>the threshold will set the cpu to approximate mid range cpu frequency, if load goes higher it will scale to max <code>midload</code> <code>scalingmaxfreq</code></li></ul><p>If you set and&#x2F;or the cpu will never override those values.<code>scalingmaxfreq</code> <code>scalingminfreq</code></p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage :"></a>Usage :</h3><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters :"></a>Parameters :</h3><table><thead><tr><th>Variable name</th><th>Default</th><th>Type</th><th>Comments</th></tr></thead><tbody><tr><td>lowload</td><td>auto &#x2F; 30%</td><td>integer between 000 and 999</td><td>050 &#x3D; load average : 0.50</td></tr><tr><td>midload</td><td>auto &#x2F; 60%</td><td>integer between 000 and 999</td><td>065 &#x3D; load average : 0.65</td></tr><tr><td>scalingminfreq</td><td>auto</td><td>integer in hertz</td><td>800000 &#x3D; 800 Mhz</td></tr><tr><td>scalingmaxfreq</td><td>auto</td><td>integer in hertz</td><td>2500000 &#x3D; 2,5 Ghz</td></tr></tbody></table><h3 id="Default-commande-line"><a href="#Default-commande-line" class="headerlink" title="Default commande line :"></a>Default commande line :</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">./scaling.sh &amp;</span><br></code></pre></td></tr></table></figure><h3 id="Custom-command-line-example"><a href="#Custom-command-line-example" class="headerlink" title="Custom command line example :"></a>Custom command line example :</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;<span class="hljs-attribute">lowload</span>=100 <span class="hljs-attribute">midload</span>=200 <span class="hljs-attribute">scalingmaxfreq</span>=2000000 <span class="hljs-attribute">scalingminfreq</span>=1500000 ./scaling.sh &amp;<br></code></pre></td></tr></table></figure><h3 id="Systemd-service-installer"><a href="#Systemd-service-installer" class="headerlink" title="Systemd service installer"></a>Systemd service installer</h3><p><em>for DSM 7.0 and above</em></p><ol><li>If needed, set desired lowload and midload values in <code>cpufreq-userspace-scaler.service</code></li><li>Launch the installer <code>./install.sh</code></li></ol></blockquote><p>使用方法：</p><p>1、将上述项目中的三个文件下载到群晖里</p><p>2、SSH登录到服务器</p><p>3、执行.&#x2F;install.sh</p>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑群晖引导自动编译</title>
    <link href="/2023/05/30/%E9%BB%91%E7%BE%A4%E6%99%96%E5%BC%95%E5%AF%BC%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91/"/>
    <url>/2023/05/30/%E9%BB%91%E7%BE%A4%E6%99%96%E5%BC%95%E5%AF%BC%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>黑群晖的引导盘制作原来一直是个挺复杂的事情，但是自从有了下面这些项目，引导的制作变得非常简单，感谢大神们！</p><ul><li><a href="https://github.com/pocopico/tinycore-redpill">pocopico&#x2F;tinycore-redpill</a></li><li><a href="https://github.com/fbelavenuto/arpl">fbelavenuto&#x2F;arpl: Automated Redpill Loader</a></li><li><a href="https://github.com/wjz304/arpl-i18n">wjz304&#x2F;arpl-i18n: Automated Redpill Loader(i18n)</a> arpl i18n (多语言优化版)</li></ul><h2 id="arpl自动制作引导盘"><a href="#arpl自动制作引导盘" class="headerlink" title="arpl自动制作引导盘"></a>arpl自动制作引导盘</h2><p>下面是基于arpl的操作步骤：</p><p>1、准备一个2G以上的U盘</p><p>2、下载镜像文件</p><p>​原版：<a href="https://github.com/fbelavenuto/arpl/releases">Releases · fbelavenuto&#x2F;arpl</a></p><p>​多语言版：<a href="https://github.com/wjz304/arpl-i18n/releases">Releases · wjz304&#x2F;arpl-i18n</a></p><p>3、通过写盘工具（如<a href="https://etcher.balena.io/">balenaEtcher </a>等）写入到U盘中</p><p>4、将U盘插入到黑群晖机器上，开机设置从U盘启动</p><p>5、启动完成后会在进入如下页面：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301944686.webp"></p><p>6、可以通过下面两种方式登录到系统：</p><ul><li>从另一台机器进入同一网络，在浏览器中输入屏幕上提供的地址<code>http://&lt;ip&gt;:7681</code></li><li>从另一台机器进入同一网络，使用ssh客户端，用户名： <code>root</code> 和密码： <code>Redp1lL-1s-4weSomE</code></li></ul><p>7、登录系统后输入<code>munu.sh</code>回车进入配置页面：</p><ul><li>选择型号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301949724.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301951276.webp"></p><ul><li>选择系统版本</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301951831.webp"></p><ul><li>进入“Serial”菜单，选择“Generate a random Serial number”，也可以选择手动输入。</li><li>选择“Build”选项，等待加载器生成</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301954764.webp"></p><ul><li>选择“Boot”选项，等待DSM启动:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301956866.webp"></p><p>8、通过以上步骤就完成一个引导盘的制作了。</p><h2 id="wjz304版本的一些命令"><a href="#wjz304版本的一些命令" class="headerlink" title="wjz304版本的一些命令"></a>wjz304版本的一些命令</h2><ul><li><p>arpl各版本间切换(手动方式, 全量) (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 shell 中下载需要的版本或者手动上传到/opt/arpl/下</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Download the required version <span class="hljs-keyword">in</span> the shell or manually upload it to/opt/arpl/</span><br>curl -kL -o /opt/arpl/arpl.zip https://github.com/wjz304/arpl-i18n/releases/download/23.4.5/arpl-i18n-23.4.5.img.zip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载挂载的引导盘</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Uninstalling the mounted boot disk</span><br>umount /mnt/p1 /mnt/p2 /mnt/p3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压 并写入到引导盘</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Decompress and write to the boot disk</span><br>unzip -p arpl.zip | dd of=`blkid | grep &#x27;LABEL=&quot;ARPL3&quot;&#x27; | cut -d3 -f1` bs=1M conv=fsync<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启 reboot</span><br>reboot<br></code></pre></td></tr></table></figure></li><li><p>arpl各版本间切换(菜单更新, 增量)(arpl &#x2F; arpl-zh_CN &#x2F; arpl-i18n(ver &lt; 23.4.5)):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">shell 下输入以下命令修改更新 repo.</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果要切换原版修改第二条命令中的 wjz304/arpl-i18n 为 fbelavenuto/arpl</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果切换中文版修改第二条命令中的 wjz304/arpl-i18n 为 wjz304/arpl-zh_CN</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Enter the following <span class="hljs-built_in">command</span> under the shell to modify and update repo</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If you want to switch the original version and modify wjz304/arpl-i18n to fbelavenuto/arpl <span class="hljs-keyword">in</span> the second <span class="hljs-built_in">command</span>.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If you switch to the Chinese version and modify the wjz304/arpl-i18n to wjz304/arpl_zh_CN <span class="hljs-keyword">in</span> the second <span class="hljs-built_in">command</span>.</span><br>CURREPO=`grep &quot;github.com.*update&quot; menu.sh | sed -r &#x27;s/.*com\/(.*)\/releases.*/\1/&#x27;`<br>sed -i &quot;s|$&#123;CURREPO&#125;|wjz304/arpl-i18n|g&quot; /opt/arpl/menu.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入设置菜单执行更新arpl操作即可. 更新后请重启.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Simply enter the main menu and perform the update arpl operation. Please restart after the update.</span><br></code></pre></td></tr></table></figure></li><li><p>arpl 备份 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">备份为 disk.img.gz, 自行导出.</span><br>dd if=`blkid | grep &#x27;LABEL=&quot;ARPL3&quot;&#x27; | cut -d3 -f1` | gzip &gt; disk.img.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">结合 transfer.sh 直接导出链接</span><br>curl -skL --insecure -w &#x27;\n&#x27; --upload-file disk.img.gz https://transfer.sh<br></code></pre></td></tr></table></figure></li><li><p>arpl 持久化 &#x2F;opt&#x2F;arpl 目录的修改 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">RDXZ_PATH=/tmp/rdxz_tmp<br>mkdir -p &quot;$&#123;RDXZ_PATH&#125;&quot;<br>(cd &quot;$&#123;RDXZ_PATH&#125;&quot;; xz -dc &lt; &quot;/mnt/p3/initrd-arpl&quot; | cpio -idm) &gt;/dev/null 2&gt;&amp;1 || true<br>rm -rf &quot;$&#123;RDXZ_PATH&#125;/opt/arpl&quot;<br>cp -rf &quot;/opt/arpl&quot; &quot;$&#123;RDXZ_PATH&#125;/opt&quot;<br>(cd &quot;$&#123;RDXZ_PATH&#125;&quot;; find . 2&gt;/dev/null | cpio -o -H newc -R root:root | xz --check=crc32 &gt; &quot;/mnt/p3/initrd-arpl&quot;) || true<br>rm -rf &quot;$&#123;RDXZ_PATH&#125;&quot;<br></code></pre></td></tr></table></figure></li><li><p>arpl 修改所有的pat下载源 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/global.synologydownload.com/cndl.synology.cn/g&#x27; /opt/arpl/menu.sh `find /opt/arpl/model-configs/ -type f&#x27;`<br>sed -i &#x27;s/global.download.synology.com/cndl.synology.cn/g&#x27; /opt/arpl/menu.sh `find /opt/arpl/model-configs/ -type f&#x27;`<br></code></pre></td></tr></table></figure></li><li><p>arpl 更新慢的解决办法 (arpl-zh_CN &#x2F; arpl):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s|https://.*/https://|https://|g&#x27; /opt/arpl/menu.sh <br>sed -i &#x27;s|https://github.com|https://ghproxy.homeboyc.cn/&amp;|g&#x27; /opt/arpl/menu.sh <br>sed -i &#x27;s|https://api.github.com|http://ghproxy.homeboyc.cn/&amp;|g&#x27; /opt/arpl/menu.sh<br></code></pre></td></tr></table></figure></li><li><p>arpl 去掉pat的hash校验 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/HASH&#125;&quot; ]/&amp; \&amp;\&amp; false/g&#x27; /opt/arpl/menu.sh<br></code></pre></td></tr></table></figure></li><li><p>arpl 下获取网卡驱动 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">for i in `ls /sys/class/net | grep -v &#x27;lo&#x27;`; do echo $i -- `ethtool -i $i | grep driver`; done<br></code></pre></td></tr></table></figure></li><li><p>arpl 使用自定义的dts文件 (arpl(ver &gt; v1.1-beta2a &#x2F; arpl-zh_CN):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将dts文件放到/mnt/p1下,并重命名为model.dts. <span class="hljs-string">&quot;/mnt/p1/model.dts&quot;</span></span><br>sed -i &#x27;/^.*\/addons\/disks.sh.*$/a [ -f &quot;\/mnt\/p1\/model.dts&quot; ] \&amp;\&amp; cp &quot;\/mnt\/p1\/model.dts&quot; &quot;$&#123;RAMDISK_PATH&#125;\/addons\/model.dts&quot;&#x27; /opt/arpl/ramdisk-patch.sh<br></code></pre></td></tr></table></figure></li><li><p>arpl 离线安装 (arpl_zh_CN(ver &gt; ++-v1.3) &#x2F; arpl-i18n):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. arpl 下<br><span class="hljs-meta prompt_"># </span><span class="language-bash">arpl下获取型号版本的pat下载地址 (替换以下命令中的 版本号和型号部分)</span><br>yq eval &#x27;.builds.42218.pat.url&#x27; &quot;/opt/arpl/model-configs/DS3622xs+.yml&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将pat重命名为&lt;型号&gt;-&lt;版本&gt;.pat, 放入 /mnt/p3/dl/ 下</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例: /mnt/p3/dl/DS3622xs+-42218.pat</span><br><br>2. pc 下<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 DG等其他软件打开arpl.img, 将pat重命名为&lt;型号&gt;-&lt;版本&gt;.pat, 放入 第3个分区的 /dl/ 下.</span><br></code></pre></td></tr></table></figure></li><li><p>arpl 增删驱动 (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.首先你要有对应平台的驱动 比如 SA6400 7.1.1 增加 r8125</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.解包</span><br>mkdir -p /mnt/p3/modules/epyc7002-5.10.55<br>gzip -dc /mnt/p3/modules/epyc7002-5.10.55.tgz | tar xf - -C /mnt/p3/modules/epyc7002-5.10.55<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.放入或删除驱动</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.打包</span><br>tar -cf /mnt/p3/modules/epyc7002-5.10.55.tar -C /mnt/p3/modules/epyc7002-5.10.55 .<br>gzip -c /mnt/p3/modules/epyc7002-5.10.55.tar &gt; /mnt/p3/modules/epyc7002-5.10.55.tgz<br>rm -rf /mnt/p3/modules/epyc7002-5.10.55.tar /mnt/p3/modules/epyc7002-5.10.55<br></code></pre></td></tr></table></figure></li></ul><h2 id="一些有用的群晖命令"><a href="#一些有用的群晖命令" class="headerlink" title="一些有用的群晖命令"></a>一些有用的群晖命令</h2><ul><li><p>ssh 开启 root 权限:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br>sed -i &#x27;s/^.*PermitRootLogin.*$/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config  <br>synouser --setpw root xxxxxx  # xxxxxx 为你要设置的密码<br>systemctl restart sshd<br></code></pre></td></tr></table></figure></li><li><p>dsm下挂载引导盘:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br>echo 1 &gt; /proc/sys/kernel/syno_install_flag<br>ls /dev/synoboot*    # 正常会有 /dev/synoboot  /dev/synoboot1  /dev/synoboot2  /dev/synoboot3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载第1个分区</span><br>mkdir -p /tmp/synoboot1 <br>mount /dev/synoboot1 /tmp/synoboot1 <br>ls /tmp/synoboot1/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载第2个分区</span><br>mkdir -p /tmp/synoboot2<br>mount /dev/synoboot2 /tmp/synoboot2<br>ls /tmp/synoboot2/<br></code></pre></td></tr></table></figure></li><li><p>dsm下重启到arpl(免键盘) (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i  # 输入密码<br>/usr/bin/arpl-reboot.sh &quot;config&quot;<br></code></pre></td></tr></table></figure></li><li><p>dsm下修改sn (Any version):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i  # 输入密码<br>SN=xxxxxxxxxx   # 输入你要设置的SN<br>echo 1 &gt; /proc/sys/kernel/syno_install_flag<br>[ -b &quot;/dev/synoboot1&quot; ] &amp;&amp; (mkdir -p /tmp/synoboot1; mount /dev/synoboot1 /tmp/synoboot1)<br>[ -f &quot;/tmp/synoboot1/user-config.yml&quot; ] &amp;&amp; OLD_SN=`grep &#x27;^sn:&#x27; /tmp/synoboot1/user-config.yml | sed -r &#x27;s/sn:(.*)/\1/; s/[\&quot; ]//g&#x27;`<br>[ -n &quot;$&#123;OLD_SN&#125;&quot; ] &amp;&amp; sed -i &quot;s/$&#123;OLD_SN&#125;/$&#123;SN&#125;/g&quot; /tmp/synoboot1/user-config.yml<br>reboot<br></code></pre></td></tr></table></figure></li><li><p>群晖 opkg 包管理:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O - http://bin.entware.net/x64-k3.2/installer/generic.sh | /bin/sh<br>/opt/bin/opkg update<br>/opt/bin/opkg install rename<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分享</tag>
      
      <tag>黑群晖</tag>
      
      <tag>引导</tag>
      
      <tag>arpl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群晖自动切换壁纸</title>
    <link href="/2023/05/30/%E7%BE%A4%E6%99%96%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%A3%81%E7%BA%B8/"/>
    <url>/2023/05/30/%E7%BE%A4%E6%99%96%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%A3%81%E7%BA%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>每日定时自动获取Bing的每日壁纸图片，自动更换登录界面的背景为bing今日美图，并且替换欢迎信息为美图简介。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301718741.webp"></p><h2 id="获取脚本"><a href="#获取脚本" class="headerlink" title="获取脚本"></a>获取脚本</h2><p>原始脚本在<a href="https://github.com/kkkgo/DSM_Login_BingWallpaper">kkkgo&#x2F;DSM_Login_BingWallpaper: 群晖登录壁纸自动换 (github.com)</a>，做了下简单修改，设置为壁纸的图片分辨率为1920x1080，保存的为高清的版本。</p><p>下面是修改过的脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置你的语言</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> your language(en-US,zh-CN...)</span><br>lang=&quot;zh-CN&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如需收集保存壁纸,请去掉下面注释,设置保存文件夹路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在FileStation里面右键文件夹属性可以看到路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If you want to collect and save Wallpapers,</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">please remove the comment below and <span class="hljs-built_in">set</span> the savepath.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Right click the folder property <span class="hljs-keyword">in</span> FileStation to see the path.</span><br><br>savepath=&quot;/volume5/Download/BingPicture/wallpaper_uhd&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如需下载4k分辨率,请设置res=4k</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如需下载体积更大的4k以上分辨率的原始图片,请设置res=raw</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">To download 4K resolution, <span class="hljs-built_in">set</span> res=4K</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">To download a larger original picture, <span class="hljs-built_in">set</span> res=raw</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">res=4k</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改用户桌面壁纸,注释后会替换系统的wallpaper1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">你需要清空浏览器缓存查看效果，仅在DSM7.x上测试.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Modify user desktop wallpaper.Only <span class="hljs-built_in">test</span> <span class="hljs-keyword">for</span> DMS7.x.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">System <span class="hljs-string">&quot;Wallpaper1&quot;</span> will replaced by remove the comment.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">You need to clear the browser cache to see the effect.</span><br><br>desktop=yes<br><br>echo &quot;[x]Collecting information...&quot;<br>pic=&quot;https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&quot;<br>if [ &quot;$res&quot; != &quot;&quot; ]<br>then pic=&quot;https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;uhd=1&amp;uhdwidth=3840&amp;uhdheight=2160&quot;<br>fi<br>pic=$(wget -t 5 --no-check-certificate -qO- $pic --header=&quot;cookie:_EDGE_S=mkt=$lang&quot;)<br>echo $pic|grep -q enddate||exit<br>link=$(echo https://www.bing.com$(echo $pic|sed &#x27;s/.\+&quot;url&quot;[:&quot; ]\+//g&#x27;|sed &#x27;s/&quot;.\+//g&#x27;))<br>if [ &quot;$savepath&quot; != &quot;&quot; ]<br>then linkd=$(echo https://www.bing.com$(echo $pic|sed &#x27;s/.\+&quot;url&quot;[:&quot; ]\+//g&#x27;|sed &#x27;s/&quot;.\+//g&#x27;|sed &#x27;s/1920x1080/UHD/g&#x27;))<br>fi<br>date=$(echo $pic|grep -Eo &#x27;&quot;enddate&quot;:&quot;[0-9]+&#x27;|grep -Eo &#x27;[0-9]+&#x27;|head -1)<br>if [ &quot;$date&quot; == &quot;&quot; ]<br>then date=$(date +%Y%m%d)<br>fi<br>title=$(echo $pic|sed &#x27;s/.\+&quot;title&quot;:&quot;//g&#x27;|sed &#x27;s/&quot;.\+//g&#x27;)<br>copyright=$(echo $pic|sed &#x27;s/.\+&quot;copyright[:&quot; ]\+//g&#x27;|sed &#x27;s/&quot;.\+//g&#x27;)<br>keyword=$(echo $copyright|sed &#x27;s/, /-/g&#x27;|cut -d&quot; &quot; -f1|grep -Eo &#x27;[^()\\/:*?&quot;&lt;&gt;]+&#x27;|head -1)<br>filename=$date&quot;@&quot;$title&quot;-&quot;$keyword&quot;.jpg&quot;<br>echo &quot;Link:&quot;$link<br>echo &quot;Linkd:&quot;$linkd<br>echo &quot;Date:&quot;$date<br>echo &quot;Title:&quot;$title<br>echo &quot;Copyright:&quot;$copyright<br>echo &quot;Keyword:&quot;$keyword<br>echo &quot;Filename:&quot;$filename<br><br>echo &quot;[x]Downloading wallpaper...&quot;<br>tmpfile=/tmp/$filename<br>wget -t 5 --no-check-certificate  $link -qO $tmpfile<br>ls -lah $tmpfile||exit<br><br>echo &quot;[x]Copying wallpaper...&quot;<br>if [ &quot;$savepath&quot; != &quot;&quot; ]<br>then wget -t 5 --no-check-certificate  $linkd -qO $savepath/$filename<br>echo &quot;Save:&quot;$savepath<br>ls -lah &quot;$savepath&quot;|grep $date<br>cd &quot;$savepath&quot;<br>chmod 777 $filename<br>else echo &quot;savepath is not set, skip copy.&quot;<br>fi<br><br>echo &quot;[x]Setting welcome msg...&quot;<br>sed -i s/login_welcome_title=.*//g /etc/synoinfo.conf<br>echo &quot;login_welcome_title=\&quot;$title\&quot;&quot;&gt;&gt;/etc/synoinfo.conf<br>sed -i s/login_welcome_msg=.*//g /etc/synoinfo.conf<br>echo &quot;login_welcome_msg=\&quot;$copyright\&quot;&quot;&gt;&gt;/etc/synoinfo.conf<br><br>echo &quot;[x]Applying login wallpaper...&quot;<br>sed -i s/login_background_customize=.*//g /etc/synoinfo.conf<br>echo &quot;login_background_customize=\&quot;yes\&quot;&quot;&gt;&gt;/etc/synoinfo.conf<br>sed -i s/login_background_type=.*//g /etc/synoinfo.conf<br>echo &quot;login_background_type=\&quot;fromDS\&quot;&quot;&gt;&gt;/etc/synoinfo.conf<br>rm -rf /usr/syno/etc/login_background*.jpg<br>cp -f $tmpfile /usr/syno/etc/login_background.jpg<br>ln -sf /usr/syno/etc/login_background.jpg /usr/syno/etc/login_background_hd.jpg<br><br>echo &quot;[x]Clean...&quot;<br>rm -f /tmp/bing_*.jpg<br><br>if [ &quot;$desktop&quot; == &quot;yes&quot; ]<br>then echo &quot;[x]Applying user desktop wallpaper...&quot;<br>mkdir -p /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/<br>mkdir -p /usr/syno/synoman/webman/resources/images/1x/default_wallpaper/<br>mkdir -p /usr/syno/synoman/webman/resources/images/default/1x/default_wallpaper/<br>mkdir -p /usr/syno/synoman/webman/resources/images/default_wallpaper/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">7.0</span><br>cp -f /usr/syno/etc/login_background.jpg /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg<br>ln -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/1x/default_wallpaper/dsm7_01.jpg<br><span class="hljs-meta prompt_">#</span><span class="language-bash">6.0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default/1x/default_wallpaper/default_wallpaper.jpg</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default/1x/default_wallpaper/dsm6_01.jpg</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default/1x/default_wallpaper/dsm6_02.jpg</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-comment">#5.2</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default_wallpaper/default_wallpaper.jpg</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-comment">#5.1</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default_wallpaper/01.jpg</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /usr/syno/synoman/webman/resources/images/2x/default_wallpaper/dsm7_01.jpg /usr/syno/synoman/webman/resources/images/default_wallpaper/02.jpg</span><br>fi<br></code></pre></td></tr></table></figure><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><ol><li>控制面板-任务计划-新增：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301711860.webp" alt="新增任务"></p><p>​用户账号记得选择root</p><ol start="2"><li>计划里设置每天跑脚本的时间</li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301713391.webp" alt="执行时间"></p><ol start="3"><li>任务设置里输入执行脚本的命令</li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301715084.webp" alt="任务内容"></p><ol start="4"><li><p>确定就完成任务的设置了，如果想马上看到效果可以选择手动立即执行，然后退出登录账号并<code>Ctrl+F5</code>刷新浏览器即可看到效果了 </p></li><li><p>可以看到图片也保存到设置的目录了，并且保存下来的是高分辨率的</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305301720910.webp"></p>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群晖系统Synology DSM安装ipkg包管理</title>
    <link href="/2023/05/29/%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9FSynology-DSM%E5%AE%89%E8%A3%85ipkg%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2023/05/29/%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9FSynology-DSM%E5%AE%89%E8%A3%85ipkg%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p>打开终端，我使用的是xshell，使用群晖的管理员账号和密码登录，登录成功后，可使用下面命令切换到root账号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br></code></pre></td></tr></table></figure><p>之后输入密码（与管理员的密码相同）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载bootstrap并执行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/syno-i686-bootstrap_1.2-7_i686.xsh<br>chmod +x syno-i686-bootstrap_1.2-7_i686.xsh<br>sh syno-i686-bootstrap_1.2-7_i686.xsh<br></code></pre></td></tr></table></figure><p>终端返回：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">Optware Bootstrap for syno-i686.<br>Extracting archive... please wait<br>bootstrap/<br>bootstrap/bootstrap.sh<br>bootstrap/ipkg-opt.ipk<br>bootstrap/ipkg.sh<br>1216+1 records in<br>1216+1 records out<br>bootstrap/optware-bootstrap.ipk<br>bootstrap/wget.ipk<br>249302 bytes (249 kB) copied, 0.00421063 s, 59.2 MB/s<br>Creating temporary ipkg repository...<br>Installing optware-bootstrap package...<br>Unpacking optware-bootstrap.ipk...Done.<br>Configuring optware-bootstrap.ipk...Modifying /etc/rc.local<br>Done.<br>Installing ipkg...<br>Unpacking ipkg-opt.ipk...Done.<br>Configuring ipkg-opt.ipk...Done.<br>Removing temporary ipkg repository...<br>Installing wget...<br>Installing wget (1.12-2) to root...<br>Configuring wget<br>Successfully terminated.<br>Creating /opt/etc/ipkg/cross-feed.conf...<br>Setup complete.<br></code></pre></td></tr></table></figure><p>安装完成，建议重启，不过我没重启也没问题，可以使用。 之后执行更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ipkg update<br></code></pre></td></tr></table></figure><p>如果执行ipkg失败，提示没有找到该命令（- ash : ipkg : command not found），需要添加一下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/syno/sbin:/usr/syno/bin:/usr/local/sbin:/usr/local/bin</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">export</span> PATH</span><br></code></pre></td></tr></table></figure><p>我们来安装个Screen试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@DiskStation:~# ipkg install screen<br>Installing screen (4.0.3-2) to root...<br>Downloading http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/screen_4.0.3-2_i686.ipk<br>Installing termcap (1.3.1-2) to root...<br>Downloading http://ipkg.nslu2-linux.org/feeds/optware/syno-i686/cross/unstable/t ermcap_1.3.1-2_i686.ipk<br>Configuring screen<br>Configuring termcap<br>Successfully terminated.<br></code></pre></td></tr></table></figure><p>没问题。</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>如果需要卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm syno-i686-bootstrap_1.2-7_i686.xsh<br></code></pre></td></tr></table></figure><h2 id="修复wget-https错误问题"><a href="#修复wget-https错误问题" class="headerlink" title="修复wget https错误问题"></a>修复wget https错误问题</h2><p>安装了包管理后，如果出现wget https的问题，只要删除&#x2F;opt&#x2F;bin&#x2F;wget后将&#x2F;usr&#x2F;bin&#x2F;wget软链接到&#x2F;opt&#x2F;bin目录即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/bin/wget /opt/bin/wget<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>DSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自建Emby验证服务器</title>
    <link href="/2023/05/29/%E8%87%AA%E5%BB%BAEmby%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/05/29/%E8%87%AA%E5%BB%BAEmby%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="自建Emby验证服务器（实现白嫖）"><a href="#自建Emby验证服务器（实现白嫖）" class="headerlink" title="自建Emby验证服务器（实现白嫖）"></a>自建Emby验证服务器（实现白嫖）</h1><p>群晖默认自带nginx服务，通过增加nginx反代配置，实现将Emby的验证劫持到本地，骗过emby服务器，从而解锁硬解功能，实现视频播放硬件解码，降低服务器CPU压力。</p><p>注：我的Emby服务器是DOCKER部署。</p><h3 id="1-配置nginx"><a href="#1-配置nginx" class="headerlink" title="1.配置nginx"></a>1.配置nginx</h3><p>新建一个nginx配置文件，命名随意（例如emby.conf），在配置文件中写入下面的配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs conf">server &#123;<br> listen 443 ssl;<br> server_name mb3admin.com;<br> ssl_certificate /volume6/web/mb3admin.com/mb3admin.com.cert.pem;<br> ssl_certificate_key /volume6/web/mb3admin.com/mb3admin.com.key.pem;<br> ssl_session_timeout 5m;<br> ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br> ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;<br> ssl_prefer_server_ciphers on;<br> location = /webdefault/images/logo.jpg &#123;<br> alias /usr/syno/share/nginx/logo.jpg;<br> &#125;<br><br> location @error_page &#123;<br> root /usr/syno/share/nginx;<br> rewrite (.*) /error.html break;<br> &#125;<br><br> location ^~ /.well-known/acme-challenge &#123;<br> root /var/lib/letsencrypt;<br> default_type text/plain;<br> &#125;<br><br> location / &#123;<br> rewrite ^ / redirect;<br> &#125;<br><br> location ~ ^/$ &#123;<br> rewrite / https://$host:5001/ redirect;<br> &#125;<br><br> add_header Access-Control-Allow-Origin *;<br> add_header Access-Control-Allow-Headers *;<br> add_header Access-Control-Allow-Method *;<br> add_header Access-Control-Allow-Credentials true;<br> location /admin/service/registration/validateDevice &#123;<br> default_type application/json;<br> return 200 &#x27;&#123;&quot;cacheExpirationDays&quot;: 7,&quot;message&quot;: &quot;Device Valid&quot;,&quot;resultCode&quot;: &quot;GOOD&quot;&#125;&#x27;;<br> &#125;<br><br> location /admin/service/registration/validate &#123;<br> default_type application/json;<br> return 200 &#x27;&#123;&quot;featId&quot;:&quot;&quot;,&quot;registered&quot;:true,&quot;expDate&quot;:&quot;2099-01-01&quot;,&quot;key&quot;:&quot;&quot;&#125;&#x27;;<br> &#125;<br><br> location /admin/service/registration/getStatus &#123;<br> default_type application/json;<br> return 200 &#x27;&#123;&quot;deviceStatus&quot;:&quot;&quot;,&quot;planType&quot;:&quot;&quot;,&quot;subscriptions&quot;:&#123;&#125;&#125;&#x27;;<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>将文件保存到指定位置，通过软链接到&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /volume/XX/XX/emby.conf /etc/nginx/conf.d/emby.conf<br></code></pre></td></tr></table></figure><h3 id="2-申请证书"><a href="#2-申请证书" class="headerlink" title="2.申请证书"></a>2.申请证书</h3><p>到<a href="https://www.gmcert.org/subForm">https://www.gmcert.org/subForm</a>这个网站申请申请签发证书，参考下面填写：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292103557.webp"></p><p>一个是加密算法选 RSA, 密钥长度至少选 2048, 然后除主题名称为<code>mb3admin.com</code>之外其他的按照规则随意填写。点开高级选项：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292105504.webp"></p><p>然后勾选 <code>自动包含CA证书链</code> ，最后是证书有效天数，写 <code>824</code> 天即可。下载生成的证书，同时也将CA证书下载起来：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292126065.webp"></p><p>将 <code>mb3admin.com.key.pem</code> 和 <code>mb3admin.com.cert.pem</code>文件上传到第一步配置文件中目录位置，我这里是&#x2F;volume6&#x2F;web&#x2F;mb3admin.com&#x2F;。</p><h3 id="3-重启nginx服务"><a href="#3-重启nginx服务" class="headerlink" title="3.重启nginx服务"></a>3.重启nginx服务</h3><p>测试nginx配置文件是否正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -t<br></code></pre></td></tr></table></figure><p>重载nginx配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nginx -s reload<br></code></pre></td></tr></table></figure><h3 id="4-将证书文件追加到Emby服务器"><a href="#4-将证书文件追加到Emby服务器" class="headerlink" title="4.将证书文件追加到Emby服务器"></a>4.将证书文件追加到Emby服务器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat xx/mb3admin.com.cert.pem &gt;&gt; /etc/ssl/certs/ca-certificates.crt<br></code></pre></td></tr></table></figure><h3 id="5-修改DNS或者HOSTS文件"><a href="#5-修改DNS或者HOSTS文件" class="headerlink" title="5.修改DNS或者HOSTS文件"></a>5.修改DNS或者HOSTS文件</h3><p>可以在本地电脑中修改HOSTS文件，将mb3admin.com指向群晖IP地址，也可以直接在路由器中直接进行域名劫持，将mb3admin.com指向群晖IP</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292124432.webp"></p><h3 id="6-浏览器添加CA证书"><a href="#6-浏览器添加CA证书" class="headerlink" title="6.浏览器添加CA证书"></a>6.浏览器添加CA证书</h3><p>将CA证书添加到本地电脑：</p><p>将GMCert_RSACA01.cert.pem 文件名改为GMCert_RSACA01.cer，双击安装</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292131273.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292132905.webp"></p><p>然后在浏览器中打开下面两个浏览器，验证是否成功：</p><p><a href="https://mb3admin.com/admin/service/registration/validateDevice">https://mb3admin.com/admin/service/registration/validateDevice</a></p><p><a href="https://mb3admin.com/admin/service/registration/validateDevice/666">https://mb3admin.com/admin/service/registration/validateDevice/666</a></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292133083.webp"></p><h3 id="7-在Emby服务器中输入秘钥"><a href="#7-在Emby服务器中输入秘钥" class="headerlink" title="7.在Emby服务器中输入秘钥"></a>7.在Emby服务器中输入秘钥</h3><p>管理Emby Server-Emby Premiere中随便输入一个秘钥，见证奇迹：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305292136890.webp"></p><p>结束！</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>分享</tag>
      
      <tag>Emby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于fluid主题的hexo博客搭建</title>
    <link href="/2023/05/28/%E5%9F%BA%E4%BA%8Efluid%E4%B8%BB%E9%A2%98%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/05/28/%E5%9F%BA%E4%BA%8Efluid%E4%B8%BB%E9%A2%98%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300822499.webp"></p><p>周末闲着无聊花了一天时间，搭建了一个hexo个人网站，使用的是了fluid主题，感谢作者的无私付出（<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid-dev&#x2F;hexo-theme-fluid: 一款 Material Design 风格的 Hexo 主题)</a>）。</p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo支持 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h4><p>安装Hexo其实非常简单，但是需要先在本地电脑中安装好下面几个软件，另外我还安装了Visual Studio Code及Typora，推荐Typora+picgo作为文章写作软件，支持自动上传图片到图床。</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li><li><a href="https://www.npmjs.com/">nmp</a></li><li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li><li><a href="https://typora.io/">Typora</a></li></ul><h4 id="1-2安装"><a href="#1-2安装" class="headerlink" title="1.2安装"></a>1.2安装</h4><p>安装好前三个软件后，即可使用npm安装Hexo了，打开一个PowerShell窗口，执行下面命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> hexo<span class="hljs-literal">-cli</span><br></code></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用： <code>hexo</code></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:./node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.profile<br></code></pre></td></tr></table></figure><h4 id="1-3升级"><a href="#1-3升级" class="headerlink" title="1.3升级"></a>1.3升级</h4><p>如果后期需要升级的话，进入博客的目录，先检查更新:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">E:\Blog\hexo&gt; npm outdated<br>Package  Current  Wanted     Latest  Location           Depended by<br>hexo       6.3.0   6.3.0  7.0.0-rc1  node_modules/hexo  hexo<br></code></pre></td></tr></table></figure><p>修改 <code>package.json</code> 文件，基于 <code>Latest</code> 列内容更新版本号，然后更新并检查版本号：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></figure><h3 id="2-建站"><a href="#2-建站" class="headerlink" title="2.建站"></a>2.建站</h3><h4 id="2-1初始化目录"><a href="#2-1初始化目录" class="headerlink" title="2.1初始化目录"></a>2.1初始化目录</h4><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo init &lt;目标文件夹&gt;<br><span class="hljs-built_in">cd</span> &lt;目标文件夹&gt;<br>npm install <br></code></pre></td></tr></table></figure><h4 id="2-2启动网页服务"><a href="#2-2启动网页服务" class="headerlink" title="2.2启动网页服务"></a>2.2启动网页服务</h4><p>等初始化执行完成后，通过<code>hexo s</code>命令即可在本地启动博客站点：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&gt;hexo s<br>INFO  <span class="hljs-built_in">Start</span> processing<br>INFO  Hexo is running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>浏览器访问<a href="http://localhost:4000就可以看到下面这页面了：">http://localhost:4000就可以看到下面这页面了：</a></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300845356.webp"></p><h3 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3.更换主题"></a>3.更换主题</h3><h4 id="3-1安装主题"><a href="#3-1安装主题" class="headerlink" title="3.1安装主题"></a>3.1安装主题</h4><p><strong>方式一</strong></p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml (opens new window)</a>内容复制过去。</p><p><strong>方式二</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本 (opens new window)</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><h4 id="3-2指定主题"><a href="#3-2指定主题" class="headerlink" title="3.2指定主题"></a>3.2指定主题</h4><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h4 id="3-3创建「关于页」"><a href="#3-3创建「关于页」" class="headerlink" title="3.3创建「关于页」"></a>3.3创建「关于页」</h4><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><blockquote><p><em><strong>注意</strong></em></p><p><code>layout: about</code> 必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p></blockquote><p>完了执行下面两条命令，就可以看到新主题的样式了：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo clean<br>hexo s<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300846684.webp"></p><h4 id="3-4更新主题"><a href="#3-4更新主题" class="headerlink" title="3.4更新主题"></a>3.4更新主题</h4><p><strong>方式一</strong></p><blockquote><p>适用于通过 Npm 安装主题。</p></blockquote><p>在博客目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>方式二</strong></p><blockquote><p>适用于通过 Release 压缩包安装主题，且没有自行修改任何代码的情况。</p></blockquote><ol><li>先将原文件夹重命名为别的名称，例如 <code>fluid-bkp</code>，用于升级失败进行回退；</li><li>按照安装步骤，重新下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">release (opens new window)</a>并解压重命名为 <code>fluid</code>；</li><li>如果某些配置发生了变化（改名或弃用），release 的说明里会特别提示，同步修改原配置文件即可。</li></ol><p><strong>方式三</strong></p><blockquote><p>适用于自定义了一些代码，或想体验其他分支的情况，以 dev 分支为例。</p></blockquote><ol><li>确定自己的 fluid 目录已经开启 git，并且所有改动都已 commit；</li><li>把 fluid 仓库的 develop 分支拉取到自己当前的分支上（也可新建一个分支再拉取）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull https://github.com/fluid-dev/hexo-theme-fluid.git develop<br></code></pre></td></tr></table></figure><ol start="3"><li>解决代码冲突，保留自己修改的部分（如何解决冲突可自行搜索）</li></ol><h4 id="3-5更多主题配置"><a href="#3-5更多主题配置" class="headerlink" title="3.5更多主题配置"></a>3.5更多主题配置</h4><p>更多的主题配置请参考官方配置指南：</p><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><h3 id="4-部署到Github"><a href="#4-部署到Github" class="headerlink" title="4.部署到Github"></a>4.部署到Github</h3><p>通过 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a> 插件可以实现一键将博客部署到github提供的 pages 服务。</p><h4 id="4-1新建存储库"><a href="#4-1新建存储库" class="headerlink" title="4.1新建存储库"></a>4.1新建存储库</h4><p>建立名为 <code>&lt;repository的名字&gt;.github.io</code> 的储存库，这样你的博客网址为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>，例如下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300846389.webp"></p><h4 id="4-1安装hexo-deployer-git"><a href="#4-1安装hexo-deployer-git" class="headerlink" title="4.1安装hexo-deployer-git"></a>4.1安装hexo-deployer-git</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install hexo<span class="hljs-literal">-deployer-git</span> <br></code></pre></td></tr></table></figure><h4 id="4-2修改-config-yml文件"><a href="#4-2修改-config-yml文件" class="headerlink" title="4.2修改_config.yml文件"></a>4.2修改<code>_config.yml</code>文件</h4><p>在配置文件中追加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/conscloud/conscloud.github.io</span><br>  <span class="hljs-comment"># example, https://github.com/hexojs/hexojs.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br>  <span class="hljs-attr">ignore_hidden:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="4-3部署发布"><a href="#4-3部署发布" class="headerlink" title="4.3部署发布"></a>4.3部署发布</h4><p>Commit 并 push 到默认分支上，当部署完成后，在 <code>gh-pages</code> 分支可以找到生成的网页，并在 GitHub 储存库中，前往 <code>Settings &gt; Pages &gt; Source</code>，并将 branch 改为 <code>gh-pages</code>。</p><p>部署执行下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hexo clean &amp;&amp; hexo deploy<br></code></pre></td></tr></table></figure><p>前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io/</code> 查看网站。</p><h3 id="5-部署到vercel"><a href="#5-部署到vercel" class="headerlink" title="5.部署到vercel"></a>5.部署到vercel</h3><p>部署到github一个是速度不够快，另一个是国内的网络环境有时可能无法访问，推荐部署到<a href="https://vercel.com/">Vercel</a>,配合自定义域名，可以提高访问速度。</p><h4 id="5-1新建工程"><a href="#5-1新建工程" class="headerlink" title="5.1新建工程"></a>5.1新建工程</h4><p>首先先注册一个vercel账号后，在页面中点击<code>New Project</code>，创建工程。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300846837.webp"></p><p>然后通过绑定的 <code>github</code> 或者导入需要部署的项目。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300846729.webp"></p><p>因为导入的项目是打包好的静态页，<code>FRAMEWORK PRESET</code> 选择 <code>Other</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300847718.webp"></p><p>点击 <code>deployed</code> 进行部署，如果部署失败可以查看报错信息是不是上一步的某些选项没有覆盖。部署成功后会进入如图所示的界面：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300847721.webp"></p><h4 id="5-2自定义域名"><a href="#5-2自定义域名" class="headerlink" title="5.2自定义域名"></a>5.2自定义域名</h4><p><strong>域名可以购买或者去<a href="https://www.freenom.com/zh/index.html?lang=zh">Freenom</a>申请免费的域名，但是Freenom域名听说有可能存在被收回的风险。</strong></p><ul><li>默认情况下部署成功后 <code>vercel</code> 会给你生成一个默认的域名，如果想要修改成自己的域名可将域名名称修改成自己的。</li><li>当选择修改成自己的域名名称后，<code>vercel</code> 会检查域名指向的 <code>DNS</code> 对不对，如果不对的话会提示你域名的 DNS 应该如何配置，按照 <code>vercel</code> 提示的 <code>DNS</code> 信息</li></ul><p>在自己的域名的 <code>DNS</code> 配置中进行配置，如图在 setting 中配置自定义域名：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300848352.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300848160.webp"></p><p>待生效后，就可以用自定义的域名访问了。</p><h4 id="5-4修改Vrecel服务器区域"><a href="#5-4修改Vrecel服务器区域" class="headerlink" title="5.4修改Vrecel服务器区域"></a>5.4修改Vrecel服务器区域</h4><p>在Settings-Functions中修改区域为香港。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300848122.webp"></p><p>我用的是freenom的免费域名，通过cloudfare管理，服务器区域修改为香港后，在晚上高峰期测试的延迟情况：</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300849770.webp"></p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>好像就是这样就完事了。</p><p>哦！感谢下列文章作者：</p><p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p><a href="https://blog.17lai.site/posts/40300608/#!">三万字教程]基于Hexo的matery主题搭建博客并深度优化一站式完全教程 | 夜法之书 (17lai.site)</a></p><p><a href="https://hexo.fluid-dev.com/posts/hexo-vercel/#">Vercel部署高级用法教程 - Hexo Theme Fluid (fluid-dev.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>HEXO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群晖无法启用防火墙问题修复</title>
    <link href="/2023/05/28/%E7%BE%A4%E6%99%96%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/"/>
    <url>/2023/05/28/%E7%BE%A4%E6%99%96%E6%97%A0%E6%B3%95%E5%90%AF%E7%94%A8%E9%98%B2%E7%81%AB%E5%A2%99%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300957269.webp"></p><p><strong>现象</strong>：系统版本DSM7.1，当选择启用防火墙时，编辑规则会报“无法加载配置文件数据”，也无法在防火墙配置规则中进行下拉选择。</p><h3 id="启用SSH服务登录到群晖后台"><a href="#启用SSH服务登录到群晖后台" class="headerlink" title="启用SSH服务登录到群晖后台"></a>启用SSH服务登录到群晖后台</h3><p>如果不知道如何开启SSH服务，请参考：<a href="https://www.okko.tk/2023/05/28/%E7%BE%A4%E6%99%96%E5%BC%80%E5%90%AFSSH%E5%8F%8A%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE">群晖开启SSH及免密码登录配置 - ZhJy的随笔</a></p><h3 id="修复防火墙配置文件"><a href="#修复防火墙配置文件" class="headerlink" title="修复防火墙配置文件"></a>修复防火墙配置文件</h3><ol><li>分别查看<code>/usr/syno/etc/firewall.d/</code>及<code>/usr/syno/etc.defaults/firewall.d</code>两个目录下是否至少有三个json文件，我这分别为1.json、2.json及firewall_settings.json三个文件</li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300957310.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300958132.webp"></p><ol><li>使用cat命令分别查看1.json及2.json文件内容是否为空，或者json格式不正确，我这里是在&#x2F;usr&#x2F;syno&#x2F;etc&#x2F;firewall.d&#x2F;这个目录下的两个数字开头的文件内容为空，而etc.defaults&#x2F;firewall.d&#x2F;下面同名的文件是有内容的。</li><li>将&#x2F;usr&#x2F;syno&#x2F;etc.defaults&#x2F;firewall.d&#x2F;下的1.json、2.json复制到&#x2F;usr&#x2F;syno&#x2F;etc&#x2F;firewall.d&#x2F;目录下。</li><li>回到页面验证，现在已经可以开户防火墙，并配置相关规则了</li></ol><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300958438.webp"></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>That is all!</p>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>DSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群晖开启SSH及免密码登录配置</title>
    <link href="/2023/05/28/%E7%BE%A4%E6%99%96%E5%BC%80%E5%90%AFSSH%E5%8F%8A%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/05/28/%E7%BE%A4%E6%99%96%E5%BC%80%E5%90%AFSSH%E5%8F%8A%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300820463.webp"></p><p>群晖开启root账户免密登录与linux服务器的操作大致相同。 </p><p>我的群晖DSM版本是7.1.1</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300956813.webp"></p><h3 id="1-开启SSH服务"><a href="#1-开启SSH服务" class="headerlink" title="1.开启SSH服务"></a>1.开启SSH服务</h3><p>群晖从7开始默认关闭了“admin”账户，并禁用最大权限的系统账户“root”登录网页控制台。</p><p>先使用群晖安装时建立的普通管理员账户（加入了administrators用户组的用户）登录web控制台后，依次点击“控制面板”-“终端机和SNMP”，勾选“启用SSH功能”，再点击右下角的“应用”按钮即完成开启SSH服务。<strong>建议修改默认端口号。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300956733.webp"></p><h3 id="2-允许ROOT账号登录"><a href="#2-允许ROOT账号登录" class="headerlink" title="2.允许ROOT账号登录"></a>2.允许ROOT账号登录</h3><p>通过普通管理员账户进行ssh登录，输入sudo - i 回车后再次输入管理员密码，就能切换到root账户。</p><p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300954437.webp"></p><p>给root账户设置密码,其中xxx为你想要设置的密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">synouser --setpw root xxx<br></code></pre></td></tr></table></figure><p>修改sshd_config文件的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin <span class="hljs-built_in">yes</span><span class="hljs-comment">#允许root登录</span><br>PasswordAuthentication <span class="hljs-built_in">yes</span>          <span class="hljs-comment">#开启密码认证</span><br>ChallengeResponseAuthentication no<br>UsePAM <span class="hljs-built_in">yes</span>    <span class="hljs-comment">#开户密码认证</span><br></code></pre></td></tr></table></figure><p>修改完后，别忘记保存。</p><h3 id="3-开启密钥登录"><a href="#3-开启密钥登录" class="headerlink" title="3.开启密钥登录"></a>3.开启密钥登录</h3><p>确认在root用户下，输入“ssh-keygen”命令创建密钥，id_rsa是新生成的私钥，id_rsa.pub是对应的公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 2048 -C &quot;root_rsa_key&quot;<br></code></pre></td></tr></table></figure><p>将id_rsa.pub文件内容追加到“&#x2F;root&#x2F;.ssh&#x2F;authorized_keys”文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys<br></code></pre></td></tr></table></figure><p><em>注意authorized_keys权限至少是root账户有rw（否则执行以下2条命令“chmod 700 ~&#x2F;.ssh”、“ chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys”）</em></p><p>将id_rsa文件复制到本地，重启ssh服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">synosystemctl reload sshd<br>synosystemctl restart sshd<br></code></pre></td></tr></table></figure><p>在本地就可以通过工具（如xshell等）免密码连接到群晖了。</p><p>最后可以修改sshd_config文件，禁止使用密码认证登录，提高安全性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PasswordAuthentication no          <span class="hljs-comment">#关闭密码认证</span><br></code></pre></td></tr></table></figure><p><strong>最后，如果修改sshd_config文件导致ssh功能无法使用而其他功能正常，群晖可以正常登录网页控制台，可以开启telnet,把错误的sshd_config改回去！</strong></p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><strong>群晖353条syno命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><code class="hljs bash">syno-abuser-blocklist-checker<br>syno-dump-core.sh<br>syno-init-disk-health-db<br>syno-letsencrypt<br>syno8021Xtool<br>synoRTCTime<br>syno_adv_test<br>syno_bios_bootperf_record<br>syno_disk_config_check<br>syno_disk_ctl<br>syno_disk_data_collector<br>syno_disk_db_update<br>syno_disk_dsl<br>syno_disk_dump<br>syno_disk_firm_status_update<br>syno_disk_health_predict<br>syno_disk_health_record<br>syno_disk_latency_collector<br>syno_disk_log_convert<br>syno_disk_log_import_from_xml<br>syno_disk_performance_cache_update<br>syno_disk_performance_delete_record<br>syno_disk_performance_monitor<br>syno_disk_schedule_test<br>syno_disk_smart_mail_send<br>syno_disk_sysfs_get<br>syno_disk_sysfs_set<br>syno_disk_test_log_import_from_xml<br>syno_disk_test_scheduler_set<br>syno_disk_testlog_convert<br>syno_disk_wcache_config_init<br>syno_disk_wdda<br>syno_drive_bundle<br>syno_ew_check.sh<br>syno_expansion<br>syno_fan_debug<br>syno_hdd_util<br>syno_hibernation_debug<br>syno_hook_trgr<br>syno_hw_video_transcoding.sh<br>syno_ip_conflict_detect<br>syno_iptables_common<br>syno_led_brightness<br>syno_led_mask_on<br>syno_mem_check<br>syno_mem_single_channel_action<br>syno_mib_disk_mapping<br>syno_mib_disk_tool<br>syno_microp_control<br>syno_predict_disk_health<br>syno_pstore_collect<br>syno_scemd_connector<br>syno_sched_poweroff<br>syno_smart_result_collect<br>syno_smart_test<br>syno_spectre_meltdown_tool<br>syno_ssd_trim<br>syno_ssd_trim_schedule<br>syno_storage_bkgrd_task<br>syno_swap_ctl<br>syno_syslog_check_ctl<br>syno_system_dump<br>syno_update_disk_log_information<br>syno_user_info<br>syno_volume_analyze<br>synoabnormalloginmail<br>synoabnormalloginnotify<br>synoacltool<br>synoafp<br>synoagentregisterd<br>synoagentregistertool<br>synoappbkp<br>synoappconfigcache<br>synoappnotify<br>synoapppriv_updater<br>synoarchive<br>synoarchivetool<br>synoauth<br>synoautoblock<br>synoautonano<br>synobackgroundtask<br>synobackup<br>synobackupd<br>synobandwidth<br>synobios_uninit<br>synobootseq<br>synobootupcheck<br>synobtrfssnap<br>synobtrfssnapusage<br>synocacheadvisor<br>synocacheadvisord<br>synocacheclient<br>synocachepinfiled<br>synocachepinfiletool<br>synocachepinfiletool-status<br>synocachepinfiletool.sh<br>synocfgen<br>synocgid<br>synocgitool<br>synocheckgroup<br>synocheckhotspare<br>synocheckinfo<br>synocheckiscsitrg<br>synochecknetworkcfg<br>synocheckshare<br>synocheckuser<br>synocleaner<br>synocloudserviceauth<br>synocmsclient<br>synocodectool<br>synoconfbkp<br>synoconfd<br>synocontentextract<br>synocontentextractd<br>synocontentsearchutils<br>synocopy<br>synocredential<br>synocrond<br>synocrtchecksum<br>synocrtregister<br>synocrtunregister<br>synocsp<br>synodatacollect<br>synodataverifier<br>synodate<br>synodbudconfig<br>synodbudd<br>synodbudgetinfo<br>synodbudinfo<br>synodbudisrunning<br>synodbudupdate<br>synodbudvcdiff<br>synodbudvolume<br>synodctest<br>synodd<br>synoddnsinfo<br>synodisk<br>synodiskdatacollect<br>synodiskfind<br>synodisklatencyd<br>synodiskmanagertool<br>synodiskpathparse<br>synodiskport<br>synodiskstat<br>synodiskwddad<br>synodsdefault<br>synodsinfo<br>synodsmloginhealthcheck<br>synodsmnotify<br>synoethinfo<br>synoexternal<br>synoextractjep<br>synofanconfig<br>synofilehandle<br>synofilehandlecleancache<br>synofileutil<br>synofirewall<br>synofirewallUpdater<br>synoflashcache<br>synoflashcachechecknotifymissing<br>synoflashcacheshareapplytool<br>synoflvconv<br>synofsbdctl<br>synofstool<br>synoftpchecker<br>synogear<br>synogetkeyvalue<br>synogetstate.sh<br>synogpoclientd<br>synogrinst<br>synogroup<br>synohacore<br>synohtmlhandler<br>synohwctl<br>synoindex<br>synoindex-bin-scheduler<br>synoindex-bin-sdk-hook-db-tool<br>synoindex_mgr<br>synoindex_package.sh<br>synoindexd<br>synoindexnotifyd<br>synoindexplugind<br>synoindexscand<br>synoindexworkerd<br>synoinsid<br>synoiscsiep<br>synoiscsitop<br>synoiscsiwebapi<br>synokerneltz<br>synolanstatus<br>synoldapclient<br>synoldapclientd<br>synolegalnotifier<br>synolog-linker<br>synologaccd<br>synologand<br>synologanutil<br>synologconfgen<br>synologconvert<br>synologrotated<br>synologset<br>synologset1<br>synomediaparser<br>synomediaparserd<br>synomibclient-event<br>synomibtool<br>synomigratewallpaper<br>synomkflv<br>synomkflvd<br>synomkthumb<br>synomkthumbd<br>synomoduletool<br>synomount<br>synomustache<br>synomyds<br>synonclient_send<br>synonet<br>synonetd<br>synonetdtool<br>synoneteventd<br>synonetseqadj<br>synonfs<br>synonfstest<br>synonfstop<br>synonode<br>synonotify<br>synonotifyconvert<br>synonotifydbtransfer<br>synonvme<br>synootp<br>synoovstool<br>synopartition<br>synopasswordmail<br>synopayment<br>synoperfeventd<br>synoperformancediagnose<br>synopersonalupdater<br>synopftest<br>synopingpong<br>synopkg<br>synopkgctl<br>synopkghelper<br>synopkicompatsync<br>synoplatform<br>synoportforward<br>synopostgres<br>synopoweroff<br>synopppoe<br>synopreferencedir<br>synoprint<br>synopsql<br>synopyntlmd<br>synoquota<br>synoraid5stat<br>synoraidtool<br>synorbdctl<br>synorecycle<br>synorelayd<br>synorenewdefaultcert<br>synoretainer<br>synoretentionconf<br>synoretentiontest<br>synoretentiontestutil.sh<br>synorollinggroupid<br>synorouterportfwd<br>synoroutertool<br>synorsyncdtool<br>synosavetime<br>synoscgi<br>synoscgi-socket-get-memory.js<br>synoscgi________________________________________________________<br>synoscgi_socket.js<br>synoschedmulti<br>synoschedmultirun<br>synoschedtask<br>synoschedtool<br>synoscheduled<br>synosdutils<br>synosearch<br>synosearchagent<br>synoselfcheck<br>synoselfcheck-min<br>synoservicemigrate<br>synosetkeyvalue<br>synosetnoatime<br>synoshare<br>synosharequota<br>synosharesnapshot<br>synosharesnaptool<br>synosharesnaptree<br>synosharesnaptree_reconstruct.sh<br>synosharingbackup<br>synosharingchecker<br>synosharingcron<br>synosharingurl<br>synoshortcutmigrate.min.js<br>synoshutdown<br>synosmartblock<br>synosnapschedtask.sh<br>synosnmp_communicator<br>synosnmpcd<br>synosnmpcd_db_updater<br>synosocket<br>synospace<br>synospace.sh<br>synossdbundlehotplug<br>synossdbundlemonitor<br>synosshdutils<br>synostgdisk<br>synostgpool<br>synostgreclaim<br>synostgsysraid<br>synostgtask<br>synostgvolume<br>synostorage<br>synostoragecore<br>synostoraged<br>synosubvoltype<br>synosupportchannelchecker<br>synosyncdctime<br>synosyslogcheck<br>synosyslogmail<br>synosystemctl<br>synotaskmgr<br>synotc<br>synotc_common<br>synothumb<br>synotifyd<br>synotifydutil<br>synotimecontrol<br>synotlstool<br>synotokenmgr<br>synotune<br>synoupgrade<br>synoupgradepreserve<br>synoupnp<br>synoups<br>synoups_battery_notify.sh<br>synoupscommon<br>synousb<br>synousbdisk<br>synouser<br>synouserdir<br>synouserhome<br>synovolumesnapshot<br>synovpnc<br>synovspace<br>synovspace_wrapper<br>synow3<br>synow3tool<br>synowebapi<br>synowedjat-exec<br>synowin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
      <tag>DSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openwrt状态信息推送到HA的两种实现方法</title>
    <link href="/2023/05/28/Openwrt%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0HA%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <url>/2023/05/28/Openwrt%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E6%8E%A8%E9%80%81%E5%88%B0HA%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/conscloud/picgotemp/imgplus/202305300953810.webp"></p><p>家里目前使用x86平台软路由作为主路由拨号，在群晖vmm虚拟机中安装了HAOS智能家居系统，HA中基于upnp的集成组件对路由器的监控项目不是很全，因此想将一些路由器的状态信息接入到HA中进行实时监控展示。这里介绍两种方法：</p><h3 id="一、通过http模式推送"><a href="#一、通过http模式推送" class="headerlink" title="一、通过http模式推送"></a>一、通过http模式推送</h3><p>1、在进入HA系统-用户-长期访问令牌-创建令牌，新建一个长期访问令牌</p><p>2、写一个shell脚本openwrt_post.sh，获取路由器的状态信息，我这里取了CPU频率、温度、使用率、内存使用率、科学上网及开机时长。脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>cpu_freq=$(cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq|awk &#x27;&#123;print ($1)/1000&#125;&#x27;)<br><br>temp_cpu=$(sensors|grep °C|sed -nr &#x27;s#^Core.*:.*\+(.*)°C .*#\1#gp&#x27;|sort -nr|head -n1&#x27;&#x27;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">cpu_freq=$(<span class="hljs-built_in">cat</span> /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq|awk <span class="hljs-string">&#x27;&#123;print ($1)/1000&#125;&#x27;</span>)</span><br><br>function getcpu()&#123;<br><br>local AT=$(cat /proc/stat|grep &quot;^cpu &quot;|awk &#x27;&#123;print $2+$3+$4+$5+$6+$7+$8 &quot; &quot; $2+$3+$4+$7+$8&#125;&#x27;)<br><br>sleep 1<br><br>local BT=$(cat /proc/stat|grep &quot;^cpu &quot;|awk &#x27;&#123;print $2+$3+$4+$5+$6+$7+$8 &quot; &quot; $2+$3+$4+$7+$8&#125;&#x27;)<br><br>printf &quot;%.01f&quot; $(echo $&#123;AT&#125; $&#123;BT&#125;|awk &#x27;&#123;print (($4-$2)/($3-$1))*100&#125;&#x27;)<br><br>&#125;<br><br>cpu_used=$(getcpu)<br><br>mem_used=$(free -m|sed -n &#x27;2p&#x27;|awk &#x27;&#123;print&quot;&quot;($3/$2)*100&#125;&#x27;)<br><br>ssr_server=`cat /etc/config/shadowsocksr |grep global_server|awk -F\&#x27; &#x27;&#123;print $2&#125;&#x27;`<br><br>up_times=$(cat /proc/uptime| awk -F. &#x27;&#123;run_days=$1 / 86400;run_hour=($1 % 86400)/3600;run_minute=($1 % 3600)/60;run_second=$1 % 60;printf(&quot;%d天%d时%d分%d秒\n&quot;,run_days,run_hour,run_minute,run_second)&#125;&#x27;)<br><br>post_data=&quot;&#123;\&quot;state\&quot;:\&quot;$temp_cpu\&quot;, \&quot;attributes\&quot;:&#123;\&quot;temp_cpu\&quot;:\&quot;$temp_cpu\&quot;, \&quot;cpu_freq\&quot;:\&quot;$cpu_freq\&quot;, \&quot;cpu_used\&quot;:\&quot;$cpu_used\&quot;,\&quot;mem_used\&quot;:\&quot;$mem_used\&quot;,\&quot;ssr_server\&quot;:\&quot;$ssr_server\&quot;,\&quot;up_times\&quot;:\&quot;$up_times\&quot;&#125;&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$post_data</span></span><br><br>curl -X POST -H &quot;Authorization: Bearer 第一步建的长期访问令牌&quot; -H &quot;Content-Type: application/json&quot; -d &quot;$post_data&quot; http://192.168.XX.XX:8123/api/states/input_number.openwrtinfo<br></code></pre></td></tr></table></figure><p>3、通过crontab任务调度或者写一个watch脚本循环调用，即可通过post形式将采集到的信息推送到HA。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>while :<br>do<br>        if ! ps | grep -w openwrt_post.sh | grep -v grep<br>        then                                    <br>                /opt/openwrt_post.sh<br>        sleep 60#60秒取一次，可自行修改间隔<br>        fi                       <br>done<br></code></pre></td></tr></table></figure><p>4、在HA中添加配置文件，将获取到的信息转为实体</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sensor:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">template</span><br>    <span class="hljs-attr">sensors:</span><br>      <span class="hljs-attr">openwrtinfo_temp_cpu:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">°C</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.temp_cpu &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_cpu_freq:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">MHz</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.cpu_freq &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_cpu_used:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&quot;%&quot;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.cpu_used &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_mem_used:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&quot;%&quot;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.mem_used &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_wan_sent:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">GB</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrtinfo_wan_sent</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.sensor.openwrt_router_b_sent.state | multiply(1/1024/1024/1024) | round(2) &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_wan_received:</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">GB</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrtinfo_wan_received</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.sensor.openwrt_router_b_received.state | multiply(1/1024/1024/1024) | round(2) &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_ssr_server:</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.ssr_server &#125;&#125;</span>&quot;</span><br>      <span class="hljs-attr">openwrtinfo_up_times:</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; states.input_number.openwrtinfo.attributes.up_times &#125;&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="二、通过mqtt推送"><a href="#二、通过mqtt推送" class="headerlink" title="二、通过mqtt推送"></a>二、通过mqtt推送</h3><p>1、先在openwrt中安装好mqtt，<code>mosquitto-client-nosll、libmosquitto-nossl</code>这两个包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">opkg update<br>opkg install mosquitto-client-nossl libmosquitto-nossl<br></code></pre></td></tr></table></figure><p>2、内网已经部署了MQTT服务器。</p><p>3、监控脚本与方法一大部分相同，将最后一步的发送命令修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mosquitto_pub -r -L mqtt://mqtt:mqtt@192.168.XX.XX:1883/openwrtinfo -m &quot;$post_data&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">mqtt:mqtt前面一个为mqtt用户名：mqtt密码</span><br></code></pre></td></tr></table></figure><p>​完整脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>cpu1_freq=$(cat /sys/devices/system/cpu/cpufreq/policy0/scaling_cur_freq|awk &#x27;&#123;print ($1)/1000&#125;&#x27;)<br>cpu2_freq=$(cat /sys/devices/system/cpu/cpufreq/policy1/scaling_cur_freq|awk &#x27;&#123;print ($1)/1000&#125;&#x27;)<br>temp_cpu=$(sensors|grep °C|sed -nr &#x27;s#^Core.*:.*\+(.*)°C .*#\1#gp&#x27;|sort -nr|head -n1&#x27;&#x27;)<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">getcpu</span></span>()&#123;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">local</span> AT=$(<span class="hljs-built_in">cat</span> /proc/stat|grep <span class="hljs-string">&quot;^cpu &quot;</span>|awk <span class="hljs-string">&#x27;&#123;print $2+$3+$4+$5+$6+$7+$8 &quot; &quot; $2+$3+$4+$7+$8&#125;&#x27;</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">sleep</span> 1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">local</span> BT=$(<span class="hljs-built_in">cat</span> /proc/stat|grep <span class="hljs-string">&quot;^cpu &quot;</span>|awk <span class="hljs-string">&#x27;&#123;print $2+$3+$4+$5+$6+$7+$8 &quot; &quot; $2+$3+$4+$7+$8&#125;&#x27;</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%.01f&quot;</span> $(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;AT&#125;</span> <span class="hljs-variable">$&#123;BT&#125;</span>|awk <span class="hljs-string">&#x27;&#123;print (($4-$2)/($3-$1))*100&#125;&#x27;</span>)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">&#125;</span><br>cpu_used=$(top -b -n 1|awk &#x27;NR==2&#123;print$8&#125;&#x27;|awk &#x27;&#123;print 100-$1&#125;&#x27;)<br>mem_used=$(free -m|sed -n &#x27;2p&#x27;|awk &#x27;&#123;printf &quot;%.2f&quot;,($3/$2)*100&#125;&#x27;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ip=$(curl -s https://api.ipify.org)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">for</span>((y=<span class="hljs-number">0</span>;y&lt;<span class="hljs-variable">$&#123;#array[*]&#125;</span>;y++))</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">do</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$ip</span>&quot;</span> = <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;array[y]&#125;</span>&quot;</span> ]];<span class="hljs-keyword">then</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> ssr_server=<span class="hljs-variable">$&#123;array[y+1]&#125;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> <span class="hljs-keyword">fi</span></span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-keyword">done</span></span><br>ssr_server=$(awk &#x27;/^&#x27;$(curl -s https://api.ipify.org)&#x27;/ &#123;print $2&#125;&#x27; /opt/myscripts/ssrserver)<br>hostname=$(cat /etc/config/system |grep hostname |awk -F\&#x27; &#x27;&#123;print $2&#125;&#x27;)<br>cpu_brand=$(cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq)<br>cpu_arch=$(uname -m)<br>kernel=$(uname -r)<br>releases=$(echo &quot;$(cat /etc/openwrt_release |sed -n &#x27;1p&#x27;|awk -F\&#x27; &#x27;&#123;print $2&#125;&#x27;) $(cat /etc/openwrt_release |sed -n &#x27;6p&#x27;|awk -F\&#x27; &#x27;&#123;print $2&#125;&#x27;) $(cat /etc/openwrt_version)&quot;)<br>boot_time=$(date -d &quot;@$(( $(date +%s) - $(awk -F. &#x27;&#123;print $1&#125;&#x27; /proc/uptime) ))&quot; +&quot;%Y-%m-%d %H:%M:%S&quot;)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ssr_server=`<span class="hljs-built_in">cat</span> /etc/config/shadowsocksr |grep global_server|awk -F\<span class="hljs-string">&#x27; &#x27;</span>&#123;<span class="hljs-built_in">print</span> <span class="hljs-variable">$2</span>&#125;<span class="hljs-string">&#x27;`</span></span><br>up_times=$(cat /proc/uptime| awk -F. &#x27;&#123;run_days=$1 / 86400;run_hour=($1 % 86400)/3600;run_minute=($1 % 3600)/60;run_second=$1 % 60;printf(&quot;%d天%d时%d分%d秒\n&quot;,run_days,run_hour,run_minute,run_second)&#125;&#x27;)<br><br>post_data=&quot;&#123;\&quot;temp_cpu\&quot;:\&quot;$temp_cpu\&quot;, \&quot;cpu1_freq\&quot;:\&quot;$cpu1_freq\&quot;,\&quot;cpu2_freq\&quot;:\&quot;$cpu2_freq\&quot;, \&quot;cpu_used\&quot;:\&quot;$cpu_used\&quot;,\&quot;mem_used\&quot;:\&quot;$mem_used\&quot;,\&quot;ssr_server\&quot;:\&quot;$ssr_server\&quot;,\&quot;up_times\&quot;:\&quot;$up_times\&quot;,\&quot;hostname\&quot;:\&quot;$hostname\&quot;, \&quot;cpu_brand\&quot;:\&quot;$cpu_brand\&quot;, \&quot;cpu_arch\&quot;:\&quot;$cpu_arch\&quot;,\&quot;kernel\&quot;:\&quot;$kernel\&quot;, \&quot;releases\&quot;:\&quot;$releases\&quot;, \&quot;boot_time\&quot;:\&quot;$boot_time\&quot;&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">echo $post_data</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-string">ssr_server=`cat /etc/config/shadowsocksr |grep global_server|awk -F\&#x27;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br>mosquitto_pub -r -L mqtt://mqtt:mqtt@mqtt.local:1883/openwrtinfo -m &quot;$post_data&quot;<br></code></pre></td></tr></table></figure><p>4、在HA中增加配置文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mqtt:</span><br>  <span class="hljs-attr">sensor:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu_tem&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu_tem</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&#x27;°C&#x27;</span><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:thermometer&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.temp_cpu &#125;&#125;</span>&#x27;</span>        <br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu1_freq&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu1_freq</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&#x27;MHz&#x27;</span><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:pulse&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.cpu1_freq &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu2_freq&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu2_freq</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&#x27;MHz&#x27;</span><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:pulse&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.cpu2_freq &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu_used&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu_used</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&#x27;%&#x27;</span><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:cpu-64-bit&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.cpu_used &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_mem_used&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_mem_used</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">unit_of_measurement:</span> <span class="hljs-string">&#x27;%&#x27;</span><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:memory&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.mem_used &#125;&#125;</span>&#x27;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">mqtt</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_ssr_server&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_ssr_server</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:vpn&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.ssr_server &#125;&#125;</span>&#x27;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">mqtt</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_up_times&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_up_times</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br><br>        <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;mdi:clock-time-four-outline&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.up_times &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_name&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_name</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.hostname &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu_brand&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu_brand</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.cpu_brand &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_cpu_arch&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_cpu_arch</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.cpu_arch &#125;&#125;</span>&#x27;</span><br>        <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_kernel&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_kernel</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.kernel &#125;&#125;</span>&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_releases&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_releases</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.releases &#125;&#125;</span>&#x27;</span><br>        <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;openwrt_boottime&#x27;</span><br>        <span class="hljs-attr">unique_id:</span> <span class="hljs-string">openwrt_boottime</span><br>        <span class="hljs-attr">state_topic:</span> <span class="hljs-string">&#x27;openwrtinfo&#x27;</span><br>        <span class="hljs-attr">value_template:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; value_json.boot_time &#125;&#125;</span>&#x27;</span><br><br></code></pre></td></tr></table></figure><p>5、通过crontab任务调度或者写一个watch脚本循环调用，即可通过mqtt形式将采集到的信息推送到HA。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>while :<br>do<br>        if ! ps | grep -w openwrt_mqtt.sh | grep -v grep<br>        then                                    <br>                /opt/openwrt_mqtt.sh<br>        sleep 60#60秒取一次，可自行修改间隔<br>        fi                       <br>done<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>智能家居</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openwrt</tag>
      
      <tag>HomeAssistant</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用群晖自带的 Nginx 做反向代理实现Aria2 Https访问</title>
    <link href="/2022/10/28/%E5%88%A9%E7%94%A8%E7%BE%A4%E6%99%96%E8%87%AA%E5%B8%A6%E7%9A%84-Nginx-%E5%81%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0Aria2-Https%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/10/28/%E5%88%A9%E7%94%A8%E7%BE%A4%E6%99%96%E8%87%AA%E5%B8%A6%E7%9A%84-Nginx-%E5%81%9A%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0Aria2-Https%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h3><p>给Aria2服务器所用的SSL证书往往不支持Aria2所使用的6800端口，为此就需要用Nginx来实现同时提供HTTP和Aria2 JSONRPC服务了。但是群晖 <code>UI</code> 界面的反代没有办法编辑配置。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>想到的解决方案有两个，第一是通过 <code>Docker</code> 再装一个 <code>Nginx</code> 来做反代，第二是通过群晖自身的 <code>Nginx</code> 来做反代；最后选择了通过自身 <code>Nginx</code> 来做反代</p><h3 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h3><p><code>/usr/syno/etc/certificate/system/default/</code> 为群晖<code>安全性-&gt;证书</code>上传的默认证书的存储位置</p><p><code>5001</code> 端口为 <code>群晖</code> 的默认SSL访问端口，<code>6880、6800</code>为aria2 跟rpc的docker在用端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">5001</span> ssl http2;<br>    <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">5001</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span> dl.zjylyf.fun;<br>    <span class="hljs-attribute">ssl_certificate</span> /usr/syno/etc/certificate/system/default/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /usr/syno/etc/certificate/system/default/privkey.pem;<br>    <span class="hljs-comment">#ssl_session_cache   shared:SSL:50m;</span><br>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">4h</span>;<br>    <span class="hljs-attribute">ssl_protocols</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">ssl_buffer_size</span> <span class="hljs-number">4k</span>;<br><br>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$scheme</span> = http) &#123;<br>        <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;<br>    &#125;<br><br>  <br><br>    <span class="hljs-section">location</span> / &#123;<br><br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:6880;<br><br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>:<span class="hljs-variable">$server_port</span>;<br><br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br><br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br><br>        <span class="hljs-attribute">proxy_redirect</span> http:// https://;<br><br>    &#125;<br> <br><br>    <span class="hljs-section">location</span> /jsonrpc &#123;<br><br>    <span class="hljs-attribute">proxy_pass</span> http://localhost:6800/jsonrpc;<br><br>    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br><br>    <span class="hljs-attribute">proxy_set_header</span>        X-Real-IP       <span class="hljs-variable">$remote_addr</span>;<br><br>    <span class="hljs-attribute">proxy_set_header</span>        X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br><br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br><br>    <span class="hljs-comment">#以下代码使支持WebSocket</span><br><br>    <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br><br>    <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;upgrade&quot;</span>;<br><br>    &#125;<br><br><br><br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">403</span> <span class="hljs-number">404</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> <span class="hljs-variable">@error_page</span>;<br><br>  <br><br>    <span class="hljs-section">location</span> <span class="hljs-variable">@error_page</span> &#123;<br><br>        <span class="hljs-attribute">root</span> /usr/syno/share/nginx;<br><br>        <span class="hljs-attribute">rewrite</span> (.*) /<span class="hljs-literal">error</span>.html <span class="hljs-literal">break</span>;<br><br>        <span class="hljs-attribute">allow</span> all;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链接配置"><a href="#链接配置" class="headerlink" title="链接配置"></a>链接配置</h3><p>将配置文件链接到 <code>/etc/nginx/sites-enabled/</code> </p><p><code>ln -s /xx/xx/xxx.com.conf /etc/nginx/sites-enabled/</code></p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p><del>最后只需要重启 <code>Nginx</code> 即可</del></p><p><del><code>sudo systemctl --restart nginx</code></del><br>重载入nginx配置即可，无需重启nginx<br><code>nginx -s reload</code></p>]]></content>
    
    
    <categories>
      
      <category>群晖</category>
      
    </categories>
    
    
    <tags>
      
      <tag>群晖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows平台双网卡添加静态路由</title>
    <link href="/2022/07/29/Windows%E5%B9%B3%E5%8F%B0%E5%8F%8C%E7%BD%91%E5%8D%A1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/07/29/Windows%E5%B9%B3%E5%8F%B0%E5%8F%8C%E7%BD%91%E5%8D%A1%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="双网卡下添加静态路由"><a href="#双网卡下添加静态路由" class="headerlink" title="双网卡下添加静态路由"></a>双网卡下添加静态路由</h2><p><strong>系统平台：</strong> WIN10</p><p><strong>情况描述：</strong> 电脑上安装了2个网卡，一个连接外网（自动分配IP，路由地址为192.168.0.x），</p><p>一个连接内网（网卡静态IP为10.10.130.130，网关10.10.130.254，子网掩码255.255.255.0，内网网段10.37.0.0）</p><p><strong>任务目标：</strong> 按需访问内外网</p><p><strong>操作方法：</strong> 用管理员权限打开CMD,</p><ol><li><p>删除默认路由：输入 route delete 0.0.0.0 （ 0.0.0.0是指所有地址）</p></li><li><p>添加静态路由</p><ul><li>添加内网静态路由：route add 10.37.0.0 mask 255.255.0.0 10.10.130.254 -p</li></ul><p>注：它表示访问10.37.0.0网段的所有数据都要经过网关10.10.130.254，-p表示Persistent（持久有效的意思，重启后依然生效）</p><ul><li>添加外网静态路由：route add 0.0.0.0 mask 0.0.0.0 192.168.0.1 -p</li></ul><p>注：它表示访问0.0.0.0网址和0.0.0.0网段，即任意网址任意网段，访问经过外网网关192.168.0.1。</p></li><li><p>设置完成后，输入route print 看一下路由表是否添加成功，再ping内外网的网址测试下是否有效。</p></li></ol><hr><p><strong>知识点：</strong></p><p>ROUTE路由命令简单解说</p><p>ROUTE命令格式如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ROUTE [-<span class="hljs-type">f</span>] [-<span class="hljs-type">p</span>] [<span class="hljs-type">command</span> [<span class="hljs-type">destination</span>] [<span class="hljs-type">MASK</span> <span class="hljs-type">netmask</span>] [<span class="hljs-type">gateway</span>] [<span class="hljs-type">METRIC</span> <span class="hljs-type">metric</span>] [<span class="hljs-type">IF</span> <span class="hljs-built_in">int</span><span class="hljs-type">erface</span>]<br></code></pre></td></tr></table></figure><p>其中 –f 参数用于清除路由表，-p参数用于永久保留某条路由（即在系统重启时不会丢失路由）。</p><p>Command主要有PRINT（打印）、ADD（添加）、DELETE（删除）、CHANGE（修改）共4个命令。</p><p>Destination代表所要达到的目标IP地址。</p><p>MASK是子网掩码的关键字。Netmask代表具体的子网掩码，如果不加说明，默认是255.255.255.255（单机IP地址），因此键入掩码时候要特别小心，要确认添加的是某个IP地址还是IP网段。如果代表全部出口子网掩码可用0.0.0.0。</p><p>Gateway代表出口网关。</p><p>其他interface和metric分别代表特殊路由的接口数目和到达目标地址的代价，一般可不予理会。</p>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分享</tag>
      
      <tag>Windwos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Shell文本处理工具介绍</title>
    <link href="/2022/05/29/Linux-Shell%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/29/Linux-Shell%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="搞定-Linux-Shell-文本处理工具，看完这篇还不够"><a href="#搞定-Linux-Shell-文本处理工具，看完这篇还不够" class="headerlink" title="搞定 Linux Shell 文本处理工具，看完这篇还不够~"></a>搞定 Linux Shell 文本处理工具，看完这篇还不够~</h1><p>Linux Shell是一种基本功，由于怪异的语法加之较差的可读性，通常被Python等脚本代替。既然是基本功，那就需要掌握，毕竟学习Shell脚本的过程中，还是能了解到很多Linux系统的内容。</p><p>Linux 脚本大师不是人人都可以达到的，但是用一些简单的Shell实现一些常见的基本功能还是很有必要的。</p><p><strong>下面我介绍 Linux 下使用 Shell 处理文本时最常用的工具：</strong></p><p>find、grep、xargs、sort、uniq、tr、cut、paste、wc、sed、awk；</p><p>提供的例子和参数都是最常用和最为实用的；</p><p>我对shell脚本使用的原则是命令单行书写，尽量不要超过2行；</p><p>如果有更为复杂的任务需求，还是考虑python吧；</p><h3 id="1、find-文件查找"><a href="#1、find-文件查找" class="headerlink" title="1、find 文件查找"></a>1、find 文件查找</h3><p>查找txt和pdf文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \) -print<br></code></pre></td></tr></table></figure><p>正则方式查找.txt和pdf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -regex  &quot;.*\(\.txt|\.pdf\)$&quot;<br></code></pre></td></tr></table></figure><p><strong>-iregex： 忽略大小写的正则</strong></p><p>否定参数，查找所有非txt文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . ! -name &quot;*.txt&quot; -print<br></code></pre></td></tr></table></figure><p>指定搜索深度<br>打印出当前目录的文件（深度为1）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -maxdepth 1 -type f<br></code></pre></td></tr></table></figure><p><strong>定制搜索</strong></p><p>按类型搜索：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type d -print  //只列出所有目录<br></code></pre></td></tr></table></figure><p>-type f 文件 &#x2F; l 符号链接</p><p>按时间搜索：</p><ul><li>-atime 访问时间 (单位是天，分钟单位则是-amin，以下类似）</li><li>-mtime 修改时间 （内容被修改）</li><li>-ctime 变化时间 （元数据或权限变化）</li></ul><p>最近7天被访问过的所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -atime 7 -type f -print<br></code></pre></td></tr></table></figure><p>按大小搜索：<br>w字 k M G</p><p>寻找大于2k的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -size +2k<br></code></pre></td></tr></table></figure><p>按权限查找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -perm 644 -print //找具有可执行权限的所有文件<br></code></pre></td></tr></table></figure><p>按用户查找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -user weber -print// 找用户weber所拥有的文件<br></code></pre></td></tr></table></figure><p>找到后的后续动作</p><p>删除：<br>删除当前目录下所有的swp文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -name &quot;*.swp&quot; -delete<br></code></pre></td></tr></table></figure><p>执行动作（强大的exec）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -user root -exec chown weber &#123;&#125; \; //将当前目录下的所有权变更为weber<br></code></pre></td></tr></table></figure><blockquote><p>注：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；</p></blockquote><p>eg：将找到的文件全都copy到另一个目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -type f -mtime +10 -name &quot;*.txt&quot; -exec cp &#123;&#125; OLD \;<br></code></pre></td></tr></table></figure><p>结合多个命令<br>tips: 如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-exec ./commands.sh &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>-print的定界符</p><p>默认使用<code>&#39;\n&#39;</code>作为文件的定界符；<br>-print0 使用’\0’作为文件的定界符，这样就可以搜索包含空格的文件；</p><h3 id="2、grep-文本搜索"><a href="#2、grep-文本搜索" class="headerlink" title="2、grep 文本搜索"></a>2、grep 文本搜索</h3><p>grep match_patten file &#x2F;&#x2F; 默认访问匹配行</p><p><strong>常用参数</strong></p><ul><li>-o 只输出匹配的文本行 VS -v 只输出没有匹配的文本行</li><li>-c 统计文件中包含文本的次数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -c &quot;text&quot; filename<br></code></pre></td></tr></table></figure><ul><li>-n 打印匹配的行号</li><li>-i 搜索时忽略大小写</li><li>-l 只打印文件名</li></ul><p>在多级目录中对文本递归搜索(程序员搜代码的最爱）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep &quot;class&quot; . -R -n<br></code></pre></td></tr></table></figure><p>匹配多个模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -e &quot;class&quot; -e &quot;vitural&quot; file<br></code></pre></td></tr></table></figure><p>grep输出以\0作为结尾符的文件名：（-z）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep &quot;test&quot; file* -lZ| xargs -0 rm<br></code></pre></td></tr></table></figure><h3 id="3、xargs-命令行参数转换"><a href="#3、xargs-命令行参数转换" class="headerlink" title="3、xargs 命令行参数转换"></a>3、xargs 命令行参数转换</h3><p>xargs 能够将输入数据转化为特定命令的命令行参数；这样，可以配合很多命令来组合使用。比如 grep，比如 find；</p><p>将多行输出转化为单行输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file.txt| xargs<br></code></pre></td></tr></table></figure><p><code>\n</code>是多行文本间的定界符</p><p>将单行转化为多行输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat single.txt | xargs -n 3<br></code></pre></td></tr></table></figure><p>-n：指定每行显示的字段数</p><p>xargs参数说明</p><ul><li>-d 定义定界符 （默认为空格 多行的定界符为 \n）</li><li>-n 指定输出为多行</li><li>-I {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时</li></ul><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file.txt | xargs -I &#123;&#125; ./command.sh -p &#123;&#125; -1<br></code></pre></td></tr></table></figure><p>-0：指定\0为输入定界符<br>eg：统计程序行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find source_dir/ -type f -name &quot;*.cpp&quot; -print0 |xargs -0 wc -l<br></code></pre></td></tr></table></figure><h3 id="4、sort-排序"><a href="#4、sort-排序" class="headerlink" title="4、sort 排序"></a>4、sort 排序</h3><p>字段说明：</p><p>-n 按数字进行排序 VS -d 按字典序进行排序<br>-r 逆序排序<br>-k N 指定按第N列排序</p><p>eg：</p><p>sort -nrk 1 data.txt<br>sort -bd data &#x2F;&#x2F; 忽略像空格之类的前导空白字符</p><h3 id="5、uniq-消除重复行"><a href="#5、uniq-消除重复行" class="headerlink" title="5、uniq 消除重复行"></a>5、uniq 消除重复行</h3><p>消除重复行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort unsort.txt | uniq<br></code></pre></td></tr></table></figure><p>统计各行在文件中出现的次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort unsort.txt | uniq -c<br></code></pre></td></tr></table></figure><p>找出重复行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sort unsort.txt | uniq -d<br></code></pre></td></tr></table></figure><p>可指定每行中需要比较的重复内容：-s 开始位置 -w 比较字符数</p><h3 id="6、用tr进行转换"><a href="#6、用tr进行转换" class="headerlink" title="6、用tr进行转换"></a>6、用tr进行转换</h3><p>通用用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 12345 | tr &#x27;0-9&#x27; &#x27;9876543210&#x27; //加解密转换，替换对应字符cat text| tr &#x27;\t&#x27; &#x27; &#x27;  //制表符转空格<br></code></pre></td></tr></table></figure><p>tr删除字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file | tr -d &#x27;0-9&#x27; // 删除所有数字<br></code></pre></td></tr></table></figure><p>-c 求补集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file | tr -c &#x27;0-9&#x27; //获取文件中所有数字cat file | tr -d -c &#x27;0-9 \n&#x27;  //删除非数字数据<br></code></pre></td></tr></table></figure><p>tr压缩字符<br>tr -s 压缩文本中出现的重复字符；最常用于压缩多余的空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file | tr -s &#x27; &#x27;<br></code></pre></td></tr></table></figure><p>字符类</p><ul><li>tr中可用各种字符类：</li><li>alnum：字母和数字</li><li>alpha：字母</li><li>digit：数字</li><li>space：空白字符</li><li>lower：小写</li><li>upper：大写</li><li>cntrl：控制（非可打印）字符</li><li>print：可打印字符</li></ul><p>使用方法：tr [:class:] [:class:]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg: tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;<br></code></pre></td></tr></table></figure><h3 id="7、cut-按列切分文本"><a href="#7、cut-按列切分文本" class="headerlink" title="7、cut 按列切分文本"></a>7、cut 按列切分文本</h3><p>截取文件的第2列和第4列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cut -f2,4 filename<br></code></pre></td></tr></table></figure><p>去文件除第3列的所有列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cut -f3 --complement filename<br></code></pre></td></tr></table></figure><p>-d 指定定界符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat -f2 -d&quot;;&quot; filename<br></code></pre></td></tr></table></figure><p>cut 取的范围</p><ul><li>N- 第N个字段到结尾</li><li>-M 第1个字段为M<br>N-M N到M个字段</li></ul><p>cut 取的单位</p><ul><li>-b 以字节为单位</li><li>-c 以字符为单位</li><li>-f 以字段为单位（使用定界符）</li></ul><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cut -c1-5 file //打印第一到5个字符cut -c-2 file  //打印前2个字符<br></code></pre></td></tr></table></figure><h3 id="8、paste-按列拼接文本"><a href="#8、paste-按列拼接文本" class="headerlink" title="8、paste 按列拼接文本"></a>8、paste 按列拼接文本</h3><p>将两个文本按列拼接到一起;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat file112cat file2colinbook<br></code></pre></td></tr></table></figure><p>paste file1 file21 colin2 book<br>默认的定界符是制表符，可以用-d指明定界符<br>paste file1 file2 -d “,”<br>1,colin<br>2,book</p><h3 id="9、wc-统计行和字符的工具"><a href="#9、wc-统计行和字符的工具" class="headerlink" title="9、wc 统计行和字符的工具"></a>9、wc 统计行和字符的工具</h3><p>wc -l file &#x2F;&#x2F; 统计行数<br>wc -w file &#x2F;&#x2F; 统计单词数<br>wc -c file &#x2F;&#x2F; 统计字符数</p><h3 id="10、sed-文本替换利器"><a href="#10、sed-文本替换利器" class="headerlink" title="10、sed 文本替换利器"></a>10、sed 文本替换利器</h3><p>首处替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;s/text/replace_text/&#x27; file   //替换每一行的第一处匹配的text<br></code></pre></td></tr></table></figure><p>全局替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;s/text/replace_text/g&#x27; file<br></code></pre></td></tr></table></figure><p>默认替换后，输出替换后的内容，如果需要直接替换原文件,使用-i：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;s/text/repalce_text/g&#x27; file<br></code></pre></td></tr></table></figure><p>移除空白行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;/^$/d&#x27; file<br></code></pre></td></tr></table></figure><p>变量转换，已匹配的字符串通过标记&amp;来引用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo this is en example | sed &#x27;s/\w+/[&amp;]/g&#x27;$&gt;[this]  [is] [en] [example]<br>子串匹配标记<br>第一个匹配的括号内容使用标记 \1 来引用<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;s/hello\([0-9]\)/\1/&#x27;<br></code></pre></td></tr></table></figure><p>双引号求值</p><p>sed 通常用单引号来引用；也可使用双引号，使用双引号后，双引号会对表达式求值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;s/$var/HLLOE/&#x27;<br></code></pre></td></tr></table></figure><p>当使用双引号时，我们可以在sed样式和替换字符串中指定变量；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">eg:p=pattenr=replacedecho &quot;line con a patten&quot; | sed &quot;s/$p/$r/g&quot;$&gt;line con a replaced<br></code></pre></td></tr></table></figure><p>其它示例<br>字符串插入字符：将文本中每行内容（PEKSHA） 转换为 PEK&#x2F;SHA</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed &#x27;s/^.\&#123;3\&#125;/&amp;\//g&#x27; file<br></code></pre></td></tr></table></figure><h3 id="11、awk-数据流处理工具"><a href="#11、awk-数据流处理工具" class="headerlink" title="11、awk 数据流处理工具"></a>11、awk 数据流处理工具</h3><p>awk脚本结构<br>awk ‘ BEGIN{ statements } statements2 END{ statements } ‘</p><p>工作方式</p><ol><li>执行begin中语句块；</li><li>从文件或 stdin 中读入一行，然后执行 statements2，重复这个过程，直到文件全部被读取完毕；</li><li>执行end语句块；</li></ol><p>print 打印当前行</p><p>使用不带参数的print时，会打印当前行;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;line1\nline2&quot; | awk &#x27;BEGIN&#123;print &quot;start&quot;&#125; &#123;print &#125; END&#123; print &quot;End&quot; &#125;&#x27;<br></code></pre></td></tr></table></figure><p>print 以逗号分割时，参数以空格定界;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo | awk &#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; \print var1, var2 , var3; &#125;&#x27;$&gt;v1 V2 v3<br></code></pre></td></tr></table></figure><p>使用-拼接符的方式（””作为拼接符）;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo | awk &#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; \print var1&quot;-&quot;var2&quot;-&quot;var3; &#125;&#x27;$&gt;v1-V2-v3<br>特殊变量：NR NF $0 $1 $2<br></code></pre></td></tr></table></figure><p>NR:表示记录数量，在执行过程中对应当前行号；<br>NF:表示字段数量，在执行过程总对应当前行的字段数；<br>$0:这个变量包含执行过程中当前行的文本内容；<br>$1:第一个字段的文本内容；<br>$2:第二个字段的文本内容；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e “line1 f2 f3\n line2 \n line 3” | awk ‘&#123;print NR”:”1”-“$2&#125;’<br></code></pre></td></tr></table></figure><p>打印每一行的第二和第三个字段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;print $2, $3&#125;&#x27; file<br></code></pre></td></tr></table></figure><p>统计文件的行数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27; END &#123;print NR&#125;&#x27; file<br></code></pre></td></tr></table></figure><p>累加每一行的第一个字段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;1\n 2\n 3\n 4\n&quot; | awk &#x27;BEGIN&#123;num = 0 ;print &quot;begin&quot;;&#125; &#123;sum += $1;&#125; END &#123;print &quot;==&quot;; print sum &#125;&#x27;<br></code></pre></td></tr></table></figure><p>传递外部变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">var=1000echo | awk &#x27;&#123;print vara&#125;&#x27; vara=$var #  输入来自stdinawk &#x27;&#123;print vara&#125;&#x27; vara=$var file # 输入来自文件用样式对awk处理的行进行过滤<br></code></pre></td></tr></table></figure><p>awk ‘NR &lt; 5’ #行号小于5<br>awk ‘NR&#x3D;&#x3D;1,NR&#x3D;&#x3D;4 {print}’ file #行号等于1和4的打印出来<br>awk ‘&#x2F;linux&#x2F;‘ #包含linux文本的行（可以用正则表达式来指定，超级强大）<br>awk ‘!&#x2F;linux&#x2F;‘ #不包含linux文本的行</p><p>设置定界符</p><p>使用-F来设置定界符（默认为空格）<br>awk -F: ‘{print $NF}’ &#x2F;etc&#x2F;passwd</p><p>读取命令输出</p><p>使用getline，将外部shell命令的输出读入到变量cmdout中；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo | awk &#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print cmdout &#125;&#x27;<br></code></pre></td></tr></table></figure><p>在awk中使用循环</p><p>for(i&#x3D;0;i&lt;10;i++){print $i;}<br>for(i in array){print array[i];}</p><p>eg:<br>以逆序的形式打印行：(tac命令的实现）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">seq 9| \awk &#x27;&#123;lifo[NR] = $0; lno=NR&#125; \END&#123; for(;lno&gt;-1;lno--)&#123;print lifo[lno];&#125;&#125; &#x27;<br></code></pre></td></tr></table></figure><p><strong>awk实现head、tail命令</strong></p><p>head:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;NR&lt;=10&#123;print&#125;&#x27; filename<br></code></pre></td></tr></table></figure><p>tail：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;buffer[NR%10] = $0;&#125; END&#123;for(i=0;i&lt;11;i++)&#123; \print buffer[i %10]&#125; &#125; &#x27; filename<br></code></pre></td></tr></table></figure><p>打印指定列</p><p>awk方式实现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lrt | awk &#x27;&#123;print $6&#125;&#x27;<br></code></pre></td></tr></table></figure><p>cut方式实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -lrt | cut -f6<br></code></pre></td></tr></table></figure><p>打印指定文本区域</p><p>确定行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">seq 100| awk &#x27;NR==4,NR==6&#123;print&#125;&#x27;<br></code></pre></td></tr></table></figure><p>确定文本</p><p>打印处于start_pattern 和end_pattern之间的文本；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;/start_pattern/, /end_pattern/&#x27; filename<br></code></pre></td></tr></table></figure><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">seq 100 | awk &#x27;/13/,/15/&#x27;cat /etc/passwd| awk &#x27;/mai.*mail/,/news.*news/&#x27;<br></code></pre></td></tr></table></figure><p><strong>awk常用内建函数</strong></p><ul><li>index(string,search_string):返回search_string在string中出现的位置</li><li>sub(regex,replacement_str,string)：将正则匹配到的第一处内容替换为replacement_str;</li><li>match(regex,string):检查正则表达式是否能够匹配字符串；</li><li>length(string)：返回字符串长度</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo | awk &#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print length(cmdout) &#125;&#x27;<br></code></pre></td></tr></table></figure><p>printf 类似c语言中的printf，对输出进行格式化<br>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">seq 10 | awk &#x27;&#123;printf &quot;-&gt;%4s\n&quot;, $1&#125;&#x27;<br></code></pre></td></tr></table></figure><h3 id="12、迭代文件中的行、单词和字符"><a href="#12、迭代文件中的行、单词和字符" class="headerlink" title="12、迭代文件中的行、单词和字符"></a>12、迭代文件中的行、单词和字符</h3><p><strong>1. 迭代文件中的每一行</strong></p><p>while 循环法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">while read line;doecho $line;done &lt; file.txt改成子shell:cat file.txt | (while read line;do echo $line;done)<br></code></pre></td></tr></table></figure><p>awk法：<br>cat file.txt| awk ‘{print}’</p><p><strong>2.迭代一行中的每一个单词</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">for word in $line;do echo $word;done<br></code></pre></td></tr></table></figure><p><strong>3. 迭代每一个字符</strong></p><p>从字符串中提取一个字符；(bash文本切片）</p><p>返回变量word的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for((i=0;i&lt;$&#123;#word&#125;;i++))<br>do<br>echo $&#123;word:i:1);<br>done<br></code></pre></td></tr></table></figure><hr><blockquote><p>来自：大CC<br>链接：<a href="http://www.cnblogs.com/me115/p/3427319.html">http://www.cnblogs.com/me115/p/3427319.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分享</tag>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/1977/01/01/hello-world/"/>
    <url>/1977/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
